/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CNavbar.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CParticles.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Space_Grotesk%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-heading%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22spaceGrotesk%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Manrope%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-body%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22manrope%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-signature%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22signature%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Cglobals.css&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CNavbar.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CParticles.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Space_Grotesk%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-heading%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22spaceGrotesk%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Manrope%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-body%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22manrope%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-signature%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22signature%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Cglobals.css&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/Navbar.js */ \"(app-pages-browser)/./app/components/Navbar.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/Particles.js */ \"(app-pages-browser)/./app/components/Particles.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Space_Grotesk\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-heading\",\"display\":\"swap\"}],\"variableName\":\"spaceGrotesk\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.js\\\",\\\"import\\\":\\\"Space_Grotesk\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-heading\\\",\\\"display\\\":\\\"swap\\\"}],\\\"variableName\\\":\\\"spaceGrotesk\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Manrope\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-body\",\"display\":\"swap\"}],\"variableName\":\"manrope\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.js\\\",\\\"import\\\":\\\"Manrope\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-body\\\",\\\"display\\\":\\\"swap\\\"}],\\\"variableName\\\":\\\"manrope\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Dancing_Script\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-signature\",\"display\":\"swap\"}],\"variableName\":\"signature\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.js\\\",\\\"import\\\":\\\"Dancing_Script\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-signature\\\",\\\"display\\\":\\\"swap\\\"}],\\\"variableName\\\":\\\"signature\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNVU0VSJTVDRG93bmxvYWRzJTVDcG90JTVDYnVzLXRyYW5zcG9ydC1hcHAlNUNhcHAlNUNjb21wb25lbnRzJTVDTmF2YmFyLmpzJm1vZHVsZXM9QyUzQSU1Q1VzZXJzJTVDVVNFUiU1Q0Rvd25sb2FkcyU1Q3BvdCU1Q2J1cy10cmFuc3BvcnQtYXBwJTVDYXBwJTVDY29tcG9uZW50cyU1Q1BhcnRpY2xlcy5qcyZtb2R1bGVzPUMlM0ElNUNVc2VycyU1Q1VTRVIlNUNEb3dubG9hZHMlNUNwb3QlNUNidXMtdHJhbnNwb3J0LWFwcCU1Q25vZGVfbW9kdWxlcyU1Q25leHQlNUNmb250JTVDZ29vZ2xlJTVDdGFyZ2V0LmNzcyUzRiU3QiUyMnBhdGglMjIlM0ElMjJhcHAlNUMlNUNsYXlvdXQuanMlMjIlMkMlMjJpbXBvcnQlMjIlM0ElMjJTcGFjZV9Hcm90ZXNrJTIyJTJDJTIyYXJndW1lbnRzJTIyJTNBJTVCJTdCJTIyc3Vic2V0cyUyMiUzQSU1QiUyMmxhdGluJTIyJTVEJTJDJTIydmFyaWFibGUlMjIlM0ElMjItLWZvbnQtaGVhZGluZyUyMiUyQyUyMmRpc3BsYXklMjIlM0ElMjJzd2FwJTIyJTdEJTVEJTJDJTIydmFyaWFibGVOYW1lJTIyJTNBJTIyc3BhY2VHcm90ZXNrJTIyJTdEJm1vZHVsZXM9QyUzQSU1Q1VzZXJzJTVDVVNFUiU1Q0Rvd25sb2FkcyU1Q3BvdCU1Q2J1cy10cmFuc3BvcnQtYXBwJTVDbm9kZV9tb2R1bGVzJTVDbmV4dCU1Q2ZvbnQlNUNnb29nbGUlNUN0YXJnZXQuY3NzJTNGJTdCJTIycGF0aCUyMiUzQSUyMmFwcCU1QyU1Q2xheW91dC5qcyUyMiUyQyUyMmltcG9ydCUyMiUzQSUyMk1hbnJvcGUlMjIlMkMlMjJhcmd1bWVudHMlMjIlM0ElNUIlN0IlMjJzdWJzZXRzJTIyJTNBJTVCJTIybGF0aW4lMjIlNUQlMkMlMjJ2YXJpYWJsZSUyMiUzQSUyMi0tZm9udC1ib2R5JTIyJTJDJTIyZGlzcGxheSUyMiUzQSUyMnN3YXAlMjIlN0QlNUQlMkMlMjJ2YXJpYWJsZU5hbWUlMjIlM0ElMjJtYW5yb3BlJTIyJTdEJm1vZHVsZXM9QyUzQSU1Q1VzZXJzJTVDVVNFUiU1Q0Rvd25sb2FkcyU1Q3BvdCU1Q2J1cy10cmFuc3BvcnQtYXBwJTVDbm9kZV9tb2R1bGVzJTVDbmV4dCU1Q2ZvbnQlNUNnb29nbGUlNUN0YXJnZXQuY3NzJTNGJTdCJTIycGF0aCUyMiUzQSUyMmFwcCU1QyU1Q2xheW91dC5qcyUyMiUyQyUyMmltcG9ydCUyMiUzQSUyMkRhbmNpbmdfU2NyaXB0JTIyJTJDJTIyYXJndW1lbnRzJTIyJTNBJTVCJTdCJTIyc3Vic2V0cyUyMiUzQSU1QiUyMmxhdGluJTIyJTVEJTJDJTIydmFyaWFibGUlMjIlM0ElMjItLWZvbnQtc2lnbmF0dXJlJTIyJTJDJTIyZGlzcGxheSUyMiUzQSUyMnN3YXAlMjIlN0QlNUQlMkMlMjJ2YXJpYWJsZU5hbWUlMjIlM0ElMjJzaWduYXR1cmUlMjIlN0QmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNVU0VSJTVDRG93bmxvYWRzJTVDcG90JTVDYnVzLXRyYW5zcG9ydC1hcHAlNUNhcHAlNUNnbG9iYWxzLmNzcyZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDhLQUFtSDtBQUNuSCxvTEFBc0g7QUFDdEgsb2pCQUFtVTtBQUNuVSx3aEJBQXFUO0FBQ3JULG9qQkFBbVU7QUFDblUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz84MmUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcVVNFUlxcXFxEb3dubG9hZHNcXFxccG90XFxcXGJ1cy10cmFuc3BvcnQtYXBwXFxcXGFwcFxcXFxjb21wb25lbnRzXFxcXE5hdmJhci5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcVVNFUlxcXFxEb3dubG9hZHNcXFxccG90XFxcXGJ1cy10cmFuc3BvcnQtYXBwXFxcXGFwcFxcXFxjb21wb25lbnRzXFxcXFBhcnRpY2xlcy5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcVVNFUlxcXFxEb3dubG9hZHNcXFxccG90XFxcXGJ1cy10cmFuc3BvcnQtYXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGZvbnRcXFxcZ29vZ2xlXFxcXHRhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwiYXBwXFxcXFxcXFxsYXlvdXQuanNcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJTcGFjZV9Hcm90ZXNrXFxcIixcXFwiYXJndW1lbnRzXFxcIjpbe1xcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl0sXFxcInZhcmlhYmxlXFxcIjpcXFwiLS1mb250LWhlYWRpbmdcXFwiLFxcXCJkaXNwbGF5XFxcIjpcXFwic3dhcFxcXCJ9XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwic3BhY2VHcm90ZXNrXFxcIn1cIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXFVTRVJcXFxcRG93bmxvYWRzXFxcXHBvdFxcXFxidXMtdHJhbnNwb3J0LWFwcFxcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxmb250XFxcXGdvb2dsZVxcXFx0YXJnZXQuY3NzP3tcXFwicGF0aFxcXCI6XFxcImFwcFxcXFxcXFxcbGF5b3V0LmpzXFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiTWFucm9wZVxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJ2YXJpYWJsZVxcXCI6XFxcIi0tZm9udC1ib2R5XFxcIixcXFwiZGlzcGxheVxcXCI6XFxcInN3YXBcXFwifV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcIm1hbnJvcGVcXFwifVwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcVVNFUlxcXFxEb3dubG9hZHNcXFxccG90XFxcXGJ1cy10cmFuc3BvcnQtYXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGZvbnRcXFxcZ29vZ2xlXFxcXHRhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwiYXBwXFxcXFxcXFxsYXlvdXQuanNcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJEYW5jaW5nX1NjcmlwdFxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJ2YXJpYWJsZVxcXCI6XFxcIi0tZm9udC1zaWduYXR1cmVcXFwiLFxcXCJkaXNwbGF5XFxcIjpcXFwic3dhcFxcXCJ9XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwic2lnbmF0dXJlXFxcIn1cIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXFVTRVJcXFxcRG93bmxvYWRzXFxcXHBvdFxcXFxidXMtdHJhbnNwb3J0LWFwcFxcXFxhcHBcXFxcZ2xvYmFscy5jc3NcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CNavbar.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CParticles.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Space_Grotesk%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-heading%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22spaceGrotesk%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Manrope%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-body%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22manrope%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-signature%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22signature%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Cglobals.css&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSPlugin: function() { return /* binding */ CSSPlugin; },\n/* harmony export */   _createElement: function() { return /* binding */ _createElement; },\n/* harmony export */   _getBBox: function() { return /* binding */ _getBBox; },\n/* harmony export */   checkPrefix: function() { return /* binding */ _checkPropPrefix; },\n/* harmony export */   \"default\": function() { return /* binding */ CSSPlugin; }\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/gsap/gsap-core.js\");\n/*!\n * CSSPlugin 3.14.2\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar _win, _doc, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _reverting, _windowExists = function _windowExists() {\n    return \"object\" !== \"undefined\";\n}, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\\s,\\(]\\S/, _propertyAliases = {\n    autoAlpha: \"opacity,visibility\",\n    scale: \"scaleX,scaleY\",\n    alpha: \"opacity\"\n}, _renderCSSProp = function _renderCSSProp(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n}, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n}, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n}, //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderCSSPropWithBeginningAndEnd = function _renderCSSPropWithBeginningAndEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio === 1 ? data.e : ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n}, //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n    var value = data.s + data.c * ratio;\n    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n}, _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n    return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n}, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n}, _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n    return target.style[property] = value;\n}, _setterCSSProp = function _setterCSSProp(target, property, value) {\n    return target.style.setProperty(property, value);\n}, _setterTransform = function _setterTransform(target, property, value) {\n    return target._gsap[property] = value;\n}, _setterScale = function _setterScale(target, property, value) {\n    return target._gsap.scaleX = target._gsap.scaleY = value;\n}, _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache.scaleX = cache.scaleY = value;\n    cache.renderTransform(ratio, cache);\n}, _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache[property] = value;\n    cache.renderTransform(ratio, cache);\n}, _transformProp = \"transform\", _transformOriginProp = _transformProp + \"Origin\", _saveStyle = function _saveStyle(property, isNotCSS) {\n    var _this = this;\n    var target = this.target, style = target.style, cache = target._gsap;\n    if (property in _transformProps && style) {\n        this.tfm = this.tfm || {};\n        if (property !== \"transform\") {\n            property = _propertyAliases[property] || property;\n            ~property.indexOf(\",\") ? property.split(\",\").forEach(function(a) {\n                return _this.tfm[a] = _get(target, a);\n            }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to \"scaleX,scaleY\", thus we loop and apply them both.\n            property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\n        } else {\n            return _propertyAliases.transform.split(\",\").forEach(function(p) {\n                return _saveStyle.call(_this, p, isNotCSS);\n            });\n        }\n        if (this.props.indexOf(_transformProp) >= 0) {\n            return;\n        }\n        if (cache.svg) {\n            this.svgo = target.getAttribute(\"data-svg-origin\");\n            this.props.push(_transformOriginProp, isNotCSS, \"\");\n        }\n        property = _transformProp;\n    }\n    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n}, _removeIndependentTransforms = function _removeIndependentTransforms(style) {\n    if (style.translate) {\n        style.removeProperty(\"translate\");\n        style.removeProperty(\"scale\");\n        style.removeProperty(\"rotate\");\n    }\n}, _revertStyle = function _revertStyle() {\n    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;\n    for(i = 0; i < props.length; i += 3){\n        // stored like this: property, isNotCSS, value\n        if (!props[i + 1]) {\n            props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n        } else if (props[i + 1] === 2) {\n            // non-CSS value (function-based)\n            target[props[i]](props[i + 2]);\n        } else {\n            // non-CSS value (not function-based)\n            target[props[i]] = props[i + 2];\n        }\n    }\n    if (this.tfm) {\n        for(p in this.tfm){\n            cache[p] = this.tfm[p];\n        }\n        if (cache.svg) {\n            cache.renderTransform();\n            target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n        }\n        i = _reverting();\n        if ((!i || !i.isStart) && !style[_transformProp]) {\n            _removeIndependentTransforms(style);\n            if (cache.zOrigin && style[_transformOriginProp]) {\n                style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.\n                cache.zOrigin = 0;\n                cache.renderTransform();\n            }\n            cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.\n        }\n    }\n}, _getStyleSaver = function _getStyleSaver(target, properties) {\n    var saver = {\n        target: target,\n        props: [],\n        revert: _revertStyle,\n        save: _saveStyle\n    };\n    target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.\n    properties && target.style && target.nodeType && properties.split(\",\").forEach(function(p) {\n        return saver.save(p);\n    }); // make sure it's a DOM node too.\n    return saver;\n}, _supports3D, _createElement = function _createElement(type, ns) {\n    var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n    return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n}, _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n    var cs = getComputedStyle(target);\n    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\"; //css variables may not need caps swapped out for dashes and lowercase.\n}, _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"), _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n    var e = element || _tempDiv, s = e.style, i = 5;\n    if (property in s && !preferPrefix) {\n        return property;\n    }\n    property = property.charAt(0).toUpperCase() + property.substr(1);\n    while(i-- && !(_prefixes[i] + property in s)){}\n    return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n}, _initCore = function _initCore() {\n    if (_windowExists() && window.document) {\n        _win = window;\n        _doc = _win.document;\n        _docElement = _doc.documentElement;\n        _tempDiv = _createElement(\"div\") || {\n            style: {}\n        };\n        _tempDivStyler = _createElement(\"div\");\n        _transformProp = _checkPropPrefix(_transformProp);\n        _transformOriginProp = _transformProp + \"Origin\";\n        _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n        _supports3D = !!_checkPropPrefix(\"perspective\");\n        _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting;\n        _pluginInitted = 1;\n    }\n}, _getReparentedCloneBBox = function _getReparentedCloneBBox(target) {\n    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).\n    var owner = target.ownerSVGElement, svg = _createElement(\"svg\", owner && owner.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"), clone = target.cloneNode(true), bbox;\n    clone.style.display = \"block\";\n    svg.appendChild(clone);\n    _docElement.appendChild(svg);\n    try {\n        bbox = clone.getBBox();\n    } catch (e) {}\n    svg.removeChild(clone);\n    _docElement.removeChild(svg);\n    return bbox;\n}, _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n    var i = attributesArray.length;\n    while(i--){\n        if (target.hasAttribute(attributesArray[i])) {\n            return target.getAttribute(attributesArray[i]);\n        }\n    }\n}, _getBBox = function _getBBox(target) {\n    var bounds, cloned;\n    try {\n        bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n    } catch (error) {\n        bounds = _getReparentedCloneBBox(target);\n        cloned = 1;\n    }\n    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.\n    return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n        x: +_getAttributeFallbacks(target, [\n            \"x\",\n            \"cx\",\n            \"x1\"\n        ]) || 0,\n        y: +_getAttributeFallbacks(target, [\n            \"y\",\n            \"cy\",\n            \"y1\"\n        ]) || 0,\n        width: 0,\n        height: 0\n    } : bounds;\n}, _isSVG = function _isSVG(e) {\n    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n}, //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n    if (property) {\n        var style = target.style, first2Chars;\n        if (property in _transformProps && property !== _transformOriginProp) {\n            property = _transformProp;\n        }\n        if (style.removeProperty) {\n            first2Chars = property.substr(0, 2);\n            if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\n                //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be \"ms-transform\" instead of \"-ms-transform\" for IE9, for example)\n                property = \"-\" + property;\n            }\n            style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\n        } else {\n            //note: old versions of IE use \"removeAttribute()\" instead of \"removeProperty()\"\n            style.removeAttribute(property);\n        }\n    }\n}, _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n    plugin._pt = pt;\n    pt.b = beginning;\n    pt.e = end;\n    plugin._props.push(property);\n    return pt;\n}, _nonConvertibleUnits = {\n    deg: 1,\n    rad: 1,\n    turn: 1\n}, _nonStandardLayouts = {\n    grid: 1,\n    flex: 1\n}, //takes a single value like 20px and converts it to the unit specified, like \"%\", returning only the numeric amount.\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\n    var curValue = parseFloat(value) || 0, curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\", // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n    style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === \"svg\", measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"), amount = 100, toPixels = unit === \"px\", toPercent = unit === \"%\", px, parent, cache, isSVG;\n    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n        return curValue;\n    }\n    curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n    isSVG = target.getCTM && _isSVG(target);\n    if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n        px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n        return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);\n    }\n    style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n    parent = unit !== \"rem\" && ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n    if (isSVG) {\n        parent = (target.ownerSVGElement || {}).parentNode;\n    }\n    if (!parent || parent === _doc || !parent.appendChild) {\n        parent = _doc.body;\n    }\n    cache = parent._gsap;\n    if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache) {\n        return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);\n    } else {\n        if (toPercent && (property === \"height\" || property === \"width\")) {\n            // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.\n            var v = target.style[property];\n            target.style[property] = amount + unit;\n            px = target[measureProperty];\n            v ? target.style[property] = v : _removeProperty(target, property);\n        } else {\n            (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n            parent === target && (style.position = \"static\"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.\n            parent.appendChild(_tempDiv);\n            px = _tempDiv[measureProperty];\n            parent.removeChild(_tempDiv);\n            style.position = \"absolute\";\n        }\n        if (horizontal && toPercent) {\n            cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);\n            cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;\n            cache.width = parent[measureProperty];\n        }\n    }\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n}, _get = function _get(target, property, unit, uncache) {\n    var value;\n    _pluginInitted || _initCore();\n    if (property in _propertyAliases && property !== \"transform\") {\n        property = _propertyAliases[property];\n        if (~property.indexOf(\",\")) {\n            property = property.split(\",\")[0];\n        }\n    }\n    if (_transformProps[property] && property !== \"transform\") {\n        value = _parseTransform(target, uncache);\n        value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n    } else {\n        value = target.style[property];\n        if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n            value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === \"opacity\" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n        }\n    }\n    return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n}, _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n    // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    if (!start || start === \"none\") {\n        // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style (\"clipPath\" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as \"none\" whereas WebkitClipPath reports accurately like \"ellipse(100% 0% at 50% 0%)\", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n        var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);\n        if (s && s !== start) {\n            prop = p;\n            start = s;\n        } else if (prop === \"borderColor\") {\n            start = _getComputedProperty(target, \"borderTopColor\"); // Firefox bug: always reports \"borderColor\" as \"\", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n        }\n    }\n    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;\n    pt.b = start;\n    pt.e = end;\n    start += \"\"; // ensure values are strings\n    end += \"\";\n    if (end.substring(0, 6) === \"var(--\") {\n        end = _getComputedProperty(target, end.substring(4, end.indexOf(\")\")));\n    }\n    if (end === \"auto\") {\n        startValue = target.style[prop];\n        target.style[prop] = end;\n        end = _getComputedProperty(target, prop) || end;\n        startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\n    }\n    a = [\n        start,\n        end\n    ];\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n    start = a[0];\n    end = a[1];\n    startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    if (endValues.length) {\n        while(result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)){\n            endValue = result[0];\n            chunk = end.substring(index, result.index);\n            if (color) {\n                color = (color + 1) % 5;\n            } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n                color = 1;\n            }\n            if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n                startNum = parseFloat(startValue) || 0;\n                startUnit = startValue.substr((startNum + \"\").length);\n                endValue.charAt(1) === \"=\" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);\n                endNum = parseFloat(endValue);\n                endUnit = endValue.substr((endNum + \"\").length);\n                index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;\n                if (!endUnit) {\n                    //if something like \"perspective:300\" is passed in and we must add a unit to the end\n                    endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;\n                    if (index === end.length) {\n                        end += endUnit;\n                        pt.e += endUnit;\n                    }\n                }\n                if (startUnit !== endUnit) {\n                    startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n                } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n                pt._pt = {\n                    _next: pt._pt,\n                    p: chunk || matchIndex === 1 ? chunk : \",\",\n                    //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n                    s: startNum,\n                    c: endNum - startNum,\n                    m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n                };\n            }\n        }\n        pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n    } else {\n        pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n    }\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus \"this\" would refer to the plugin.\n    return pt;\n}, _keywordToPercent = {\n    top: \"0%\",\n    bottom: \"100%\",\n    left: \"0%\",\n    right: \"100%\",\n    center: \"50%\"\n}, _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n    var split = value.split(\" \"), x = split[0], y = split[1] || \"50%\";\n    if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n        //the user provided them in the wrong order, so flip them\n        value = x;\n        x = y;\n        y = value;\n    }\n    split[0] = _keywordToPercent[x] || x;\n    split[1] = _keywordToPercent[y] || y;\n    return split.join(\" \");\n}, _renderClearProps = function _renderClearProps(ratio, data) {\n    if (data.tween && data.tween._time === data.tween._dur) {\n        var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;\n        if (props === \"all\" || props === true) {\n            style.cssText = \"\";\n            clearTransforms = 1;\n        } else {\n            props = props.split(\",\");\n            i = props.length;\n            while(--i > -1){\n                prop = props[i];\n                if (_transformProps[prop]) {\n                    clearTransforms = 1;\n                    prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n                }\n                _removeProperty(target, prop);\n            }\n        }\n        if (clearTransforms) {\n            _removeProperty(target, _transformProp);\n            if (cache) {\n                cache.svg && target.removeAttribute(\"transform\");\n                style.scale = style.rotate = style.translate = \"none\";\n                _parseTransform(target, 1); // force all the cached values back to \"normal\"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.\n                cache.uncache = 1;\n                _removeIndependentTransforms(style);\n            }\n        }\n    }\n}, // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n    clearProps: function clearProps(plugin, target, property, endValue, tween) {\n        if (tween.data !== \"isFromStart\") {\n            var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n            pt.u = endValue;\n            pt.pr = -10;\n            pt.tween = tween;\n            plugin._props.push(property);\n            return 1;\n        }\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */ _identity2DMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n], _rotationalProperties = {}, _isNullTransform = function _isNullTransform(value) {\n    return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n}, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n    var matrixString = _getComputedProperty(target, _transformProp);\n    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);\n}, _getMatrix = function _getMatrix(target, force2D) {\n    var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;\n    if (cache.svg && target.getAttribute(\"transform\")) {\n        temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like \"translate(50,60) rotate(135,0,0)\" are parsed because it mashes it into a matrix.\n        matrix = [\n            temp.a,\n            temp.b,\n            temp.c,\n            temp.d,\n            temp.e,\n            temp.f\n        ];\n        return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n        //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n        //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not \"none\". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).\n        temp = style.display;\n        style.display = \"block\";\n        parent = target.parentNode;\n        if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {\n            // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375. Note: position: fixed elements report a null offsetParent but they could also be invisible because they're in an ancestor with display: none, so we check getBoundingClientRect(). We only want to alter the DOM if we absolutely have to because it can cause iframe content to reload, like a Vimeo video.\n            addedToDOM = 1; //flag\n            nextSibling = target.nextElementSibling;\n            _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n        }\n        matrix = _getComputedTransformMatrixAsArray(target);\n        temp ? style.display = temp : _removeProperty(target, \"display\");\n        if (addedToDOM) {\n            nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n        }\n    }\n    return force2D && matrix.length > 6 ? [\n        matrix[0],\n        matrix[1],\n        matrix[4],\n        matrix[5],\n        matrix[12],\n        matrix[13]\n    ] : matrix;\n}, _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(\" \"), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;\n    if (!originIsAbsolute) {\n        bounds = _getBBox(target);\n        xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin); // if (!(\"xOrigin\" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration\n    // \txOrigin -= bounds.x;\n    // \tyOrigin -= bounds.y;\n    // }\n    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n        //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n        xOrigin = x;\n        yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.\n    }\n    if (smooth || smooth !== false && cache.smooth) {\n        tx = xOrigin - xOriginOld;\n        ty = yOrigin - yOriginOld;\n        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n    } else {\n        cache.xOffset = cache.yOffset = 0;\n    }\n    cache.xOrigin = xOrigin;\n    cache.yOrigin = yOrigin;\n    cache.smooth = !!smooth;\n    cache.origin = origin;\n    cache.originIsAbsolute = !!originIsAbsolute;\n    target.style[_transformOriginProp] = \"0px 0px\"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).\n    if (pluginToAddPropTweensTo) {\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n    }\n    target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n}, _parseTransform = function _parseTransform(target, uncache) {\n    var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);\n    if (\"x\" in cache && !uncache && !cache.uncache) {\n        return cache;\n    }\n    var style = target.style, invertedScaleX = cache.scaleX < 0, px = \"px\", deg = \"deg\", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || \"0\", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;\n    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n    scaleX = scaleY = 1;\n    cache.svg = !!(target.getCTM && _isSVG(target));\n    if (cs.translate) {\n        // accommodate independent transforms by combining them into normal ones.\n        if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n            style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n        }\n        style.scale = style.rotate = style.translate = \"none\";\n    }\n    matrix = _getMatrix(target, cache.svg);\n    if (cache.svg) {\n        if (cache.uncache) {\n            // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + \"px \" + (cache.yOrigin - bbox.y) + \"px\". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.\n            t2 = target.getBBox();\n            origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n            t1 = \"\";\n        } else {\n            t1 = !uncache && target.getAttribute(\"data-svg-origin\"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.\n        }\n        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n    }\n    xOrigin = cache.xOrigin || 0;\n    yOrigin = cache.yOrigin || 0;\n    if (matrix !== _identity2DMatrix) {\n        a = matrix[0]; //a11\n        b = matrix[1]; //a21\n        c = matrix[2]; //a31\n        d = matrix[3]; //a41\n        x = a12 = matrix[4];\n        y = a22 = matrix[5]; //2D matrix\n        if (matrix.length === 6) {\n            scaleX = Math.sqrt(a * a + b * b);\n            scaleY = Math.sqrt(d * d + c * c);\n            rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).\n            skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n            skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n            if (cache.svg) {\n                x -= xOrigin - (xOrigin * a + yOrigin * c);\n                y -= yOrigin - (xOrigin * b + yOrigin * d);\n            } //3D matrix\n        } else {\n            a32 = matrix[6];\n            a42 = matrix[7];\n            a13 = matrix[8];\n            a23 = matrix[9];\n            a33 = matrix[10];\n            a43 = matrix[11];\n            x = matrix[12];\n            y = matrix[13];\n            z = matrix[14];\n            angle = _atan2(a32, a33);\n            rotationX = angle * _RAD2DEG; //rotationX\n            if (angle) {\n                cos = Math.cos(-angle);\n                sin = Math.sin(-angle);\n                t1 = a12 * cos + a13 * sin;\n                t2 = a22 * cos + a23 * sin;\n                t3 = a32 * cos + a33 * sin;\n                a13 = a12 * -sin + a13 * cos;\n                a23 = a22 * -sin + a23 * cos;\n                a33 = a32 * -sin + a33 * cos;\n                a43 = a42 * -sin + a43 * cos;\n                a12 = t1;\n                a22 = t2;\n                a32 = t3;\n            } //rotationY\n            angle = _atan2(-c, a33);\n            rotationY = angle * _RAD2DEG;\n            if (angle) {\n                cos = Math.cos(-angle);\n                sin = Math.sin(-angle);\n                t1 = a * cos - a13 * sin;\n                t2 = b * cos - a23 * sin;\n                t3 = c * cos - a33 * sin;\n                a43 = d * sin + a43 * cos;\n                a = t1;\n                b = t2;\n                c = t3;\n            } //rotationZ\n            angle = _atan2(b, a);\n            rotation = angle * _RAD2DEG;\n            if (angle) {\n                cos = Math.cos(angle);\n                sin = Math.sin(angle);\n                t1 = a * cos + b * sin;\n                t2 = a12 * cos + a22 * sin;\n                b = b * cos - a * sin;\n                a22 = a22 * cos - a12 * sin;\n                a = t1;\n                a12 = t2;\n            }\n            if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n                //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n                rotationX = rotation = 0;\n                rotationY = 180 - rotationY;\n            }\n            scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));\n            scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));\n            angle = _atan2(a12, a22);\n            skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n            perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n        }\n        if (cache.svg) {\n            //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n            t1 = target.getAttribute(\"transform\");\n            cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n            t1 && target.setAttribute(\"transform\", t1);\n        }\n    }\n    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n        if (invertedScaleX) {\n            scaleX *= -1;\n            skewX += rotation <= 0 ? 180 : -180;\n            rotation += rotation <= 0 ? 180 : -180;\n        } else {\n            scaleY *= -1;\n            skewX += skewX <= 0 ? 180 : -180;\n        }\n    }\n    uncache = uncache || cache.uncache;\n    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n    cache.z = z + px;\n    cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);\n    cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);\n    cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;\n    cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;\n    cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;\n    cache.skewX = skewX + deg;\n    cache.skewY = skewY + deg;\n    cache.transformPerspective = perspective + px;\n    if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\n        style[_transformOriginProp] = _firstTwoOnly(origin);\n    }\n    cache.xOffset = cache.yOffset = 0;\n    cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;\n    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n    cache.uncache = 0;\n    return cache;\n}, _firstTwoOnly = function _firstTwoOnly(value) {\n    return (value = value.split(\" \"))[0] + \" \" + value[1];\n}, //for handling transformOrigin values, stripping out the 3rd dimension\n_addPxTranslate = function _addPxTranslate(target, start, value) {\n    var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n}, _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n    cache.z = \"0px\";\n    cache.rotationY = cache.rotationX = \"0deg\";\n    cache.force3D = 0;\n    _renderCSSTransforms(ratio, cache);\n}, _zeroDeg = \"0deg\", _zeroPx = \"0px\", _endParenthesis = \") \", _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = \"\", use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n        var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;\n        angle = parseFloat(rotationX) * _DEG2RAD;\n        cos = Math.cos(angle);\n        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n    }\n    if (transformPerspective !== _zeroPx) {\n        transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n    }\n    if (xPercent || yPercent) {\n        transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n    }\n    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n        transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n    }\n    if (rotation !== _zeroDeg) {\n        transforms += \"rotate(\" + rotation + _endParenthesis;\n    }\n    if (rotationY !== _zeroDeg) {\n        transforms += \"rotateY(\" + rotationY + _endParenthesis;\n    }\n    if (rotationX !== _zeroDeg) {\n        transforms += \"rotateX(\" + rotationX + _endParenthesis;\n    }\n    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n        transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n    }\n    if (scaleX !== 1 || scaleY !== 1) {\n        transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n    }\n    target.style[_transformProp] = transforms || \"translate(0, 0)\";\n}, _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;\n    rotation = parseFloat(rotation);\n    skewX = parseFloat(skewX);\n    skewY = parseFloat(skewY);\n    if (skewY) {\n        //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n        skewY = parseFloat(skewY);\n        skewX += skewY;\n        rotation += skewY;\n    }\n    if (rotation || skewX) {\n        rotation *= _DEG2RAD;\n        skewX *= _DEG2RAD;\n        a11 = Math.cos(rotation) * scaleX;\n        a21 = Math.sin(rotation) * scaleX;\n        a12 = Math.sin(rotation - skewX) * -scaleY;\n        a22 = Math.cos(rotation - skewX) * scaleY;\n        if (skewX) {\n            skewY *= _DEG2RAD;\n            temp = Math.tan(skewX - skewY);\n            temp = Math.sqrt(1 + temp * temp);\n            a12 *= temp;\n            a22 *= temp;\n            if (skewY) {\n                temp = Math.tan(skewY);\n                temp = Math.sqrt(1 + temp * temp);\n                a11 *= temp;\n                a21 *= temp;\n            }\n        }\n        a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);\n        a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);\n        a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);\n        a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);\n    } else {\n        a11 = scaleX;\n        a22 = scaleY;\n        a21 = a12 = 0;\n    }\n    if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n        tx = _convertToUnit(target, \"x\", x, \"px\");\n        ty = _convertToUnit(target, \"y\", y, \"px\");\n    }\n    if (xOrigin || yOrigin || xOffset || yOffset) {\n        tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n        ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n    }\n    if (xPercent || yPercent) {\n        //The SVG spec doesn't support percentage-based translation in the \"transform\" attribute, so we merge it into the translation to simulate it.\n        temp = target.getBBox();\n        tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);\n        ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);\n    }\n    temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n    target.setAttribute(\"transform\", temp);\n    forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)\n}, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n    var cap = 360, isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + \"deg\", direction, pt;\n    if (isString) {\n        direction = endValue.split(\"_\")[1];\n        if (direction === \"short\") {\n            change %= cap;\n            if (change !== change % (cap / 2)) {\n                change += change < 0 ? cap : -cap;\n            }\n        }\n        if (direction === \"cw\" && change < 0) {\n            change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n        } else if (direction === \"ccw\" && change > 0) {\n            change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n        }\n    }\n    plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    pt.u = \"deg\";\n    plugin._props.push(property);\n    return pt;\n}, _assign = function _assign(target, source) {\n    // Internet Explorer doesn't have Object.assign(), so we recreate it here.\n    for(var p in source){\n        target[p] = source[p];\n    }\n    return target;\n}, _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n    //for handling cases where someone passes in a whole transform string, like transform: \"scale(2, 3) rotate(20deg) translateY(30em)\"\n    var startCache = _assign({}, target._gsap), exclude = \"perspective,force3D,transformOrigin,svgOrigin\", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;\n    if (startCache.svg) {\n        startValue = target.getAttribute(\"transform\");\n        target.setAttribute(\"transform\", \"\");\n        style[_transformProp] = transforms;\n        endCache = _parseTransform(target, 1);\n        _removeProperty(target, _transformProp);\n        target.setAttribute(\"transform\", startValue);\n    } else {\n        startValue = getComputedStyle(target)[_transformProp];\n        style[_transformProp] = transforms;\n        endCache = _parseTransform(target, 1);\n        style[_transformProp] = startValue;\n    }\n    for(p in _transformProps){\n        startValue = startCache[p];\n        endValue = endCache[p];\n        if (startValue !== endValue && exclude.indexOf(p) < 0) {\n            //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n            startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n            endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n            startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n            endNum = parseFloat(endValue);\n            plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n            plugin._pt.u = endUnit || 0;\n            plugin._props.push(p);\n        }\n    }\n    _assign(endCache, startCache);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"padding,margin,Width,Radius\", function(name, index) {\n    var t = \"Top\", r = \"Right\", b = \"Bottom\", l = \"Left\", props = (index < 3 ? [\n        t,\n        r,\n        b,\n        l\n    ] : [\n        t + l,\n        t + r,\n        b + r,\n        b + l\n    ]).map(function(side) {\n        return index < 2 ? name + side : \"border\" + side + name;\n    });\n    _specialProps[index > 1 ? \"border\" + name : name] = function(plugin, target, property, endValue, tween) {\n        var a, vars;\n        if (arguments.length < 4) {\n            // getter, passed target, property, and unit (from _get())\n            a = props.map(function(prop) {\n                return _get(plugin, prop, property);\n            });\n            vars = a.join(\" \");\n            return vars.split(a[0]).length === 5 ? a[0] : vars;\n        }\n        a = (endValue + \"\").split(\" \");\n        vars = {};\n        props.forEach(function(prop, i) {\n            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n        });\n        plugin.init(target, vars, tween);\n    };\n});\nvar CSSPlugin = {\n    name: \"css\",\n    register: _initCore,\n    targetTest: function targetTest(target) {\n        return target.style && target.nodeType;\n    },\n    init: function init(target, vars, tween, index, targets) {\n        var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps, finalTransformValue;\n        _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps\n        this.styles = this.styles || _getStyleSaver(target);\n        inlineProps = this.styles.props;\n        this.tween = tween;\n        for(p in vars){\n            if (p === \"autoRound\") {\n                continue;\n            }\n            endValue = vars[p];\n            if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {\n                continue;\n            }\n            type = typeof endValue;\n            specialProp = _specialProps[p];\n            if (type === \"function\") {\n                endValue = endValue.call(tween, index, target, targets);\n                type = typeof endValue;\n            }\n            if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n                endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);\n            }\n            if (specialProp) {\n                specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n            } else if (p.substr(0, 2) === \"--\") {\n                //CSS variable\n                startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n                endValue += \"\";\n                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;\n                if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {\n                    // colors don't have units\n                    startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n                    endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n                    endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n                }\n                this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n                props.push(p);\n                inlineProps.push(p, 0, style[p]);\n            } else if (type !== \"undefined\") {\n                if (startAt && p in startAt) {\n                    // in case someone hard-codes a complex value as the start, like top: \"calc(2vh / 2)\". Without this, it'd use the computed value (always in px)\n                    startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n                    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf(\"random(\") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));\n                    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + \"\") || startValue === \"auto\" || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || \"\"); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.\n                    (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p)); // can't work with relative values\n                } else {\n                    startValue = _get(target, p);\n                }\n                startNum = parseFloat(startValue);\n                relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n                relative && (endValue = endValue.substr(2));\n                endNum = parseFloat(endValue);\n                if (p in _propertyAliases) {\n                    if (p === \"autoAlpha\") {\n                        //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n                        if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n                            //if visibility is initially set to \"hidden\", we should interpret that as intent to make opacity 0 (a convenience)\n                            startNum = 0;\n                        }\n                        inlineProps.push(\"visibility\", 0, style.visibility);\n                        _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n                    }\n                    if (p !== \"scale\" && p !== \"transform\") {\n                        p = _propertyAliases[p];\n                        ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n                    }\n                }\n                isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n                if (isTransformRelated) {\n                    this.styles.save(p);\n                    finalTransformValue = endValue; // this is always the same as endValue except when it's a var(--) value, in which case we need to calculate the end value.\n                    if (type === \"string\" && endValue.substring(0, 6) === \"var(--\") {\n                        endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(\")\")));\n                        if (endValue.substring(0, 5) === \"calc(\") {\n                            var origPerspective = target.style.perspective;\n                            target.style.perspective = endValue;\n                            endValue = _getComputedProperty(target, \"perspective\");\n                            origPerspective ? target.style.perspective = origPerspective : _removeProperty(target, \"perspective\");\n                        }\n                        endNum = parseFloat(endValue);\n                    }\n                    if (!transformPropTween) {\n                        cache = target._gsap;\n                        cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:\"translateX(50vw)\"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.\n                        smooth = vars.smoothOrigin !== false && cache.smooth;\n                        transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n                        transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n                    }\n                    if (p === \"scale\") {\n                        this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n                        this._pt.u = 0;\n                        props.push(\"scaleY\", p);\n                        p += \"X\";\n                    } else if (p === \"transformOrigin\") {\n                        inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n                        endValue = _convertKeywordsToPercentages(endValue); //in case something like \"left top\" or \"bottom right\" is passed in. Convert to percentages.\n                        if (cache.svg) {\n                            _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n                        } else {\n                            endUnit = parseFloat(endValue.split(\" \")[2]) || 0; //handle the zOrigin separately!\n                            endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n                            _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n                        }\n                        continue;\n                    } else if (p === \"svgOrigin\") {\n                        _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n                        continue;\n                    } else if (p in _rotationalProperties) {\n                        _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);\n                        continue;\n                    } else if (p === \"smoothOrigin\") {\n                        _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n                        continue;\n                    } else if (p === \"force3D\") {\n                        cache[p] = endValue;\n                        continue;\n                    } else if (p === \"transform\") {\n                        _addRawTransformPTs(this, endValue, target);\n                        continue;\n                    }\n                } else if (!(p in style)) {\n                    p = _checkPropPrefix(p) || p;\n                }\n                if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n                    startUnit = (startValue + \"\").substr((startNum + \"\").length);\n                    endNum || (endNum = 0); // protect against NaN\n                    endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);\n                    startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n                    this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n                    this._pt.u = endUnit || 0;\n                    if (isTransformRelated && finalTransformValue !== endValue) {\n                        this._pt.b = startValue;\n                        this._pt.e = finalTransformValue;\n                        this._pt.r = _renderCSSPropWithBeginningAndEnd;\n                    } else if (startUnit !== endUnit && endUnit !== \"%\") {\n                        //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a \"b\" (beginning) property and point to a render method that handles that. (performance optimization)\n                        this._pt.b = startValue;\n                        this._pt.r = _renderCSSPropWithBeginning;\n                    }\n                } else if (!(p in style)) {\n                    if (p in target) {\n                        //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.\n                        this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n                    } else if (p !== \"parseTransform\") {\n                        (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);\n                        continue;\n                    }\n                } else {\n                    _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n                }\n                isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === \"function\" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));\n                props.push(p);\n            }\n        }\n        hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);\n    },\n    render: function render(ratio, data) {\n        if (data.tween._time || !_reverting()) {\n            var pt = data._pt;\n            while(pt){\n                pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n        } else {\n            data.styles.revert();\n        }\n    },\n    get: _get,\n    aliases: _propertyAliases,\n    getSetter: function getSetter(target, property, plugin) {\n        //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like \"x\" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.\n        var p = _propertyAliases[property];\n        p && p.indexOf(\",\") < 0 && (property = p);\n        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);\n    },\n    core: {\n        _removeProperty: _removeProperty,\n        _getMatrix: _getMatrix\n    }\n};\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver;\n(function(positionAndScale, rotation, others, aliases) {\n    var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + \",\" + rotation + \",\" + others, function(name) {\n        _transformProps[name] = 1;\n    });\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function(name) {\n        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"deg\";\n        _rotationalProperties[name] = 1;\n    });\n    _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function(name) {\n        var split = name.split(\":\");\n        _propertyAliases[split[1]] = all[split[0]];\n    });\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function(name) {\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"px\";\n});\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nc2FwL0NTU1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BLEdBRUEsa0JBQWtCLEdBRU07QUFFeEIsSUFBSTJCLE1BQ0FDLE1BQ0FDLGFBQ0FDLGdCQUNBQyxVQUNBQyxnQkFDQUMscUJBQ0FDLFlBQ0FDLGdCQUFnQixTQUFTQTtJQUMzQixPQUFPLGFBQWtCO0FBQzNCLEdBQ0lDLGtCQUFrQixDQUFDLEdBQ25CQyxXQUFXLE1BQU1DLEtBQUtDLEVBQUUsRUFDeEJDLFdBQVdGLEtBQUtDLEVBQUUsR0FBRyxLQUNyQkUsU0FBU0gsS0FBS0ksS0FBSyxFQUNuQkMsVUFBVSxLQUNWQyxXQUFXLFlBQ1hDLGlCQUFpQix3Q0FDakJDLGNBQWMsYUFDZEMsbUJBQW1CO0lBQ3JCQyxXQUFXO0lBQ1hDLE9BQU87SUFDUEMsT0FBTztBQUNULEdBQ0lDLGlCQUFpQixTQUFTQSxlQUFlQyxLQUFLLEVBQUVDLElBQUk7SUFDdEQsT0FBT0EsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxDQUFDLEVBQUVGLEtBQUtHLENBQUMsRUFBRWxCLEtBQUttQixLQUFLLENBQUMsQ0FBQ0osS0FBS0ssQ0FBQyxHQUFHTCxLQUFLTSxDQUFDLEdBQUdQLEtBQUksSUFBSyxTQUFTLFFBQVFDLEtBQUtPLENBQUMsRUFBRVA7QUFDbEcsR0FDSVEscUJBQXFCLFNBQVNBLG1CQUFtQlQsS0FBSyxFQUFFQyxJQUFJO0lBQzlELE9BQU9BLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsQ0FBQyxFQUFFRixLQUFLRyxDQUFDLEVBQUVKLFVBQVUsSUFBSUMsS0FBS1MsQ0FBQyxHQUFHeEIsS0FBS21CLEtBQUssQ0FBQyxDQUFDSixLQUFLSyxDQUFDLEdBQUdMLEtBQUtNLENBQUMsR0FBR1AsS0FBSSxJQUFLLFNBQVMsUUFBUUMsS0FBS08sQ0FBQyxFQUFFUDtBQUN6SCxHQUNJVSw4QkFBOEIsU0FBU0EsNEJBQTRCWCxL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Q0ZwUSwrQ0FBSUEsQ0FBQzJYLEtBQUssQ0FBQ0MsV0FBVyxHQUFHcFA7QUFDekJ4SSwrQ0FBSUEsQ0FBQzBILElBQUksQ0FBQ21RLGFBQWEsR0FBR3hRO0FBRXpCLFVBQVV5USxnQkFBZ0IsRUFBRXpGLFFBQVEsRUFBRTBGLE1BQU0sRUFBRU4sT0FBTztJQUNwRCxJQUFJTyxNQUFNdlgsMkRBQVlBLENBQUNxWCxtQkFBbUIsTUFBTXpGLFdBQVcsTUFBTTBGLFFBQVEsU0FBVWxDLElBQUk7UUFDckZ6VCxlQUFlLENBQUN5VCxLQUFLLEdBQUc7SUFDMUI7SUFFQXBWLDJEQUFZQSxDQUFDNFIsVUFBVSxTQUFVd0QsSUFBSTtRQUNuQzVVLGtEQUFPQSxDQUFDeU4sS0FBSyxDQUFDbUgsS0FBSyxHQUFHO1FBQ3RCOUYscUJBQXFCLENBQUM4RixLQUFLLEdBQUc7SUFDaEM7SUFFQTlTLGdCQUFnQixDQUFDaVYsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHRixtQkFBbUIsTUFBTXpGO0lBRXJENVIsMkRBQVlBLENBQUNnWCxTQUFTLFNBQVU1QixJQUFJO1FBQ2xDLElBQUlqUSxRQUFRaVEsS0FBS2pRLEtBQUssQ0FBQztRQUN2QjdDLGdCQUFnQixDQUFDNkMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHb1MsR0FBRyxDQUFDcFMsS0FBSyxDQUFDLEVBQUUsQ0FBQztJQUM1QztBQUNGLEdBQUcsK0NBQStDLDRDQUE0QyxpRkFBaUY7QUFFL0tuRiwyREFBWUEsQ0FBQyxnRkFBZ0YsU0FBVW9WLElBQUk7SUFDekc1VSxrREFBT0EsQ0FBQ3lOLEtBQUssQ0FBQ21ILEtBQUssR0FBRztBQUN4QjtBQUVBN1YsK0NBQUlBLENBQUNpWSxjQUFjLENBQUM5QjtBQUN1RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanM/OTYwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENTU1BsdWdpbiAzLjE0LjJcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDI1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2VcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtIC8vZm9yIHRoZSBjb21tZW50ZWQtb3V0IGNsYXNzTmFtZSBmZWF0dXJlLlxufSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcblxudmFyIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfcGx1Z2luSW5pdHRlZCxcbiAgICBfdGVtcERpdixcbiAgICBfdGVtcERpdlN0eWxlcixcbiAgICBfcmVjZW50U2V0dGVyUGx1Z2luLFxuICAgIF9yZXZlcnRpbmcsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX2hvcml6b250YWxFeHAgPSAvKGxlZnR8cmlnaHR8d2lkdGh8bWFyZ2lufHBhZGRpbmd8eCkvaSxcbiAgICBfY29tcGxleEV4cCA9IC9bXFxzLFxcKF1cXFMvLFxuICAgIF9wcm9wZXJ0eUFsaWFzZXMgPSB7XG4gIGF1dG9BbHBoYTogXCJvcGFjaXR5LHZpc2liaWxpdHlcIixcbiAgc2NhbGU6IFwic2NhbGVYLHNjYWxlWVwiLFxuICBhbHBoYTogXCJvcGFjaXR5XCJcbn0sXG4gICAgX3JlbmRlckNTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BXaXRoRW5kID0gZnVuY3Rpb24gX3JlbmRlclByb3BXaXRoRW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPT09IDEgPyBkYXRhLmUgOiBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyhyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICAvL2lmIHVuaXRzIGNoYW5nZSwgd2UgbmVlZCBhIHdheSB0byByZW5kZXIgdGhlIG9yaWdpbmFsIHVuaXQvdmFsdWUgd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgKHJhdGlvOjApXG5fcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmdBbmRFbmQgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmdBbmRFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IHJhdGlvID8gTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICAvL2lmIHVuaXRzIGNoYW5nZSwgd2UgbmVlZCBhIHdheSB0byByZW5kZXIgdGhlIG9yaWdpbmFsIHVuaXQvdmFsdWUgd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgKHJhdGlvOjApXG5fcmVuZGVyUm91bmRlZENTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyUm91bmRlZENTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YS5zICsgZGF0YS5jICogcmF0aW87XG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCB+fih2YWx1ZSArICh2YWx1ZSA8IDAgPyAtLjUgOiAuNSkpICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZShyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvICE9PSAxID8gZGF0YS5iIDogZGF0YS5lLCBkYXRhKTtcbn0sXG4gICAgX3NldHRlckNTU1N0eWxlID0gZnVuY3Rpb24gX3NldHRlckNTU1N0eWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJDU1NQcm9wID0gZnVuY3Rpb24gX3NldHRlckNTU1Byb3AodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGUgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcC5zY2FsZVggPSB0YXJnZXQuX2dzYXAuc2NhbGVZID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIixcbiAgICBfc2F2ZVN0eWxlID0gZnVuY3Rpb24gX3NhdmVTdHlsZShwcm9wZXJ0eSwgaXNOb3RDU1MpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgc3R5bGUpIHtcbiAgICB0aGlzLnRmbSA9IHRoaXMudGZtIHx8IHt9O1xuXG4gICAgaWYgKHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldIHx8IHByb3BlcnR5O1xuICAgICAgfnByb3BlcnR5LmluZGV4T2YoXCIsXCIpID8gcHJvcGVydHkuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnRmbVthXSA9IF9nZXQodGFyZ2V0LCBhKTtcbiAgICAgIH0pIDogdGhpcy50Zm1bcHJvcGVydHldID0gY2FjaGUueCA/IGNhY2hlW3Byb3BlcnR5XSA6IF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSk7IC8vIG5vdGU6IHNjYWxlIHdvdWxkIG1hcCB0byBcInNjYWxlWCxzY2FsZVlcIiwgdGh1cyB3ZSBsb29wIGFuZCBhcHBseSB0aGVtIGJvdGguXG5cbiAgICAgIHByb3BlcnR5ID09PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGhpcy50Zm0uek9yaWdpbiA9IGNhY2hlLnpPcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3Byb3BlcnR5QWxpYXNlcy50cmFuc2Zvcm0uc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIF9zYXZlU3R5bGUuY2FsbChfdGhpcywgcCwgaXNOb3RDU1MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuaW5kZXhPZihfdHJhbnNmb3JtUHJvcCkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIHRoaXMuc3ZnbyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7XG4gICAgICB0aGlzLnByb3BzLnB1c2goX3RyYW5zZm9ybU9yaWdpblByb3AsIGlzTm90Q1NTLCBcIlwiKTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICB9XG5cbiAgKHN0eWxlIHx8IGlzTm90Q1NTKSAmJiB0aGlzLnByb3BzLnB1c2gocHJvcGVydHksIGlzTm90Q1NTLCBzdHlsZVtwcm9wZXJ0eV0pO1xufSxcbiAgICBfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSkge1xuICBpZiAoc3R5bGUudHJhbnNsYXRlKSB7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2xhdGVcIik7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJzY2FsZVwiKTtcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInJvdGF0ZVwiKTtcbiAgfVxufSxcbiAgICBfcmV2ZXJ0U3R5bGUgPSBmdW5jdGlvbiBfcmV2ZXJ0U3R5bGUoKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBpLFxuICAgICAgcDtcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAvLyBzdG9yZWQgbGlrZSB0aGlzOiBwcm9wZXJ0eSwgaXNOb3RDU1MsIHZhbHVlXG4gICAgaWYgKCFwcm9wc1tpICsgMV0pIHtcbiAgICAgIHByb3BzW2kgKyAyXSA/IHN0eWxlW3Byb3BzW2ldXSA9IHByb3BzW2kgKyAyXSA6IHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BzW2ldLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiID8gcHJvcHNbaV0gOiBwcm9wc1tpXS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9IGVsc2UgaWYgKHByb3BzW2kgKyAxXSA9PT0gMikge1xuICAgICAgLy8gbm9uLUNTUyB2YWx1ZSAoZnVuY3Rpb24tYmFzZWQpXG4gICAgICB0YXJnZXRbcHJvcHNbaV1dKHByb3BzW2kgKyAyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vbi1DU1MgdmFsdWUgKG5vdCBmdW5jdGlvbi1iYXNlZClcbiAgICAgIHRhcmdldFtwcm9wc1tpXV0gPSBwcm9wc1tpICsgMl07XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudGZtKSB7XG4gICAgZm9yIChwIGluIHRoaXMudGZtKSB7XG4gICAgICBjYWNoZVtwXSA9IHRoaXMudGZtW3BdO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB0aGlzLnN2Z28gfHwgXCJcIik7XG4gICAgfVxuXG4gICAgaSA9IF9yZXZlcnRpbmcoKTtcblxuICAgIGlmICgoIWkgfHwgIWkuaXNTdGFydCkgJiYgIXN0eWxlW190cmFuc2Zvcm1Qcm9wXSkge1xuICAgICAgX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSk7XG5cbiAgICAgIGlmIChjYWNoZS56T3JpZ2luICYmIHN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSkge1xuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gKz0gXCIgXCIgKyBjYWNoZS56T3JpZ2luICsgXCJweFwiOyAvLyBzaW5jZSB3ZSdyZSB1bmNhY2hpbmcsIHdlIG11c3QgcHV0IHRoZSB6T3JpZ2luIGJhY2sgaW50byB0aGUgdHJhbnNmb3JtT3JpZ2luIHNvIHRoYXQgd2UgY2FuIHB1bGwgaXQgb3V0IGFjY3VyYXRlbHkgd2hlbiB3ZSBwYXJzZSBhZ2Fpbi4gT3RoZXJ3aXNlLCB3ZSdkIGxvc2UgdGhlIHogcG9ydGlvbiBvZiB0aGUgb3JpZ2luIHNpbmNlIHdlIGV4dHJhY3QgaXQgdG8gcHJvdGVjdCBmcm9tIFNhZmFyaSBidWdzLlxuXG4gICAgICAgIGNhY2hlLnpPcmlnaW4gPSAwO1xuICAgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgIH1cblxuICAgICAgY2FjaGUudW5jYWNoZSA9IDE7IC8vIGlmIGl0J3MgYSBzdGFydEF0IHRoYXQncyBiZWluZyByZXZlcnRlZCBpbiB0aGUgX2luaXRUd2VlbigpIG9mIHRoZSBjb3JlLCB3ZSBkb24ndCBuZWVkIHRvIHVuY2FjaGUgdHJhbnNmb3Jtcy4gVGhpcyBpcyBwdXJlbHkgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAgfVxuICB9XG59LFxuICAgIF9nZXRTdHlsZVNhdmVyID0gZnVuY3Rpb24gX2dldFN0eWxlU2F2ZXIodGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBzYXZlciA9IHtcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICBwcm9wczogW10sXG4gICAgcmV2ZXJ0OiBfcmV2ZXJ0U3R5bGUsXG4gICAgc2F2ZTogX3NhdmVTdHlsZVxuICB9O1xuICB0YXJnZXQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCk7IC8vIGp1c3QgbWFrZSBzdXJlIHRoZXJlJ3MgYSBfZ3NhcCBjYWNoZSBkZWZpbmVkIGJlY2F1c2Ugd2UgcmVhZCBmcm9tIGl0IGluIF9zYXZlU3R5bGUoKSBhbmQgaXQncyBtb3JlIGVmZmljaWVudCB0byBqdXN0IGNoZWNrIGl0IGhlcmUgb25jZS5cblxuICBwcm9wZXJ0aWVzICYmIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQubm9kZVR5cGUgJiYgcHJvcGVydGllcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBzYXZlci5zYXZlKHApO1xuICB9KTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBET00gbm9kZSB0b28uXG5cbiAgcmV0dXJuIHNhdmVyO1xufSxcbiAgICBfc3VwcG9ydHMzRCxcbiAgICBfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KHR5cGUsIG5zKSB7XG4gIHZhciBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUygobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBzZXJ2ZXJzIHN3YXAgaW4gaHR0cHMgZm9yIGh0dHAgaW4gdGhlIG5hbWVzcGFjZSB3aGljaCBjYW4gYnJlYWsgdGhpbmdzLCBtYWtpbmcgXCJzdHlsZVwiIGluYWNjZXNzaWJsZS5cblxuICByZXR1cm4gZSAmJiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjAyMTUtcHJvYmxlbS11c2luZy10d2Vlbm1heC1pbi1zdGFuZGFsb25lLXNlbGYtY29udGFpbmluZy1zdmctZmlsZS1lcnItY2Fubm90LXNldC1wcm9wZXJ0eS1jc3N0ZXh0LW9mLXVuZGVmaW5lZC8pLlxufSxcbiAgICBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHNraXBQcmVmaXhGYWxsYmFjaykge1xuICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIHJldHVybiBjc1twcm9wZXJ0eV0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSB8fCAhc2tpcFByZWZpeEZhbGxiYWNrICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSkgfHwgcHJvcGVydHksIDEpIHx8IFwiXCI7IC8vY3NzIHZhcmlhYmxlcyBtYXkgbm90IG5lZWQgY2FwcyBzd2FwcGVkIG91dCBmb3IgZGFzaGVzIGFuZCBsb3dlcmNhc2UuXG59LFxuICAgIF9wcmVmaXhlcyA9IFwiTyxNb3osbXMsTXMsV2Via2l0XCIuc3BsaXQoXCIsXCIpLFxuICAgIF9jaGVja1Byb3BQcmVmaXggPSBmdW5jdGlvbiBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5LCBlbGVtZW50LCBwcmVmZXJQcmVmaXgpIHtcbiAgdmFyIGUgPSBlbGVtZW50IHx8IF90ZW1wRGl2LFxuICAgICAgcyA9IGUuc3R5bGUsXG4gICAgICBpID0gNTtcblxuICBpZiAocHJvcGVydHkgaW4gcyAmJiAhcHJlZmVyUHJlZml4KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgcHJvcGVydHkgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcblxuICB3aGlsZSAoaS0tICYmICEoX3ByZWZpeGVzW2ldICsgcHJvcGVydHkgaW4gcykpIHt9XG5cbiAgcmV0dXJuIGkgPCAwID8gbnVsbCA6IChpID09PSAzID8gXCJtc1wiIDogaSA+PSAwID8gX3ByZWZpeGVzW2ldIDogXCJcIikgKyBwcm9wZXJ0eTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBpZiAoX3dpbmRvd0V4aXN0cygpICYmIHdpbmRvdy5kb2N1bWVudCkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IF93aW4uZG9jdW1lbnQ7XG4gICAgX2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpIHx8IHtcbiAgICAgIHN0eWxlOiB7fVxuICAgIH07XG4gICAgX3RlbXBEaXZTdHlsZXIgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoX3RyYW5zZm9ybVByb3ApO1xuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuICAgIF90ZW1wRGl2LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlci13aWR0aDowO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7cGFkZGluZzowXCI7IC8vbWFrZSBzdXJlIHRvIG92ZXJyaWRlIGNlcnRhaW4gcHJvcGVydGllcyB0aGF0IG1heSBjb250YW1pbmF0ZSBtZWFzdXJlbWVudHMsIGluIGNhc2UgdGhlIHVzZXIgaGFzIG92ZXJyZWFjaGluZyBzdHlsZSBzaGVldHMuXG5cbiAgICBfc3VwcG9ydHMzRCA9ICEhX2NoZWNrUHJvcFByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuICAgIF9yZXZlcnRpbmcgPSBnc2FwLmNvcmUucmV2ZXJ0aW5nO1xuICAgIF9wbHVnaW5Jbml0dGVkID0gMTtcbiAgfVxufSxcbiAgICBfZ2V0UmVwYXJlbnRlZENsb25lQkJveCA9IGZ1bmN0aW9uIF9nZXRSZXBhcmVudGVkQ2xvbmVCQm94KHRhcmdldCkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgb3duZXIgPSB0YXJnZXQub3duZXJTVkdFbGVtZW50LFxuICAgICAgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgb3duZXIgJiYgb3duZXIuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIGNsb25lID0gdGFyZ2V0LmNsb25lTm9kZSh0cnVlKSxcbiAgICAgIGJib3g7XG5cbiAgY2xvbmUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgc3ZnLmFwcGVuZENoaWxkKGNsb25lKTtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHRyeSB7XG4gICAgYmJveCA9IGNsb25lLmdldEJCb3goKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBzdmcucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgcmV0dXJuIGJib3g7XG59LFxuICAgIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3MgPSBmdW5jdGlvbiBfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgYXR0cmlidXRlc0FycmF5KSB7XG4gIHZhciBpID0gYXR0cmlidXRlc0FycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldEJCb3ggPSBmdW5jdGlvbiBfZ2V0QkJveCh0YXJnZXQpIHtcbiAgdmFyIGJvdW5kcywgY2xvbmVkO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldFJlcGFyZW50ZWRDbG9uZUJCb3godGFyZ2V0KTtcbiAgICBjbG9uZWQgPSAxO1xuICB9XG5cbiAgYm91bmRzICYmIChib3VuZHMud2lkdGggfHwgYm91bmRzLmhlaWdodCkgfHwgY2xvbmVkIHx8IChib3VuZHMgPSBfZ2V0UmVwYXJlbnRlZENsb25lQkJveCh0YXJnZXQpKTsgLy9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIG1pc3JlcG9ydCB0aGUgYm91bmRzIGlmIHRoZSBlbGVtZW50IGhhcyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgKGl0IGp1c3QgYXNzdW1lcyBpdCdzIGF0IHg6MCwgeTowKSwgdGh1cyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGdyYWIgdGhlIHBvc2l0aW9uIGluIHRoYXQgY2FzZS5cblxuICByZXR1cm4gYm91bmRzICYmICFib3VuZHMud2lkdGggJiYgIWJvdW5kcy54ICYmICFib3VuZHMueSA/IHtcbiAgICB4OiArX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIFtcInhcIiwgXCJjeFwiLCBcIngxXCJdKSB8fCAwLFxuICAgIHk6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieVwiLCBcImN5XCIsIFwieTFcIl0pIHx8IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0gOiBib3VuZHM7XG59LFxuICAgIF9pc1NWRyA9IGZ1bmN0aW9uIF9pc1NWRyhlKSB7XG4gIHJldHVybiAhIShlLmdldENUTSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkgJiYgX2dldEJCb3goZSkpO1xufSxcbiAgICAvL3JlcG9ydHMgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHIG9uIHdoaWNoIGdldEJCb3goKSBhY3R1YWxseSB3b3Jrc1xuX3JlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24gX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBmaXJzdDJDaGFycztcblxuICAgIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB7XG4gICAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgZmlyc3QyQ2hhcnMgPSBwcm9wZXJ0eS5zdWJzdHIoMCwgMik7XG5cbiAgICAgIGlmIChmaXJzdDJDaGFycyA9PT0gXCJtc1wiIHx8IHByb3BlcnR5LnN1YnN0cigwLCA2KSA9PT0gXCJ3ZWJraXRcIikge1xuICAgICAgICAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHByb3BlcnR5ID0gXCItXCIgKyBwcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoZmlyc3QyQ2hhcnMgPT09IFwiLS1cIiA/IHByb3BlcnR5IDogcHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQgPSBmdW5jdGlvbiBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpIHtcbiAgdmFyIHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBvbmx5U2V0QXRFbmQgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKTtcbiAgcGx1Z2luLl9wdCA9IHB0O1xuICBwdC5iID0gYmVnaW5uaW5nO1xuICBwdC5lID0gZW5kO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfbm9uQ29udmVydGlibGVVbml0cyA9IHtcbiAgZGVnOiAxLFxuICByYWQ6IDEsXG4gIHR1cm46IDFcbn0sXG4gICAgX25vblN0YW5kYXJkTGF5b3V0cyA9IHtcbiAgZ3JpZDogMSxcbiAgZmxleDogMVxufSxcbiAgICAvL3Rha2VzIGEgc2luZ2xlIHZhbHVlIGxpa2UgMjBweCBhbmQgY29udmVydHMgaXQgdG8gdGhlIHVuaXQgc3BlY2lmaWVkLCBsaWtlIFwiJVwiLCByZXR1cm5pbmcgb25seSB0aGUgbnVtZXJpYyBhbW91bnQuXG5fY29udmVydFRvVW5pdCA9IGZ1bmN0aW9uIF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSB7XG4gIHZhciBjdXJWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsXG4gICAgICBjdXJVbml0ID0gKHZhbHVlICsgXCJcIikudHJpbSgpLnN1YnN0cigoY3VyVmFsdWUgKyBcIlwiKS5sZW5ndGgpIHx8IFwicHhcIixcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgbGVhdmUgZXh0cmEgd2hpdGVzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIENTUyB2YXJpYWJsZXMsIGhlbmNlIHRoZSBuZWVkIHRvIHRyaW0oKVxuICBzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuICAgICAgaG9yaXpvbnRhbCA9IF9ob3Jpem9udGFsRXhwLnRlc3QocHJvcGVydHkpLFxuICAgICAgaXNSb290U1ZHID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIixcbiAgICAgIG1lYXN1cmVQcm9wZXJ0eSA9IChpc1Jvb3RTVkcgPyBcImNsaWVudFwiIDogXCJvZmZzZXRcIikgKyAoaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpLFxuICAgICAgYW1vdW50ID0gMTAwLFxuICAgICAgdG9QaXhlbHMgPSB1bml0ID09PSBcInB4XCIsXG4gICAgICB0b1BlcmNlbnQgPSB1bml0ID09PSBcIiVcIixcbiAgICAgIHB4LFxuICAgICAgcGFyZW50LFxuICAgICAgY2FjaGUsXG4gICAgICBpc1NWRztcblxuICBpZiAodW5pdCA9PT0gY3VyVW5pdCB8fCAhY3VyVmFsdWUgfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbdW5pdF0gfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbY3VyVW5pdF0pIHtcbiAgICByZXR1cm4gY3VyVmFsdWU7XG4gIH1cblxuICBjdXJVbml0ICE9PSBcInB4XCIgJiYgIXRvUGl4ZWxzICYmIChjdXJWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBcInB4XCIpKTtcbiAgaXNTVkcgPSB0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpO1xuXG4gIGlmICgodG9QZXJjZW50IHx8IGN1clVuaXQgPT09IFwiJVwiKSAmJiAoX3RyYW5zZm9ybVByb3BzW3Byb3BlcnR5XSB8fCB+cHJvcGVydHkuaW5kZXhPZihcImFkaXVzXCIpKSkge1xuICAgIHB4ID0gaXNTVkcgPyB0YXJnZXQuZ2V0QkJveCgpW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA6IHRhcmdldFttZWFzdXJlUHJvcGVydHldO1xuICAgIHJldHVybiBfcm91bmQodG9QZXJjZW50ID8gY3VyVmFsdWUgLyBweCAqIGFtb3VudCA6IGN1clZhbHVlIC8gMTAwICogcHgpO1xuICB9XG5cbiAgc3R5bGVbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gYW1vdW50ICsgKHRvUGl4ZWxzID8gY3VyVW5pdCA6IHVuaXQpO1xuICBwYXJlbnQgPSB1bml0ICE9PSBcInJlbVwiICYmIH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0b1BlcmNlbnQgJiYgKHByb3BlcnR5ID09PSBcImhlaWdodFwiIHx8IHByb3BlcnR5ID09PSBcIndpZHRoXCIpKSB7XG4gICAgICAvLyBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggd2lkdGgvaGVpZ2h0IHRoYXQncyBpbnNpZGUgYSBjb250YWluZXIgd2l0aCBwYWRkaW5nIGFuZC9vciBpdCdzIGEgZmxleGJveC9ncmlkIGNvbnRhaW5lciwgd2UgbXVzdCBhcHBseSBpdCB0byB0aGUgdGFyZ2V0IGl0c2VsZiByYXRoZXIgdGhhbiB0aGUgX3RlbXBEaXYgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBsZXRlIGFjY3VyYWN5LCBmYWN0b3JpbmcgaW4gdGhlIHBhcmVudCdzIHBhZGRpbmcuXG4gICAgICB2YXIgdiA9IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV07XG4gICAgICB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gYW1vdW50ICsgdW5pdDtcbiAgICAgIHB4ID0gdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICB2ID8gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHYgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmICFfbm9uU3RhbmRhcmRMYXlvdXRzW19nZXRDb21wdXRlZFByb3BlcnR5KHBhcmVudCwgXCJkaXNwbGF5XCIpXSAmJiAoc3R5bGUucG9zaXRpb24gPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIFwicG9zaXRpb25cIikpO1xuICAgICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChfdGVtcERpdik7XG4gICAgICBweCA9IF90ZW1wRGl2W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgfVxuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vIG5vdGU6IHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPT09IFwibm9uZVwiKSB7XG4gICAgLy8gc29tZSBicm93c2VycyBsaWtlIFNhZmFyaSBhY3R1YWxseSBQUkVGRVIgdGhlIHByZWZpeGVkIHByb3BlcnR5IGFuZCBtaXMtcmVwb3J0IHRoZSB1bnByZWZpeGVkIHZhbHVlIGxpa2UgY2xpcFBhdGggKEJVRykuIEluIG90aGVyIHdvcmRzLCBldmVuIHRob3VnaCBjbGlwUGF0aCBleGlzdHMgaW4gdGhlIHN0eWxlIChcImNsaXBQYXRoXCIgaW4gdGFyZ2V0LnN0eWxlKSBhbmQgaXQncyBzZXQgaW4gdGhlIENTUyBwcm9wZXJseSAoYWxvbmcgd2l0aCAtd2Via2l0LWNsaXAtcGF0aCksIFNhZmFyaSByZXBvcnRzIGNsaXBQYXRoIGFzIFwibm9uZVwiIHdoZXJlYXMgV2Via2l0Q2xpcFBhdGggcmVwb3J0cyBhY2N1cmF0ZWx5IGxpa2UgXCJlbGxpcHNlKDEwMCUgMCUgYXQgNTAlIDAlKVwiLCBzbyBpbiB0aGlzIGNhc2Ugd2UgbXVzdCBTV0lUQ0ggdG8gdXNpbmcgdGhlIHByZWZpeGVkIHByb3BlcnR5IGluc3RlYWQuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXG4gICAgdmFyIHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG4gICAgICAgIHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cbiAgICBpZiAocyAmJiBzICE9PSBzdGFydCkge1xuICAgICAgcHJvcCA9IHA7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSBcImJvcmRlckNvbG9yXCIpIHtcbiAgICAgIHN0YXJ0ID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcImJvcmRlclRvcENvbG9yXCIpOyAvLyBGaXJlZm94IGJ1ZzogYWx3YXlzIHJlcG9ydHMgXCJib3JkZXJDb2xvclwiIGFzIFwiXCIsIHNvIHdlIG11c3QgZmFsbCBiYWNrIHRvIGJvcmRlclRvcENvbG9yLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVmFsdWVzO1xuICBwdC5iID0gc3RhcnQ7XG4gIHB0LmUgPSBlbmQ7XG4gIHN0YXJ0ICs9IFwiXCI7IC8vIGVuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoZW5kLnN1YnN0cmluZygwLCA2KSA9PT0gXCJ2YXIoLS1cIikge1xuICAgIGVuZCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgZW5kLnN1YnN0cmluZyg0LCBlbmQuaW5kZXhPZihcIilcIikpKTtcbiAgfVxuXG4gIGlmIChlbmQgPT09IFwiYXV0b1wiKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHRhcmdldC5zdHlsZVtwcm9wXTtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XG4gICAgZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB8fCBlbmQ7XG4gICAgc3RhcnRWYWx1ZSA/IHRhcmdldC5zdHlsZVtwcm9wXSA9IHN0YXJ0VmFsdWUgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgfVxuXG4gIGEgPSBbc3RhcnQsIGVuZF07XG5cbiAgX2NvbG9yU3RyaW5nRmlsdGVyKGEpOyAvLyBwYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLiBJZiBjb2xvcnMgYXJlIGZvdW5kLCBpdCByZXR1cm5zIHRydWUgYW5kIHRoZW4gd2UgbXVzdCBtYXRjaCB3aGVyZSB0aGUgY29sb3Igc2hvd3MgdXAgb3JkZXItd2lzZSBiZWNhdXNlIGZvciB0aGluZ3MgbGlrZSBib3hTaGFkb3csIHNvbWV0aW1lcyB0aGUgYnJvd3NlciBwcm92aWRlcyB0aGUgY29tcHV0ZWQgdmFsdWVzIHdpdGggdGhlIGNvbG9yIEZJUlNULCBidXQgdGhlIHVzZXIgcHJvdmlkZXMgaXQgd2l0aCB0aGUgY29sb3IgTEFTVCwgc28gZmxpcCB0aGVtIGlmIG5lY2Vzc2FyeS4gU2FtZSBmb3IgZHJvcC1zaGFkb3coKS5cblxuXG4gIHN0YXJ0ID0gYVswXTtcbiAgZW5kID0gYVsxXTtcbiAgc3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICBpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xuICAgIHdoaWxlIChyZXN1bHQgPSBfbnVtV2l0aFVuaXRFeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIgfHwgY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJoc2xhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZhbHVlICE9PSAoc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzW21hdGNoSW5kZXgrK10gfHwgXCJcIikpIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG4gICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgKGVuZFZhbHVlID0gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZFZhbHVlKSArIHN0YXJ0VW5pdCk7XG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBpbmRleCA9IF9udW1XaXRoVW5pdEV4cC5sYXN0SW5kZXggLSBlbmRVbml0Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIWVuZFVuaXQpIHtcbiAgICAgICAgICAvL2lmIHNvbWV0aGluZyBsaWtlIFwicGVyc3BlY3RpdmU6MzAwXCIgaXMgcGFzc2VkIGluIGFuZCB3ZSBtdXN0IGFkZCBhIHVuaXQgdG8gdGhlIGVuZFxuICAgICAgICAgIGVuZFVuaXQgPSBlbmRVbml0IHx8IF9jb25maWcudW5pdHNbcHJvcF0gfHwgc3RhcnRVbml0O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgKz0gZW5kVW5pdDtcbiAgICAgICAgICAgIHB0LmUgKz0gZW5kVW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgIH0gLy8gdGhlc2UgbmVzdGVkIFByb3BUd2VlbnMgYXJlIGhhbmRsZWQgaW4gYSBzcGVjaWFsIHdheSAtIHdlJ2xsIG5ldmVyIGFjdHVhbGx5IGNhbGwgYSByZW5kZXIgb3Igc2V0dGVyIG1ldGhvZCBvbiB0aGVtLiBXZSdsbCBqdXN0IGxvb3AgdGhyb3VnaCB0aGVtIGluIHRoZSBwYXJlbnQgY29tcGxleCBzdHJpbmcgUHJvcFR3ZWVuJ3MgcmVuZGVyIG1ldGhvZC5cblxuXG4gICAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgICBfbmV4dDogcHQuX3B0LFxuICAgICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICAgIHM6IHN0YXJ0TnVtLFxuICAgICAgICAgIGM6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgX3JlbEV4cC50ZXN0KGVuZCkgJiYgKHB0LmUgPSAwKTsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgc3R5bGUuc2NhbGUgPSBzdHlsZS5yb3RhdGUgPSBzdHlsZS50cmFuc2xhdGUgPSBcIm5vbmVcIjtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcblxuICAgICAgICBfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjAzNjgtcG9zc2libGUtZ3NhcC1idWctc3dpdGNoaW5nLWNsYXNzbmFtZXMtaW4tY2hyb21lLy5cbiAgXHRcdHN0eWxlLmNzc1RleHQgPSBjc3NUZXh0OyAvL3dlIHJlY29yZGVkIGNzc1RleHQgYmVmb3JlIHdlIHN3YXBwZWQgY2xhc3NlcyBhbmQgcmFuIF9nZXRBbGxTdHlsZXMoKSBiZWNhdXNlIGluIGNhc2VzIHdoZW4gYSBjbGFzc05hbWUgdHdlZW4gaXMgb3ZlcndyaXR0ZW4sIHdlIHJlbW92ZSBhbGwgdGhlIHJlbGF0ZWQgdHdlZW5pbmcgcHJvcGVydGllcyBmcm9tIHRoYXQgY2xhc3MgY2hhbmdlIChvdGhlcndpc2UgY2xhc3Mtc3BlY2lmaWMgc3R1ZmYgY2FuJ3Qgb3ZlcnJpZGUgcHJvcGVydGllcyB3ZSd2ZSBkaXJlY3RseSBzZXQgb24gdGhlIHRhcmdldCdzIHN0eWxlIG9iamVjdCBkdWUgdG8gc3BlY2lmaWNpdHkpLlxuICBcdH1cbiAgXHRfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB0cnVlKTsgLy90byBjbGVhciB0aGUgY2FjaGluZyBvZiB0cmFuc2Zvcm1zXG4gIFx0ZGF0YS5jc3MgPSBuZXcgZ3NhcC5wbHVnaW5zLmNzcygpO1xuICBcdGRhdGEuY3NzLmluaXQodGFyZ2V0LCBjaGFuZ2luZ1ZhcnMsIHR3ZWVuKTtcbiAgXHRwbHVnaW4uX3Byb3BzLnB1c2goLi4uZGF0YS5jc3MuX3Byb3BzKTtcbiAgXHRyZXR1cm4gMTtcbiAgfVxuICAqL1xuXG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRSQU5TRk9STVNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl9pZGVudGl0eTJETWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdLFxuICAgIF9yb3RhdGlvbmFsUHJvcGVydGllcyA9IHt9LFxuICAgIF9pc051bGxUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfaXNOdWxsVHJhbnNmb3JtKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIiB8fCB2YWx1ZSA9PT0gXCJub25lXCIgfHwgIXZhbHVlO1xufSxcbiAgICBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpIHtcbiAgdmFyIG1hdHJpeFN0cmluZyA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gIHJldHVybiBfaXNOdWxsVHJhbnNmb3JtKG1hdHJpeFN0cmluZykgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeFN0cmluZy5zdWJzdHIoNykubWF0Y2goX251bUV4cCkubWFwKF9yb3VuZCk7XG59LFxuICAgIF9nZXRNYXRyaXggPSBmdW5jdGlvbiBfZ2V0TWF0cml4KHRhcmdldCwgZm9yY2UyRCkge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgX2dldENhY2hlKHRhcmdldCksXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSxcbiAgICAgIHBhcmVudCxcbiAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgdGVtcCxcbiAgICAgIGFkZGVkVG9ET007XG5cbiAgaWYgKGNhY2hlLnN2ZyAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpKSB7XG4gICAgdGVtcCA9IHRhcmdldC50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpLm1hdHJpeDsgLy9lbnN1cmVzIHRoYXQgZXZlbiBjb21wbGV4IHZhbHVlcyBsaWtlIFwidHJhbnNsYXRlKDUwLDYwKSByb3RhdGUoMTM1LDAsMClcIiBhcmUgcGFyc2VkIGJlY2F1c2UgaXQgbWFzaGVzIGl0IGludG8gYSBtYXRyaXguXG5cbiAgICBtYXRyaXggPSBbdGVtcC5hLCB0ZW1wLmIsIHRlbXAuYywgdGVtcC5kLCB0ZW1wLmUsIHRlbXAuZl07XG4gICAgcmV0dXJuIG1hdHJpeC5qb2luKFwiLFwiKSA9PT0gXCIxLDAsMCwxLDAsMFwiID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXg7XG4gIH0gZWxzZSBpZiAobWF0cml4ID09PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAhdGFyZ2V0Lm9mZnNldFBhcmVudCAmJiB0YXJnZXQgIT09IF9kb2NFbGVtZW50ICYmICFjYWNoZS5zdmcpIHtcbiAgICAvL25vdGU6IGlmIG9mZnNldFBhcmVudCBpcyBudWxsLCB0aGF0IG1lYW5zIHRoZSBlbGVtZW50IGlzbid0IGluIHRoZSBub3JtYWwgZG9jdW1lbnQgZmxvdywgbGlrZSBpZiBpdCBoYXMgZGlzcGxheTpub25lIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhcyBkaXNwbGF5Om5vbmUpLiBGaXJlZm94IHJldHVybnMgbnVsbCBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSgpIGlmIHRoZSBlbGVtZW50IGlzIGluIGFuIGlmcmFtZSB0aGF0IGhhcyBkaXNwbGF5Om5vbmUuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICAgIC8vYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IHRyYW5zZm9ybXMgYWNjdXJhdGVseSB1bmxlc3MgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIERPTSBhbmQgaGFzIGEgZGlzcGxheSB2YWx1ZSB0aGF0J3Mgbm90IFwibm9uZVwiLiBGaXJlZm94IGFuZCBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIHBhcnRpYWwgYnVnIHdoZXJlIHRoZXknbGwgcmVwb3J0IHRyYW5zZm9ybXMgZXZlbiBpZiBkaXNwbGF5Om5vbmUgQlVUIG5vdCBhbnkgcGVyY2VudGFnZS1iYXNlZCB2YWx1ZXMgbGlrZSB0cmFuc2xhdGUoLTUwJSwgOHB4KSB3aWxsIGJlIHJlcG9ydGVkIGFzIGlmIGl0J3MgdHJhbnNsYXRlKDAsIDhweCkuXG4gICAgdGVtcCA9IHN0eWxlLmRpc3BsYXk7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblxuICAgIGlmICghcGFyZW50IHx8ICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmICF0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1LiBOb3RlOiBwb3NpdGlvbjogZml4ZWQgZWxlbWVudHMgcmVwb3J0IGEgbnVsbCBvZmZzZXRQYXJlbnQgYnV0IHRoZXkgY291bGQgYWxzbyBiZSBpbnZpc2libGUgYmVjYXVzZSB0aGV5J3JlIGluIGFuIGFuY2VzdG9yIHdpdGggZGlzcGxheTogbm9uZSwgc28gd2UgY2hlY2sgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuIFdlIG9ubHkgd2FudCB0byBhbHRlciB0aGUgRE9NIGlmIHdlIGFic29sdXRlbHkgaGF2ZSB0byBiZWNhdXNlIGl0IGNhbiBjYXVzZSBpZnJhbWUgY29udGVudCB0byByZWxvYWQsIGxpa2UgYSBWaW1lbyB2aWRlby5cbiAgICAgIGFkZGVkVG9ET00gPSAxOyAvL2ZsYWdcblxuICAgICAgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTsgLy8gaWYgKCEoXCJ4T3JpZ2luXCIgaW4gY2FjaGUpICYmICh4T3JpZ2luIHx8IHlPcmlnaW4pKSB7IC8vIGFkZGVkIGluIDMuMTIuMywgcmV2ZXJ0ZWQgaW4gMy4xMi40OyByZXF1aXJlcyBtb3JlIGV4cGxvcmF0aW9uXG4gICAgLy8gXHR4T3JpZ2luIC09IGJvdW5kcy54O1xuICAgIC8vIFx0eU9yaWdpbiAtPSBib3VuZHMueTtcbiAgICAvLyB9XG4gIH0gZWxzZSBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAoZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjKSkge1xuICAgIC8vaWYgaXQncyB6ZXJvIChsaWtlIGlmIHNjYWxlWCBhbmQgc2NhbGVZIGFyZSB6ZXJvKSwgc2tpcCBpdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBkaXZpZGluZyBieSB6ZXJvLlxuICAgIHggPSB4T3JpZ2luICogKGQgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKC1jIC8gZGV0ZXJtaW5hbnQpICsgKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtIChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgeE9yaWdpbiA9IHg7XG4gICAgeU9yaWdpbiA9IHk7IC8vIHRoZW9yeTogd2Ugb25seSBoYWQgdG8gZG8gdGhpcyBmb3Igc21vb3RoaW5nIGFuZCBpdCBhc3N1bWVzIHRoYXQgdGhlIHByZXZpb3VzIG9uZSB3YXMgbm90IG9yaWdpbklzQWJzb2x1dGUuXG4gIH1cblxuICBpZiAoc21vb3RoIHx8IHNtb290aCAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKSB7XG4gICAgdHggPSB4T3JpZ2luIC0geE9yaWdpbk9sZDtcbiAgICB0eSA9IHlPcmlnaW4gLSB5T3JpZ2luT2xkO1xuICAgIGNhY2hlLnhPZmZzZXQgPSB4T2Zmc2V0T2xkICsgKHR4ICogYSArIHR5ICogYykgLSB0eDtcbiAgICBjYWNoZS55T2Zmc2V0ID0geU9mZnNldE9sZCArICh0eCAqIGIgKyB0eSAqIGQpIC0gdHk7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICB9XG5cbiAgY2FjaGUueE9yaWdpbiA9IHhPcmlnaW47XG4gIGNhY2hlLnlPcmlnaW4gPSB5T3JpZ2luO1xuICBjYWNoZS5zbW9vdGggPSAhIXNtb290aDtcbiAgY2FjaGUub3JpZ2luID0gb3JpZ2luO1xuICBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlID0gISFvcmlnaW5Jc0Fic29sdXRlO1xuICB0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCIwcHggMHB4XCI7IC8vb3RoZXJ3aXNlLCBpZiBzb21lb25lIHNldHMgIGFuIG9yaWdpbiB2aWEgQ1NTLCBpdCB3aWxsIGxpa2VseSBpbnRlcmZlcmUgd2l0aCB0aGUgU1ZHIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb25lcyAoYmVjYXVzZSByZW1lbWJlciwgd2UncmUgYmFraW5nIHRoZSBvcmlnaW4gaW50byB0aGUgbWF0cml4KCkgdmFsdWUpLlxuXG4gIGlmIChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T3JpZ2luXCIsIHhPcmlnaW5PbGQsIHhPcmlnaW4pO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPcmlnaW5cIiwgeU9yaWdpbk9sZCwgeU9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9mZnNldFwiLCB4T2Zmc2V0T2xkLCBjYWNoZS54T2Zmc2V0KTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T2Zmc2V0XCIsIHlPZmZzZXRPbGQsIGNhY2hlLnlPZmZzZXQpO1xuICB9XG5cbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB4T3JpZ2luICsgXCIgXCIgKyB5T3JpZ2luKTtcbn0sXG4gICAgX3BhcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSkge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgbmV3IEdTQ2FjaGUodGFyZ2V0KTtcblxuICBpZiAoXCJ4XCIgaW4gY2FjaGUgJiYgIXVuY2FjaGUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBpbnZlcnRlZFNjYWxlWCA9IGNhY2hlLnNjYWxlWCA8IDAsXG4gICAgICBweCA9IFwicHhcIixcbiAgICAgIGRlZyA9IFwiZGVnXCIsXG4gICAgICBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcblxuICBpZiAoY3MudHJhbnNsYXRlKSB7XG4gICAgLy8gYWNjb21tb2RhdGUgaW5kZXBlbmRlbnQgdHJhbnNmb3JtcyBieSBjb21iaW5pbmcgdGhlbSBpbnRvIG5vcm1hbCBvbmVzLlxuICAgIGlmIChjcy50cmFuc2xhdGUgIT09IFwibm9uZVwiIHx8IGNzLnNjYWxlICE9PSBcIm5vbmVcIiB8fCBjcy5yb3RhdGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoY3MudHJhbnNsYXRlICE9PSBcIm5vbmVcIiA/IFwidHJhbnNsYXRlM2QoXCIgKyAoY3MudHJhbnNsYXRlICsgXCIgMCAwXCIpLnNwbGl0KFwiIFwiKS5zbGljZSgwLCAzKS5qb2luKFwiLCBcIikgKyBcIikgXCIgOiBcIlwiKSArIChjcy5yb3RhdGUgIT09IFwibm9uZVwiID8gXCJyb3RhdGUoXCIgKyBjcy5yb3RhdGUgKyBcIikgXCIgOiBcIlwiKSArIChjcy5zY2FsZSAhPT0gXCJub25lXCIgPyBcInNjYWxlKFwiICsgY3Muc2NhbGUuc3BsaXQoXCIgXCIpLmpvaW4oXCIsXCIpICsgXCIpIFwiIDogXCJcIikgKyAoY3NbX3RyYW5zZm9ybVByb3BdICE9PSBcIm5vbmVcIiA/IGNzW190cmFuc2Zvcm1Qcm9wXSA6IFwiXCIpO1xuICAgIH1cblxuICAgIHN0eWxlLnNjYWxlID0gc3R5bGUucm90YXRlID0gc3R5bGUudHJhbnNsYXRlID0gXCJub25lXCI7XG4gIH1cblxuICBtYXRyaXggPSBfZ2V0TWF0cml4KHRhcmdldCwgY2FjaGUuc3ZnKTtcblxuICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgaWYgKGNhY2hlLnVuY2FjaGUpIHtcbiAgICAgIC8vIGlmIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSAoYW5kIG1heWJlIGlmIG9yaWdpbiBpcyAwLDApLCB3ZSBuZWVkIHRvIHNldCBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChjYWNoZS54T3JpZ2luIC0gYmJveC54KSArIFwicHggXCIgKyAoY2FjaGUueU9yaWdpbiAtIGJib3gueSkgKyBcInB4XCIuIFByZXZpb3VzbHkgd2UgbGV0IHRoZSBkYXRhLXN2Zy1vcmlnaW4gc3RheSBpbnN0ZWFkLCBidXQgd2hlbiBpbnRyb2R1Y2luZyByZXZlcnQoKSwgaXQgY29tcGxpY2F0ZWQgdGhpbmdzLlxuICAgICAgdDIgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgICAgb3JpZ2luID0gY2FjaGUueE9yaWdpbiAtIHQyLnggKyBcInB4IFwiICsgKGNhY2hlLnlPcmlnaW4gLSB0Mi55KSArIFwicHhcIjtcbiAgICAgIHQxID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdDEgPSAhdW5jYWNoZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpOyAvLyAgUmVtZW1iZXIsIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIHdlIGFsd2F5cyBmb3JjZSBTVkcgZWxlbWVudHMnIHRyYW5zZm9ybU9yaWdpbiB0byAwLDAgYW5kIG9mZnNldCB0aGUgdHJhbnNsYXRpb24gYWNjb3JkaW5nbHkuXG4gICAgfVxuXG4gICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgdDEgfHwgb3JpZ2luLCAhIXQxIHx8IGNhY2hlLm9yaWdpbklzQWJzb2x1dGUsIGNhY2hlLnNtb290aCAhPT0gZmFsc2UsIG1hdHJpeCk7XG4gIH1cblxuICB4T3JpZ2luID0gY2FjaGUueE9yaWdpbiB8fCAwO1xuICB5T3JpZ2luID0gY2FjaGUueU9yaWdpbiB8fCAwO1xuXG4gIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4KSB7XG4gICAgYSA9IG1hdHJpeFswXTsgLy9hMTFcblxuICAgIGIgPSBtYXRyaXhbMV07IC8vYTIxXG5cbiAgICBjID0gbWF0cml4WzJdOyAvL2EzMVxuXG4gICAgZCA9IG1hdHJpeFszXTsgLy9hNDFcblxuICAgIHggPSBhMTIgPSBtYXRyaXhbNF07XG4gICAgeSA9IGEyMiA9IG1hdHJpeFs1XTsgLy8yRCBtYXRyaXhcblxuICAgIGlmIChtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICBzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICBzY2FsZVkgPSBNYXRoLnNxcnQoZCAqIGQgKyBjICogYyk7XG4gICAgICByb3RhdGlvbiA9IGEgfHwgYiA/IF9hdGFuMihiLCBhKSAqIF9SQUQyREVHIDogMDsgLy9ub3RlOiBpZiBzY2FsZVggaXMgMCwgd2UgY2Fubm90IGFjY3VyYXRlbHkgbWVhc3VyZSByb3RhdGlvbi4gU2FtZSBmb3Igc2tld1ggd2l0aCBhIHNjYWxlWSBvZiAwLiBUaGVyZWZvcmUsIHdlIGRlZmF1bHQgdG8gdGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmFsdWUgKG9yIHplcm8gaWYgdGhhdCBkb2Vzbid0IGV4aXN0KS5cblxuICAgICAgc2tld1ggPSBjIHx8IGQgPyBfYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogMDtcbiAgICAgIHNrZXdYICYmIChzY2FsZVkgKj0gTWF0aC5hYnMoTWF0aC5jb3Moc2tld1ggKiBfREVHMlJBRCkpKTtcblxuICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcbiAgICAgIH0gLy8zRCBtYXRyaXhcblxuICAgIH0gZWxzZSB7XG4gICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICBhNDIgPSBtYXRyaXhbN107XG4gICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICBhMzMgPSBtYXRyaXhbMTBdO1xuICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgeSA9IG1hdHJpeFsxM107XG4gICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgIHJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7IC8vcm90YXRpb25YXG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xuICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xuICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgYTIyID0gdDI7XG4gICAgICAgIGEzMiA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWVxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICB0MyA9IGMgKiBjb3MgLSBhMzMgKiBzaW47XG4gICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYiA9IHQyO1xuICAgICAgICBjID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25aXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICByb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgIGIgPSBiICogY29zIC0gYSAqIHNpbjtcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGExMiA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cbiAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIC8vc2Vuc2UgaWYgdGhlcmUgYXJlIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb24gYW4gU1ZHIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHdoZW4gcmVuZGVyaW5nLiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpcyBtb3JlIHJlbGlhYmxlIGNyb3NzLWJyb3dzZXIsIGJ1dCB3ZSBjYW4ndCBqdXN0IHJlbW92ZSB0aGUgQ1NTIG9uZXMgYmVjYXVzZSB0aGV5IG1heSBiZSBhcHBsaWVkIGluIGEgQ1NTIHJ1bGUgc29tZXdoZXJlIChub3QganVzdCBpbmxpbmUpLlxuICAgICAgdDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcbiAgICAgIHQxICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH1cbiAgfVxuXG4gIHVuY2FjaGUgPSB1bmNhY2hlIHx8IGNhY2hlLnVuY2FjaGU7XG4gIGNhY2hlLnggPSB4IC0gKChjYWNoZS54UGVyY2VudCA9IHggJiYgKCF1bmNhY2hlICYmIGNhY2hlLnhQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0V2lkdGggKiBjYWNoZS54UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnkgPSB5IC0gKChjYWNoZS55UGVyY2VudCA9IHkgJiYgKCF1bmNhY2hlICYmIGNhY2hlLnlQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldEhlaWdodCAqIGNhY2hlLnlQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueiA9IHogKyBweDtcbiAgY2FjaGUuc2NhbGVYID0gX3JvdW5kKHNjYWxlWCk7XG4gIGNhY2hlLnNjYWxlWSA9IF9yb3VuZChzY2FsZVkpO1xuICBjYWNoZS5yb3RhdGlvbiA9IF9yb3VuZChyb3RhdGlvbikgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWCA9IF9yb3VuZChyb3RhdGlvblgpICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblkgPSBfcm91bmQocm90YXRpb25ZKSArIGRlZztcbiAgY2FjaGUuc2tld1ggPSBza2V3WCArIGRlZztcbiAgY2FjaGUuc2tld1kgPSBza2V3WSArIGRlZztcbiAgY2FjaGUudHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZSArIHB4O1xuXG4gIGlmIChjYWNoZS56T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW4uc3BsaXQoXCIgXCIpWzJdKSB8fCAhdW5jYWNoZSAmJiBjYWNoZS56T3JpZ2luIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcbiAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTsgLy9zb21lIGJyb3dzZXJzIHByaW9yaXRpemUgQ1NTIHRyYW5zZm9ybXMgb3ZlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS4gV2hlbiB3ZSBzZW5zZSB0aGF0IHRoZSB1c2VyIGhhcyBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkLCB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHRoaXMgd2F5IChvdGhlcndpc2Ugc29tZSBicm93c2VyIHNpbXBseSB3b24ndCByZW5kZXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgY2hhbmdlcyEpXG59LFxuICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUpIHtcbiAgdmFyIGNhcCA9IDM2MCxcbiAgICAgIGlzU3RyaW5nID0gX2lzU3RyaW5nKGVuZFZhbHVlKSxcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgIGNoYW5nZSA9IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlICsgXCJkZWdcIixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHB0O1xuXG4gIGlmIChpc1N0cmluZykge1xuICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuICAgICAgY2hhbmdlICU9IGNhcDtcblxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgIGNoYW5nZSArPSBjaGFuZ2UgPCAwID8gY2FwIDogLWNhcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlIC0gY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgcHQuZSA9IGZpbmFsVmFsdWU7XG4gIHB0LnUgPSBcImRlZ1wiO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYXNzaWduID0gZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IGhhdmUgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSByZWNyZWF0ZSBpdCBoZXJlLlxuICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgIHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59LFxuICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHMgPSBmdW5jdGlvbiBfYWRkUmF3VHJhbnNmb3JtUFRzKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSB7XG4gIC8vZm9yIGhhbmRsaW5nIGNhc2VzIHdoZXJlIHNvbWVvbmUgcGFzc2VzIGluIGEgd2hvbGUgdHJhbnNmb3JtIHN0cmluZywgbGlrZSB0cmFuc2Zvcm06IFwic2NhbGUoMiwgMykgcm90YXRlKDIwZGVnKSB0cmFuc2xhdGVZKDMwZW0pXCJcbiAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuICAgICAgZXhjbHVkZSA9IFwicGVyc3BlY3RpdmUsZm9yY2UzRCx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luXCIsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcblxuICBpZiAoc3RhcnRDYWNoZS5zdmcpIHtcbiAgICBzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblxuICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RhcnRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtUHJvcF07XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHN0YXJ0VmFsdWU7XG4gIH1cblxuICBmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHN0YXJ0Q2FjaGVbcF07XG4gICAgZW5kVmFsdWUgPSBlbmRDYWNoZVtwXTtcblxuICAgIGlmIChzdGFydFZhbHVlICE9PSBlbmRWYWx1ZSAmJiBleGNsdWRlLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgZW5kQ2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmROdW0gLSBzdGFydE51bSwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG5cbiAgX2Fzc2lnbihlbmRDYWNoZSwgc3RhcnRDYWNoZSk7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eSxcbiAgICAgICAgaW5saW5lUHJvcHMsXG4gICAgICAgIGZpbmFsVHJhbnNmb3JtVmFsdWU7XG4gICAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7IC8vIHdlIG1heSBjYWxsIGluaXQoKSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwbHVnaW4gaW5zdGFuY2UsIGxpa2Ugd2hlbiBhZGRpbmcgc3BlY2lhbCBwcm9wZXJ0aWVzLCBzbyBtYWtlIHN1cmUgd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSByZXZlcnQgZGF0YSBvciBpbmxpbmVQcm9wc1xuXG4gICAgdGhpcy5zdHlsZXMgPSB0aGlzLnN0eWxlcyB8fCBfZ2V0U3R5bGVTYXZlcih0YXJnZXQpO1xuICAgIGlubGluZVByb3BzID0gdGhpcy5zdHlsZXMucHJvcHM7XG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGlmIChwID09PSBcImF1dG9Sb3VuZFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbmRWYWx1ZSA9IHZhcnNbcF07XG5cbiAgICAgIGlmIChfcGx1Z2luc1twXSAmJiBfY2hlY2tQbHVnaW4ocCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKSB7XG4gICAgICAgIC8vIHBsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgc3BlY2lhbFByb3AodGhpcywgdGFyZ2V0LCBwLCBlbmRWYWx1ZSwgdHdlZW4pICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHN0YXJ0VmFsdWUgPSAoZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiKS50cmltKCk7XG4gICAgICAgIGVuZFZhbHVlICs9IFwiXCI7XG4gICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICghX2NvbG9yRXhwLnRlc3Qoc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgICAgIGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZChzdHlsZSwgXCJzZXRQcm9wZXJ0eVwiLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgaW5kZXgsIHRhcmdldHMsIDAsIDAsIHApO1xuICAgICAgICBwcm9wcy5wdXNoKHApO1xuICAgICAgICBpbmxpbmVQcm9wcy5wdXNoKHAsIDAsIHN0eWxlW3BdKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoc3RhcnRBdCAmJiBwIGluIHN0YXJ0QXQpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHNvbWVvbmUgaGFyZC1jb2RlcyBhIGNvbXBsZXggdmFsdWUgYXMgdGhlIHN0YXJ0LCBsaWtlIHRvcDogXCJjYWxjKDJ2aCAvIDIpXCIuIFdpdGhvdXQgdGhpcywgaXQnZCB1c2UgdGhlIGNvbXB1dGVkIHZhbHVlIChhbHdheXMgaW4gcHgpXG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IHR5cGVvZiBzdGFydEF0W3BdID09PSBcImZ1bmN0aW9uXCIgPyBzdGFydEF0W3BdLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogc3RhcnRBdFtwXTtcbiAgICAgICAgICBfaXNTdHJpbmcoc3RhcnRWYWx1ZSkgJiYgfnN0YXJ0VmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgJiYgKHN0YXJ0VmFsdWUgPSBfcmVwbGFjZVJhbmRvbShzdGFydFZhbHVlKSk7XG4gICAgICAgICAgZ2V0VW5pdChzdGFydFZhbHVlICsgXCJcIikgfHwgc3RhcnRWYWx1ZSA9PT0gXCJhdXRvXCIgfHwgKHN0YXJ0VmFsdWUgKz0gX2NvbmZpZy51bml0c1twXSB8fCBnZXRVbml0KF9nZXQodGFyZ2V0LCBwKSkgfHwgXCJcIik7IC8vIGZvciBjYXNlcyB3aGVuIHNvbWVvbmUgcGFzc2VzIGluIGEgdW5pdGxlc3MgdmFsdWUgbGlrZSB7eDogMTAwfTsgaWYgd2UgdHJ5IHNldHRpbmcgdHJhbnNsYXRlKDEwMCwgMHB4KSBpdCB3b24ndCB3b3JrLlxuXG4gICAgICAgICAgKHN0YXJ0VmFsdWUgKyBcIlwiKS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApKTsgLy8gY2FuJ3Qgd29yayB3aXRoIHJlbGF0aXZlIHZhbHVlc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIGVuZFZhbHVlLnN1YnN0cigwLCAyKTtcbiAgICAgICAgcmVsYXRpdmUgJiYgKGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpKTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cbiAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlubGluZVByb3BzLnB1c2goXCJ2aXNpYmlsaXR5XCIsIDAsIHN0eWxlLnZpc2liaWxpdHkpO1xuXG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBzdHlsZSwgXCJ2aXNpYmlsaXR5XCIsIHN0YXJ0TnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCBlbmROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsICFlbmROdW0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwICE9PSBcInNjYWxlXCIgJiYgcCAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgcCA9IF9wcm9wZXJ0eUFsaWFzZXNbcF07XG4gICAgICAgICAgICB+cC5pbmRleE9mKFwiLFwiKSAmJiAocCA9IHAuc3BsaXQoXCIsXCIpWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgPSBwIGluIF90cmFuc2Zvcm1Qcm9wczsgLy8tLS0gVFJBTlNGT1JNLVJFTEFURUQgLS0tXG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzLnNhdmUocCk7XG4gICAgICAgICAgZmluYWxUcmFuc2Zvcm1WYWx1ZSA9IGVuZFZhbHVlOyAvLyB0aGlzIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyBlbmRWYWx1ZSBleGNlcHQgd2hlbiBpdCdzIGEgdmFyKC0tKSB2YWx1ZSwgaW4gd2hpY2ggY2FzZSB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgZW5kIHZhbHVlLlxuXG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuc3Vic3RyaW5nKDAsIDYpID09PSBcInZhcigtLVwiKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgZW5kVmFsdWUuc3Vic3RyaW5nKDQsIGVuZFZhbHVlLmluZGV4T2YoXCIpXCIpKSk7XG5cbiAgICAgICAgICAgIGlmIChlbmRWYWx1ZS5zdWJzdHJpbmcoMCwgNSkgPT09IFwiY2FsYyhcIikge1xuICAgICAgICAgICAgICB2YXIgb3JpZ1BlcnNwZWN0aXZlID0gdGFyZ2V0LnN0eWxlLnBlcnNwZWN0aXZlO1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUucGVyc3BlY3RpdmUgPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgICAgZW5kVmFsdWUgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIFwicGVyc3BlY3RpdmVcIik7XG4gICAgICAgICAgICAgIG9yaWdQZXJzcGVjdGl2ZSA/IHRhcmdldC5zdHlsZS5wZXJzcGVjdGl2ZSA9IG9yaWdQZXJzcGVjdGl2ZSA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwicGVyc3BlY3RpdmVcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdHJhbnNmb3JtUHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgICAgICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSAmJiAhdmFycy5wYXJzZVRyYW5zZm9ybSB8fCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB2YXJzLnBhcnNlVHJhbnNmb3JtKTsgLy8gaWYsIGZvciBleGFtcGxlLCBnc2FwLnNldCguLi4ge3RyYW5zZm9ybTpcInRyYW5zbGF0ZVgoNTB2dylcIn0pLCB0aGUgX2dldCgpIGNhbGwgZG9lc24ndCBwYXJzZSB0aGUgdHJhbnNmb3JtLCB0aHVzIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB3b24ndCBiZSBzZXQgeWV0IHNvIGZvcmNlIHRoZSBwYXJzaW5nIG9mIHRoZSB0cmFuc2Zvcm0gaGVyZS5cblxuICAgICAgICAgICAgc21vb3RoID0gdmFycy5zbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIGNhY2hlLnNtb290aDtcbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbiA9IHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgc3R5bGUsIF90cmFuc2Zvcm1Qcm9wLCAwLCAxLCBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0sIGNhY2hlLCAwLCAtMSk7IC8vdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCwgY3JlYXRlIHRoZSByZW5kZXJpbmcgUHJvcFR3ZWVuIHNvIHRoYXQgaXQgcnVucyBMQVNUIChpbiB0aGUgbGlua2VkIGxpc3QsIHdlIGtlZXAgYWRkaW5nIHRvIHRoZSBiZWdpbm5pbmcpXG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2Vlbi5kZXAgPSAxOyAvL2ZsYWcgaXQgYXMgZGVwZW5kZW50IHNvIHRoYXQgaWYgdGhpbmdzIGdldCBraWxsZWQvb3ZlcndyaXR0ZW4gYW5kIHRoaXMgaXMgdGhlIG9ubHkgUHJvcFR3ZWVuIGxlZnQsIHdlIGNhbiBzYWZlbHkga2lsbCB0aGUgd2hvbGUgdHdlZW4uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBjYWNoZSwgXCJzY2FsZVlcIiwgY2FjaGUuc2NhbGVZLCAocmVsYXRpdmUgPyBfcGFyc2VSZWxhdGl2ZShjYWNoZS5zY2FsZVksIHJlbGF0aXZlICsgZW5kTnVtKSA6IGVuZE51bSkgLSBjYWNoZS5zY2FsZVkgfHwgMCwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgICAgICAgdGhpcy5fcHQudSA9IDA7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKFwic2NhbGVZXCIsIHApO1xuICAgICAgICAgICAgcCArPSBcIlhcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIGlubGluZVByb3BzLnB1c2goX3RyYW5zZm9ybU9yaWdpblByb3AsIDAsIHN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSk7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKGVuZFZhbHVlKTsgLy9pbiBjYXNlIHNvbWV0aGluZyBsaWtlIFwibGVmdCB0b3BcIiBvciBcImJvdHRvbSByaWdodFwiIGlzIHBhc3NlZCBpbi4gQ29udmVydCB0byBwZXJjZW50YWdlcy5cblxuICAgICAgICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMCwgc21vb3RoLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZFVuaXQgPSBwYXJzZUZsb2F0KGVuZFZhbHVlLnNwbGl0KFwiIFwiKVsyXSkgfHwgMDsgLy9oYW5kbGUgdGhlIHpPcmlnaW4gc2VwYXJhdGVseSFcblxuICAgICAgICAgICAgICBlbmRVbml0ICE9PSBjYWNoZS56T3JpZ2luICYmIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInpPcmlnaW5cIiwgY2FjaGUuek9yaWdpbiwgZW5kVW5pdCk7XG5cbiAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIHAsIF9maXJzdFR3b09ubHkoc3RhcnRWYWx1ZSksIF9maXJzdFR3b09ubHkoZW5kVmFsdWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG4gICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCByZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZFZhbHVlKSA6IGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInNtb290aE9yaWdpblwiKSB7XG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcbiAgICAgICAgICAgIGNhY2hlW3BdID0gZW5kVmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHModGhpcywgZW5kVmFsdWUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgcCA9IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIHAgaW4gc3R5bGUpIHtcbiAgICAgICAgICBzdGFydFVuaXQgPSAoc3RhcnRWYWx1ZSArIFwiXCIpLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICAgIGVuZE51bSB8fCAoZW5kTnVtID0gMCk7IC8vIHByb3RlY3QgYWdhaW5zdCBOYU5cblxuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKSB8fCAocCBpbiBfY29uZmlnLnVuaXRzID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG4gICAgICAgICAgc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkpO1xuICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gc3RhcnROdW0sICFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgdGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgZmluYWxUcmFuc2Zvcm1WYWx1ZSAhPT0gZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3B0LmIgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcHQuZSA9IGZpbmFsVHJhbnNmb3JtVmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wdC5yID0gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nQW5kRW5kO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIGVuZFVuaXQgIT09IFwiJVwiKSB7XG4gICAgICAgICAgICAvL3doZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nLCB3ZSBuZWVkIHRvIHJldmVydCBpdCB0byB0aGUgT0xEL09SSUdJTkFMIHZhbHVlICh3aXRoIHRob3NlIHVuaXRzKS4gV2UgcmVjb3JkIHRoYXQgYXMgYSBcImJcIiAoYmVnaW5uaW5nKSBwcm9wZXJ0eSBhbmQgcG9pbnQgdG8gYSByZW5kZXIgbWV0aG9kIHRoYXQgaGFuZGxlcyB0aGF0LiAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgICAgICAgICAgdGhpcy5fcHQuYiA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wdC5yID0gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgaWYgKHAgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvL21heWJlIGl0J3Mgbm90IGEgc3R5bGUgLSBpdCBjb3VsZCBiZSBhIHByb3BlcnR5IGFkZGVkIGRpcmVjdGx5IHRvIGFuIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSdsbCB0cnkgdG8gYW5pbWF0ZSB0aGF0LlxuICAgICAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBwLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSwgcmVsYXRpdmUgPyByZWxhdGl2ZSArIGVuZFZhbHVlIDogZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgIT09IFwicGFyc2VUcmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgX21pc3NpbmdQbHVnaW4ocCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHRoaXMsIHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgcmVsYXRpdmUgPyByZWxhdGl2ZSArIGVuZFZhbHVlIDogZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkIHx8IChwIGluIHN0eWxlID8gaW5saW5lUHJvcHMucHVzaChwLCAwLCBzdHlsZVtwXSkgOiB0eXBlb2YgdGFyZ2V0W3BdID09PSBcImZ1bmN0aW9uXCIgPyBpbmxpbmVQcm9wcy5wdXNoKHAsIDIsIHRhcmdldFtwXSgpKSA6IGlubGluZVByb3BzLnB1c2gocCwgMSwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0pKTtcbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHRoaXMpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIGlmIChkYXRhLnR3ZWVuLl90aW1lIHx8ICFfcmV2ZXJ0aW5nKCkpIHtcbiAgICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuc3R5bGVzLnJldmVydCgpO1xuICAgIH1cbiAgfSxcbiAgZ2V0OiBfZ2V0LFxuICBhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxuICBnZXRTZXR0ZXI6IGZ1bmN0aW9uIGdldFNldHRlcih0YXJnZXQsIHByb3BlcnR5LCBwbHVnaW4pIHtcbiAgICAvL3JldHVybnMgYSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRhcmdldCwgcHJvcGVydHksIHZhbHVlIGFuZCBhcHBsaWVzIGl0IGFjY29yZGluZ2x5LiBSZW1lbWJlciwgcHJvcGVydGllcyBsaWtlIFwieFwiIGFyZW4ndCBhcyBzaW1wbGUgYXMgdGFyZ2V0LnN0eWxlLnByb3BlcnR5ID0gdmFsdWUgYmVjYXVzZSB0aGV5J3ZlIGdvdCB0byBiZSBhcHBsaWVkIHRvIGEgcHJveHkgb2JqZWN0IGFuZCB0aGVuIG1lcmdlZCBpbnRvIGEgdHJhbnNmb3JtIHN0cmluZyBpbiBhIHJlbmRlcmVyLlxuICAgIHZhciBwID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG4gICAgcCAmJiBwLmluZGV4T2YoXCIsXCIpIDwgMCAmJiAocHJvcGVydHkgPSBwKTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGFyZ2V0Ll9nc2FwLnggfHwgX2dldCh0YXJnZXQsIFwieFwiKSkgPyBwbHVnaW4gJiYgX3JlY2VudFNldHRlclBsdWdpbiA9PT0gcGx1Z2luID8gcHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZSA6IF9zZXR0ZXJUcmFuc2Zvcm0gOiAoX3JlY2VudFNldHRlclBsdWdpbiA9IHBsdWdpbiB8fCB7fSkgJiYgKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIDogX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIpIDogdGFyZ2V0LnN0eWxlICYmICFfaXNVbmRlZmluZWQodGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSkgPyBfc2V0dGVyQ1NTU3R5bGUgOiB+cHJvcGVydHkuaW5kZXhPZihcIi1cIikgPyBfc2V0dGVyQ1NTUHJvcCA6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIH0sXG4gIGNvcmU6IHtcbiAgICBfcmVtb3ZlUHJvcGVydHk6IF9yZW1vdmVQcm9wZXJ0eSxcbiAgICBfZ2V0TWF0cml4OiBfZ2V0TWF0cml4XG4gIH1cbn07XG5nc2FwLnV0aWxzLmNoZWNrUHJlZml4ID0gX2NoZWNrUHJvcFByZWZpeDtcbmdzYXAuY29yZS5nZXRTdHlsZVNhdmVyID0gX2dldFN0eWxlU2F2ZXI7XG5cbihmdW5jdGlvbiAocG9zaXRpb25BbmRTY2FsZSwgcm90YXRpb24sIG90aGVycywgYWxpYXNlcykge1xuICB2YXIgYWxsID0gX2ZvckVhY2hOYW1lKHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uICsgXCIsXCIgKyBvdGhlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX3RyYW5zZm9ybVByb3BzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX2ZvckVhY2hOYW1lKHJvdGF0aW9uLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9jb25maWcudW5pdHNbbmFtZV0gPSBcImRlZ1wiO1xuICAgIF9yb3RhdGlvbmFsUHJvcGVydGllc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9wcm9wZXJ0eUFsaWFzZXNbYWxsWzEzXV0gPSBwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbjtcblxuICBfZm9yRWFjaE5hbWUoYWxpYXNlcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3BsaXQgPSBuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBfcHJvcGVydHlBbGlhc2VzW3NwbGl0WzFdXSA9IGFsbFtzcGxpdFswXV07XG4gIH0pO1xufSkoXCJ4LHkseixzY2FsZSxzY2FsZVgsc2NhbGVZLHhQZXJjZW50LHlQZXJjZW50XCIsIFwicm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxza2V3WCxza2V3WVwiLCBcInRyYW5zZm9ybSx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLGZvcmNlM0Qsc21vb3RoT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsIFwiMDp0cmFuc2xhdGVYLDE6dHJhbnNsYXRlWSwyOnRyYW5zbGF0ZVosODpyb3RhdGUsODpyb3RhdGlvblosODpyb3RhdGVaLDk6cm90YXRlWCwxMDpyb3RhdGVZXCIpO1xuXG5fZm9yRWFjaE5hbWUoXCJ4LHkseix0b3AscmlnaHQsYm90dG9tLGxlZnQsd2lkdGgsaGVpZ2h0LGZvbnRTaXplLHBhZGRpbmcsbWFyZ2luLHBlcnNwZWN0aXZlXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIF9jb25maWcudW5pdHNbbmFtZV0gPSBcInB4XCI7XG59KTtcblxuZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pO1xuZXhwb3J0IHsgQ1NTUGx1Z2luIGFzIGRlZmF1bHQsIF9nZXRCQm94LCBfY3JlYXRlRWxlbWVudCwgX2NoZWNrUHJvcFByZWZpeCBhcyBjaGVja1ByZWZpeCB9OyJdLCJuYW1lcyI6WyJnc2FwIiwiX2dldFByb3BlcnR5IiwiX251bUV4cCIsIl9udW1XaXRoVW5pdEV4cCIsImdldFVuaXQiLCJfaXNTdHJpbmciLCJfaXNVbmRlZmluZWQiLCJfcmVuZGVyQ29tcGxleFN0cmluZyIsIl9yZWxFeHAiLCJfZm9yRWFjaE5hbWUiLCJfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5IiwiX2NvbG9yU3RyaW5nRmlsdGVyIiwiX2NoZWNrUGx1Z2luIiwiX3JlcGxhY2VSYW5kb20iLCJfcGx1Z2lucyIsIkdTQ2FjaGUiLCJQcm9wVHdlZW4iLCJfY29uZmlnIiwiX3RpY2tlciIsIl9yb3VuZCIsIl9taXNzaW5nUGx1Z2luIiwiX2dldFNldHRlciIsIl9nZXRDYWNoZSIsIl9jb2xvckV4cCIsIl9wYXJzZVJlbGF0aXZlIiwiX3NldERlZmF1bHRzIiwiX3JlbW92ZUxpbmtlZExpc3RJdGVtIiwiX3dpbiIsIl9kb2MiLCJfZG9jRWxlbWVudCIsIl9wbHVnaW5Jbml0dGVkIiwiX3RlbXBEaXYiLCJfdGVtcERpdlN0eWxlciIsIl9yZWNlbnRTZXR0ZXJQbHVnaW4iLCJfcmV2ZXJ0aW5nIiwiX3dpbmRvd0V4aXN0cyIsIl90cmFuc2Zvcm1Qcm9wcyIsIl9SQUQyREVHIiwiTWF0aCIsIlBJIiwiX0RFRzJSQUQiLCJfYXRhbjIiLCJhdGFuMiIsIl9iaWdOdW0iLCJfY2Fwc0V4cCIsIl9ob3Jpem9udGFsRXhwIiwiX2NvbXBsZXhFeHAiLCJfcHJvcGVydHlBbGlhc2VzIiwiYXV0b0FscGhhIiwic2NhbGUiLCJhbHBoYSIsIl9yZW5kZXJDU1NQcm9wIiwicmF0aW8iLCJkYXRhIiwic2V0IiwidCIsInAiLCJyb3VuZCIsInMiLCJjIiwidSIsIl9yZW5kZXJQcm9wV2l0aEVuZCIsImUiLCJfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmciLCJiIiwiX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nQW5kRW5kIiwiX3JlbmRlclJvdW5kZWRDU1NQcm9wIiwidmFsdWUiLCJfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIiwiX3NldHRlckNTU1N0eWxlIiwidGFyZ2V0IiwicHJvcGVydHkiLCJzdHlsZSIsIl9zZXR0ZXJDU1NQcm9wIiwic2V0UHJvcGVydHkiLCJfc2V0dGVyVHJhbnNmb3JtIiwiX2dzYXAiLCJfc2V0dGVyU2NhbGUiLCJzY2FsZVgiLCJzY2FsZVkiLCJfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIiwiY2FjaGUiLCJyZW5kZXJUcmFuc2Zvcm0iLCJfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciIsIl90cmFuc2Zvcm1Qcm9wIiwiX3RyYW5zZm9ybU9yaWdpblByb3AiLCJfc2F2ZVN0eWxlIiwiaXNOb3RDU1MiLCJfdGhpcyIsInRmbSIsImluZGV4T2YiLCJzcGxpdCIsImZvckVhY2giLCJhIiwiX2dldCIsIngiLCJ6T3JpZ2luIiwidHJhbnNmb3JtIiwiY2FsbCIsInByb3BzIiwic3ZnIiwic3ZnbyIsImdldEF0dHJpYnV0ZSIsInB1c2giLCJfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zIiwidHJhbnNsYXRlIiwicmVtb3ZlUHJvcGVydHkiLCJfcmV2ZXJ0U3R5bGUiLCJpIiwibGVuZ3RoIiwic3Vic3RyIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwic2V0QXR0cmlidXRlIiwiaXNTdGFydCIsInVuY2FjaGUiLCJfZ2V0U3R5bGVTYXZlciIsInByb3BlcnRpZXMiLCJzYXZlciIsInJldmVydCIsInNhdmUiLCJjb3JlIiwiZ2V0Q2FjaGUiLCJub2RlVHlwZSIsIl9zdXBwb3J0czNEIiwiX2NyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwibnMiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVFbGVtZW50IiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJjcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsImVsZW1lbnQiLCJwcmVmZXJQcmVmaXgiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIl9pbml0Q29yZSIsIndpbmRvdyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY3NzVGV4dCIsInJldmVydGluZyIsIl9nZXRSZXBhcmVudGVkQ2xvbmVCQm94Iiwib3duZXIiLCJvd25lclNWR0VsZW1lbnQiLCJjbG9uZSIsImNsb25lTm9kZSIsImJib3giLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJnZXRCQm94IiwicmVtb3ZlQ2hpbGQiLCJfZ2V0QXR0cmlidXRlRmFsbGJhY2tzIiwiYXR0cmlidXRlc0FycmF5IiwiaGFzQXR0cmlidXRlIiwiX2dldEJCb3giLCJib3VuZHMiLCJjbG9uZWQiLCJlcnJvciIsIndpZHRoIiwiaGVpZ2h0IiwieSIsIl9pc1NWRyIsImdldENUTSIsInBhcmVudE5vZGUiLCJfcmVtb3ZlUHJvcGVydHkiLCJmaXJzdDJDaGFycyIsInJlbW92ZUF0dHJpYnV0ZSIsIl9hZGROb25Ud2VlbmluZ1BUIiwicGx1Z2luIiwiYmVnaW5uaW5nIiwiZW5kIiwib25seVNldEF0RW5kIiwicHQiLCJfcHQiLCJfcHJvcHMiLCJfbm9uQ29udmVydGlibGVVbml0cyIsImRlZyIsInJhZCIsInR1cm4iLCJfbm9uU3RhbmRhcmRMYXlvdXRzIiwiZ3JpZCIsImZsZXgiLCJfY29udmVydFRvVW5pdCIsInVuaXQiLCJjdXJWYWx1ZSIsInBhcnNlRmxvYXQiLCJjdXJVbml0IiwidHJpbSIsImhvcml6b250YWwiLCJ0ZXN0IiwiaXNSb290U1ZHIiwidGFnTmFtZSIsIm1lYXN1cmVQcm9wZXJ0eSIsImFtb3VudCIsInRvUGl4ZWxzIiwidG9QZXJjZW50IiwicHgiLCJwYXJlbnQiLCJpc1NWRyIsImJvZHkiLCJ0aW1lIiwidiIsInBvc2l0aW9uIiwiX3BhcnNlVHJhbnNmb3JtIiwib3JpZ2luIiwiX2ZpcnN0VHdvT25seSIsIl9zcGVjaWFsUHJvcHMiLCJfdHdlZW5Db21wbGV4Q1NTU3RyaW5nIiwicHJvcCIsInN0YXJ0IiwiaW5kZXgiLCJtYXRjaEluZGV4IiwicmVzdWx0Iiwic3RhcnRWYWx1ZXMiLCJzdGFydE51bSIsImNvbG9yIiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiZW5kTnVtIiwiY2h1bmsiLCJlbmRVbml0Iiwic3RhcnRVbml0IiwiZW5kVmFsdWVzIiwic3Vic3RyaW5nIiwibWF0Y2giLCJleGVjIiwibGFzdEluZGV4IiwidW5pdHMiLCJfbmV4dCIsIm0iLCJyIiwiX2tleXdvcmRUb1BlcmNlbnQiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJjZW50ZXIiLCJfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyIsImpvaW4iLCJfcmVuZGVyQ2xlYXJQcm9wcyIsInR3ZWVuIiwiX3RpbWUiLCJfZHVyIiwiY2xlYXJUcmFuc2Zvcm1zIiwicm90YXRlIiwiY2xlYXJQcm9wcyIsInByIiwiX2lkZW50aXR5MkRNYXRyaXgiLCJfcm90YXRpb25hbFByb3BlcnRpZXMiLCJfaXNOdWxsVHJhbnNmb3JtIiwiX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSIsIm1hdHJpeFN0cmluZyIsIm1hcCIsIl9nZXRNYXRyaXgiLCJmb3JjZTJEIiwibWF0cml4IiwibmV4dFNpYmxpbmciLCJ0ZW1wIiwiYWRkZWRUb0RPTSIsImJhc2VWYWwiLCJjb25zb2xpZGF0ZSIsImQiLCJmIiwib2Zmc2V0UGFyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiX2FwcGx5U1ZHT3JpZ2luIiwib3JpZ2luSXNBYnNvbHV0ZSIsInNtb290aCIsIm1hdHJpeEFycmF5IiwicGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8iLCJ4T3JpZ2luT2xkIiwieE9yaWdpbiIsInlPcmlnaW5PbGQiLCJ5T3JpZ2luIiwieE9mZnNldE9sZCIsInhPZmZzZXQiLCJ5T2Zmc2V0T2xkIiwieU9mZnNldCIsInR4IiwidHkiLCJvcmlnaW5TcGxpdCIsImRldGVybWluYW50IiwiaW52ZXJ0ZWRTY2FsZVgiLCJ6Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJza2V3WCIsInNrZXdZIiwicGVyc3BlY3RpdmUiLCJhbmdsZSIsImNvcyIsInNpbiIsImExMiIsImEyMiIsInQxIiwidDIiLCJ0MyIsImExMyIsImEyMyIsImEzMyIsImE0MiIsImE0MyIsImEzMiIsInNsaWNlIiwic3FydCIsImFicyIsImZvcmNlQ1NTIiwieFBlcmNlbnQiLCJvZmZzZXRXaWR0aCIsInlQZXJjZW50Iiwib2Zmc2V0SGVpZ2h0IiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJmb3JjZTNEIiwiX3JlbmRlclNWR1RyYW5zZm9ybXMiLCJfcmVuZGVyQ1NTVHJhbnNmb3JtcyIsIl9yZW5kZXJOb24zRFRyYW5zZm9ybXMiLCJfYWRkUHhUcmFuc2xhdGUiLCJfemVyb0RlZyIsIl96ZXJvUHgiLCJfZW5kUGFyZW50aGVzaXMiLCJfcmVmIiwidHJhbnNmb3JtcyIsInVzZTNEIiwiX3JlZjIiLCJhMTEiLCJhMjEiLCJ0YW4iLCJfYWRkUm90YXRpb25hbFByb3BUd2VlbiIsImNhcCIsImlzU3RyaW5nIiwiY2hhbmdlIiwiZmluYWxWYWx1ZSIsImRpcmVjdGlvbiIsIl9hc3NpZ24iLCJzb3VyY2UiLCJfYWRkUmF3VHJhbnNmb3JtUFRzIiwic3RhcnRDYWNoZSIsImV4Y2x1ZGUiLCJlbmRDYWNoZSIsIm5hbWUiLCJsIiwic2lkZSIsInZhcnMiLCJhcmd1bWVudHMiLCJpbml0IiwiQ1NTUGx1Z2luIiwicmVnaXN0ZXIiLCJ0YXJnZXRUZXN0IiwidGFyZ2V0cyIsInN0YXJ0QXQiLCJzcGVjaWFsUHJvcCIsInJlbGF0aXZlIiwiaXNUcmFuc2Zvcm1SZWxhdGVkIiwidHJhbnNmb3JtUHJvcFR3ZWVuIiwiaGFzUHJpb3JpdHkiLCJpbmxpbmVQcm9wcyIsImZpbmFsVHJhbnNmb3JtVmFsdWUiLCJzdHlsZXMiLCJhZGQiLCJ2aXNpYmlsaXR5Iiwib3JpZ1BlcnNwZWN0aXZlIiwicGFyc2VUcmFuc2Zvcm0iLCJzbW9vdGhPcmlnaW4iLCJkZXAiLCJhdXRvUm91bmQiLCJyZW5kZXIiLCJnZXQiLCJhbGlhc2VzIiwiZ2V0U2V0dGVyIiwidXRpbHMiLCJjaGVja1ByZWZpeCIsImdldFN0eWxlU2F2ZXIiLCJwb3NpdGlvbkFuZFNjYWxlIiwib3RoZXJzIiwiYWxsIiwicmVnaXN0ZXJQbHVnaW4iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/gsap/CSSPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: function() { return /* binding */ Animation; },\n/* harmony export */   Back: function() { return /* binding */ Back; },\n/* harmony export */   Bounce: function() { return /* binding */ Bounce; },\n/* harmony export */   Circ: function() { return /* binding */ Circ; },\n/* harmony export */   Cubic: function() { return /* binding */ Cubic; },\n/* harmony export */   Elastic: function() { return /* binding */ Elastic; },\n/* harmony export */   Expo: function() { return /* binding */ Expo; },\n/* harmony export */   GSCache: function() { return /* binding */ GSCache; },\n/* harmony export */   Linear: function() { return /* binding */ Linear; },\n/* harmony export */   Power0: function() { return /* binding */ Power0; },\n/* harmony export */   Power1: function() { return /* binding */ Power1; },\n/* harmony export */   Power2: function() { return /* binding */ Power2; },\n/* harmony export */   Power3: function() { return /* binding */ Power3; },\n/* harmony export */   Power4: function() { return /* binding */ Power4; },\n/* harmony export */   PropTween: function() { return /* binding */ PropTween; },\n/* harmony export */   Quad: function() { return /* binding */ Quad; },\n/* harmony export */   Quart: function() { return /* binding */ Quart; },\n/* harmony export */   Quint: function() { return /* binding */ Quint; },\n/* harmony export */   Sine: function() { return /* binding */ Sine; },\n/* harmony export */   SteppedEase: function() { return /* binding */ SteppedEase; },\n/* harmony export */   Strong: function() { return /* binding */ Strong; },\n/* harmony export */   Timeline: function() { return /* binding */ Timeline; },\n/* harmony export */   TimelineLite: function() { return /* binding */ Timeline; },\n/* harmony export */   TimelineMax: function() { return /* binding */ Timeline; },\n/* harmony export */   Tween: function() { return /* binding */ Tween; },\n/* harmony export */   TweenLite: function() { return /* binding */ Tween; },\n/* harmony export */   TweenMax: function() { return /* binding */ Tween; },\n/* harmony export */   _checkPlugin: function() { return /* binding */ _checkPlugin; },\n/* harmony export */   _colorExp: function() { return /* binding */ _colorExp; },\n/* harmony export */   _colorStringFilter: function() { return /* binding */ _colorStringFilter; },\n/* harmony export */   _config: function() { return /* binding */ _config; },\n/* harmony export */   _forEachName: function() { return /* binding */ _forEachName; },\n/* harmony export */   _getCache: function() { return /* binding */ _getCache; },\n/* harmony export */   _getProperty: function() { return /* binding */ _getProperty; },\n/* harmony export */   _getSetter: function() { return /* binding */ _getSetter; },\n/* harmony export */   _isString: function() { return /* binding */ _isString; },\n/* harmony export */   _isUndefined: function() { return /* binding */ _isUndefined; },\n/* harmony export */   _missingPlugin: function() { return /* binding */ _missingPlugin; },\n/* harmony export */   _numExp: function() { return /* binding */ _numExp; },\n/* harmony export */   _numWithUnitExp: function() { return /* binding */ _numWithUnitExp; },\n/* harmony export */   _parseRelative: function() { return /* binding */ _parseRelative; },\n/* harmony export */   _plugins: function() { return /* binding */ _plugins; },\n/* harmony export */   _relExp: function() { return /* binding */ _relExp; },\n/* harmony export */   _removeLinkedListItem: function() { return /* binding */ _removeLinkedListItem; },\n/* harmony export */   _renderComplexString: function() { return /* binding */ _renderComplexString; },\n/* harmony export */   _replaceRandom: function() { return /* binding */ _replaceRandom; },\n/* harmony export */   _round: function() { return /* binding */ _round; },\n/* harmony export */   _roundModifier: function() { return /* binding */ _roundModifier; },\n/* harmony export */   _setDefaults: function() { return /* binding */ _setDefaults; },\n/* harmony export */   _sortPropTweensByPriority: function() { return /* binding */ _sortPropTweensByPriority; },\n/* harmony export */   _ticker: function() { return /* binding */ _ticker; },\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   \"default\": function() { return /* binding */ gsap; },\n/* harmony export */   distribute: function() { return /* binding */ distribute; },\n/* harmony export */   getUnit: function() { return /* binding */ getUnit; },\n/* harmony export */   gsap: function() { return /* binding */ gsap; },\n/* harmony export */   interpolate: function() { return /* binding */ interpolate; },\n/* harmony export */   mapRange: function() { return /* binding */ mapRange; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   pipe: function() { return /* binding */ pipe; },\n/* harmony export */   random: function() { return /* binding */ random; },\n/* harmony export */   selector: function() { return /* binding */ selector; },\n/* harmony export */   shuffle: function() { return /* binding */ shuffle; },\n/* harmony export */   snap: function() { return /* binding */ snap; },\n/* harmony export */   splitColor: function() { return /* binding */ splitColor; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   unitize: function() { return /* binding */ unitize; },\n/* harmony export */   wrap: function() { return /* binding */ wrap; },\n/* harmony export */   wrapYoyo: function() { return /* binding */ wrapYoyo; }\n/* harmony export */ });\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\n/*!\n * GSAP 3.14.2\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _config = {\n    autoSleep: 120,\n    force3D: \"auto\",\n    nullTargetWarn: 1,\n    units: {\n        lineHeight: \"\"\n    }\n}, _defaults = {\n    duration: .5,\n    overwrite: false,\n    delay: 0\n}, _suppressOverwrites, _reverting, _context, _bigNum = 1e8, _tinyNum = 1 / _bigNum, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _isNotFalse = function _isNotFalse(value) {\n    return value !== false;\n}, _windowExists = function _windowExists() {\n    return \"object\" !== \"undefined\";\n}, _isFuncOrString = function _isFuncOrString(value) {\n    return _isFunction(value) || _isString(value);\n}, _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function() {}, // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n_isArray = Array.isArray, _randomExp = /random\\([^)]+\\)/g, _commaDelimExp = /,\\s*/g, _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi, //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi, //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.\n_relExp = /[+-]=-?[.\\d]+/, _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi, // previously /[#\\-+.]*\\b[a-z\\d\\-=+%.]+/gi but didn't catch special characters.\n_unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i, _globalTimeline, _win, _coreInitted, _doc, _globals = {}, _installScope = {}, _coreReady, _install = function _install(scope) {\n    return (_installScope = _merge(scope, _globals)) && gsap;\n}, _missingPlugin = function _missingPlugin(property, value) {\n    return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n}, _warn = function _warn(message, suppress) {\n    return !suppress && console.warn(message);\n}, _addGlobal = function _addGlobal(name, obj) {\n    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n}, _emptyFunc = function _emptyFunc() {\n    return 0;\n}, _startAtRevertConfig = {\n    suppressEvents: true,\n    isStart: true,\n    kill: false\n}, _revertConfigNoKill = {\n    suppressEvents: true,\n    kill: false\n}, _revertConfig = {\n    suppressEvents: true\n}, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = \"\", _harness = function _harness(targets) {\n    var target = targets[0], harnessPlugin, i;\n    _isObject(target) || _isFunction(target) || (targets = [\n        targets\n    ]);\n    if (!(harnessPlugin = (target._gsap || {}).harness)) {\n        // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n        i = _harnessPlugins.length;\n        while(i-- && !_harnessPlugins[i].targetTest(target)){}\n        harnessPlugin = _harnessPlugins[i];\n    }\n    i = targets.length;\n    while(i--){\n        targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n    }\n    return targets;\n}, _getCache = function _getCache(target) {\n    return target._gsap || _harness(toArray(target))[0]._gsap;\n}, _getProperty = function _getProperty(target, property, v) {\n    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n}, _forEachName = function _forEachName(names, func) {\n    return (names = names.split(\",\")).forEach(func) || names;\n}, //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n}, _roundPrecise = function _roundPrecise(value) {\n    return Math.round(value * 10000000) / 10000000 || 0;\n}, // increased precision mostly for timing values.\n_parseRelative = function _parseRelative(start, value) {\n    var operator = value.charAt(0), end = parseFloat(value.substr(2));\n    start = parseFloat(start);\n    return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n}, _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.\n    var l = toFind.length, i = 0;\n    for(; toSearch.indexOf(toFind[i]) < 0 && ++i < l;){}\n    return i < l;\n}, _lazyRender = function _lazyRender() {\n    var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;\n    _lazyLookup = {};\n    _lazyTweens.length = 0;\n    for(i = 0; i < l; i++){\n        tween = a[i];\n        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n    }\n}, _isRevertWorthy = function _isRevertWorthy(animation) {\n    return !!(animation._initted || animation._startAt || animation.add);\n}, _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n    _lazyTweens.length && !_reverting && _lazyRender();\n    animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));\n    _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n}, _numericIfPossible = function _numericIfPossible(value) {\n    var n = parseFloat(value);\n    return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n}, _passThrough = function _passThrough(p) {\n    return p;\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n}, _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n    return function(obj, defaults) {\n        for(var p in defaults){\n            p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n        }\n    };\n}, _merge = function _merge(base, toMerge) {\n    for(var p in toMerge){\n        base[p] = toMerge[p];\n    }\n    return base;\n}, _mergeDeep = function _mergeDeep(base, toMerge) {\n    for(var p in toMerge){\n        p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n    }\n    return base;\n}, _copyExcluding = function _copyExcluding(obj, excluding) {\n    var copy = {}, p;\n    for(p in obj){\n        p in excluding || (copy[p] = obj[p]);\n    }\n    return copy;\n}, _inheritDefaults = function _inheritDefaults(vars) {\n    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n    if (_isNotFalse(vars.inherit)) {\n        while(parent){\n            func(vars, parent.vars.defaults);\n            parent = parent.parent || parent._dp;\n        }\n    }\n    return vars;\n}, _arraysMatch = function _arraysMatch(a1, a2) {\n    var i = a1.length, match = i === a2.length;\n    while(match && i-- && a1[i] === a2[i]){}\n    return i < 0;\n}, _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n    if (firstProp === void 0) {\n        firstProp = \"_first\";\n    }\n    if (lastProp === void 0) {\n        lastProp = \"_last\";\n    }\n    var prev = parent[lastProp], t;\n    if (sortBy) {\n        t = child[sortBy];\n        while(prev && prev[sortBy] > t){\n            prev = prev._prev;\n        }\n    }\n    if (prev) {\n        child._next = prev._next;\n        prev._next = child;\n    } else {\n        child._next = parent[firstProp];\n        parent[firstProp] = child;\n    }\n    if (child._next) {\n        child._next._prev = child;\n    } else {\n        parent[lastProp] = child;\n    }\n    child._prev = prev;\n    child.parent = child._dp = parent;\n    return child;\n}, _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n    if (firstProp === void 0) {\n        firstProp = \"_first\";\n    }\n    if (lastProp === void 0) {\n        lastProp = \"_last\";\n    }\n    var prev = child._prev, next = child._next;\n    if (prev) {\n        prev._next = next;\n    } else if (parent[firstProp] === child) {\n        parent[firstProp] = next;\n    }\n    if (next) {\n        next._prev = prev;\n    } else if (parent[lastProp] === child) {\n        parent[lastProp] = prev;\n    }\n    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.\n}, _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n    child._act = 0;\n}, _uncache = function _uncache(animation, child) {\n    if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n        // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n        var a = animation;\n        while(a){\n            a._dirty = 1;\n            a = a.parent;\n        }\n    }\n    return animation;\n}, _recacheAncestors = function _recacheAncestors(animation) {\n    var parent = animation.parent;\n    while(parent && parent.parent){\n        //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\n        parent._dirty = 1;\n        parent.totalDuration();\n        parent = parent.parent;\n    }\n    return animation;\n}, _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\n    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n}, _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n}, _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n}, // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));\n    return tTime && whole === tTime ? whole - 1 : whole;\n}, _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n}, _setEnd = function _setEnd(animation) {\n    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n}, _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.\n    var parent = animation._dp;\n    if (parent && parent.smoothChildTiming && animation._ts) {\n        animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n        _setEnd(animation);\n        parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n    }\n    return animation;\n}, /*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/ _postAddChecks = function _postAddChecks(timeline, child) {\n    var t;\n    if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\n        // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).\n        t = _parentToChildTotalTime(timeline.rawTime(), child);\n        if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n            child.render(t, true);\n        }\n    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.\n    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n        //in case any of the ancestors had completed but should now be enabled...\n        if (timeline._dur < timeline.duration()) {\n            t = timeline;\n            while(t._dp){\n                t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n                t = t._dp;\n            }\n        }\n        timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.\n    }\n}, _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n    child.parent && _removeFromParent(child);\n    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\n    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n    _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n    _isFromOrFromStart(child) || (timeline._recent = child);\n    skipChecks || _postAddChecks(timeline, child);\n    timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)\n    return timeline;\n}, _scrollTrigger = function _scrollTrigger(animation, trigger) {\n    return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n}, _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\n    _initTween(tween, time, tTime);\n    if (!tween._initted) {\n        return 1;\n    }\n    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n        _lazyTweens.push(tween);\n        tween._lazy = [\n            tTime,\n            suppressEvents\n        ];\n        return 1;\n    }\n}, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n    var parent = _ref.parent;\n    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n}, // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0\n_isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n    var data = _ref2.data;\n    return data === \"isFromStart\" || data === \"isStart\";\n}, _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the \"startAt\" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any \"from\" and \"fromTo\" startAt tweens are rendered the first time at a ratio of 1.\n    repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;\n    if (repeatDelay && tween._repeat) {\n        // in case there's a zero-duration tween that has a repeat with a repeatDelay\n        tTime = _clamp(0, tween._tDur, totalTime);\n        iteration = _animationCycle(tTime, repeatDelay);\n        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n        if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n            // if iteration changed\n            prevRatio = 1 - ratio;\n            tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n        }\n    }\n    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n            // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n            return;\n        }\n        prevIteration = tween._zTime;\n        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n        suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.\n        tween.ratio = ratio;\n        tween._from && (ratio = 1 - ratio);\n        tween._time = 0;\n        tween._tTime = tTime;\n        pt = tween._pt;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n        tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n        tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n            ratio && _removeFromParent(tween, 1);\n            if (!suppressEvents && !_reverting) {\n                _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n                tween._prom && tween._prom();\n            }\n        }\n    } else if (!tween._zTime) {\n        tween._zTime = totalTime;\n    }\n}, _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n    var child;\n    if (time > prevTime) {\n        child = animation._first;\n        while(child && child._start <= time){\n            if (child.data === \"isPause\" && child._start > prevTime) {\n                return child;\n            }\n            child = child._next;\n        }\n    } else {\n        child = animation._last;\n        while(child && child._start >= time){\n            if (child.data === \"isPause\" && child._start < prevTime) {\n                return child;\n            }\n            child = child._prev;\n        }\n    }\n}, _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;\n    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n    animation._dur = dur;\n    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n    animation.parent && _setEnd(animation);\n    skipUncache || _uncache(animation.parent, animation);\n    return animation;\n}, _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n}, _zeroPosition = {\n    _start: 0,\n    endTime: _emptyFunc,\n    totalDuration: _emptyFunc\n}, _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.\n    i, offset, isPercent;\n    if (_isString(position) && (isNaN(position) || position in labels)) {\n        //if the string is a number like \"1\", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).\n        offset = position.charAt(0);\n        isPercent = position.substr(-1) === \"%\";\n        i = position.indexOf(\"=\");\n        if (offset === \"<\" || offset === \">\") {\n            i >= 0 && (position = position.replace(/=/, \"\"));\n            return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n        }\n        if (i < 0) {\n            position in labels || (labels[position] = clippedDuration);\n            return labels[position];\n        }\n        offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n        if (isPercent && percentAnimation) {\n            offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n        }\n        return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n    }\n    return position == null ? clippedDuration : +position;\n}, _createTweenType = function _createTweenType(type, params, timeline) {\n    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;\n    isLegacy && (vars.duration = params[1]);\n    vars.parent = timeline;\n    if (type) {\n        irVars = vars;\n        parent = timeline;\n        while(parent && !(\"immediateRender\" in irVars)){\n            // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.\n            irVars = parent.vars.defaults || {};\n            parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n        }\n        vars.immediateRender = _isNotFalse(irVars.immediateRender);\n        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // \"from\" vars\n    }\n    return new Tween(params[0], vars, params[varsIndex + 1]);\n}, _conditionalReturn = function _conditionalReturn(value, func) {\n    return value || value === 0 ? func(value) : func;\n}, _clamp = function _clamp(min, max, value) {\n    return value < min ? min : value > max ? max : value;\n}, getUnit = function getUnit(value, v) {\n    return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n}, // note: protect against padded numbers as strings, like \"100.100\". That shouldn't return \"00\" as the unit. If it's numeric, return no unit.\nclamp = function clamp(min, max, value) {\n    return _conditionalReturn(value, function(v) {\n        return _clamp(min, max, v);\n    });\n}, _slice = [].slice, _isArrayLike = function _isArrayLike(value, nonEmpty) {\n    return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n}, _flatten = function _flatten(ar, leaveStrings, accumulator) {\n    if (accumulator === void 0) {\n        accumulator = [];\n    }\n    return ar.forEach(function(value) {\n        var _accumulator;\n        return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n    }) || accumulator;\n}, // takes any value and returns an Array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.\ntoArray = function toArray(value, scope, leaveStrings) {\n    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [\n        value\n    ] : [];\n}, selector = function selector(value) {\n    value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n    return function(v) {\n        var el = value.current || value.nativeElement || value;\n        return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n    };\n}, shuffle = function shuffle(a) {\n    return a.sort(function() {\n        return .5 - Math.random();\n    });\n}, // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = (Math.random() * i) | 0, v = a[--i], a[i] = a[j], a[j] = v); return a;\n// for distributing values across an Array. Can accept a number, a function or (most commonly) an object which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array.\ndistribute = function distribute(v) {\n    if (_isFunction(v)) {\n        return v;\n    }\n    var vars = _isObject(v) ? v : {\n        each: v\n    }, //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\n    ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;\n    if (_isString(from)) {\n        ratioX = ratioY = ({\n            center: .5,\n            edges: .5,\n            end: 1\n        })[from] || 0;\n    } else if (!isDecimal && ratios) {\n        ratioX = from[0];\n        ratioY = from[1];\n    }\n    return function(i, target, a) {\n        var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;\n        if (!distances) {\n            wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [\n                1,\n                _bigNum\n            ])[1];\n            if (!wrapAt) {\n                max = -_bigNum;\n                while(max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l){}\n                wrapAt < l && wrapAt--;\n            }\n            distances = cache[l] = [];\n            originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n            originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n            max = 0;\n            min = _bigNum;\n            for(j = 0; j < l; j++){\n                x = j % wrapAt - originX;\n                y = originY - (j / wrapAt | 0);\n                distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n                d > max && (max = d);\n                d < min && (min = d);\n            }\n            from === \"random\" && shuffle(distances);\n            distances.max = max - min;\n            distances.min = min;\n            distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n            distances.b = l < 0 ? base - l : base;\n            distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n            ease = ease && l < 0 ? _invertEase(ease) : ease;\n        }\n        l = (distances[i] - distances.min) / distances.max || 0;\n        return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n    };\n}, _roundModifier = function _roundModifier(v) {\n    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n    var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())\n    return function(raw) {\n        var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n        return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n    };\n}, snap = function snap(snapTo, value) {\n    var isArray = _isArray(snapTo), radius, is2D;\n    if (!isArray && _isObject(snapTo)) {\n        radius = isArray = snapTo.radius || _bigNum;\n        if (snapTo.values) {\n            snapTo = toArray(snapTo.values);\n            if (is2D = !_isNumber(snapTo[0])) {\n                radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.\n            }\n        } else {\n            snapTo = _roundModifier(snapTo.increment);\n        }\n    }\n    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {\n        is2D = snapTo(raw);\n        return Math.abs(is2D - raw) <= radius ? is2D : raw;\n    } : function(raw) {\n        var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;\n        while(i--){\n            if (is2D) {\n                dx = snapTo[i].x - x;\n                dy = snapTo[i].y - y;\n                dx = dx * dx + dy * dy;\n            } else {\n                dx = Math.abs(snapTo[i] - x);\n            }\n            if (dx < min) {\n                min = dx;\n                closest = i;\n            }\n        }\n        closest = !radius || min <= radius ? snapTo[closest] : raw;\n        return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n    });\n}, random = function random(min, max, roundingIncrement, returnFunction) {\n    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {\n        return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n    });\n}, pipe = function pipe() {\n    for(var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++){\n        functions[_key] = arguments[_key];\n    }\n    return function(value) {\n        return functions.reduce(function(v, f) {\n            return f(v);\n        }, value);\n    };\n}, unitize = function unitize(func, unit) {\n    return function(value) {\n        return func(parseFloat(value)) + (unit || getUnit(value));\n    };\n}, normalize = function normalize(min, max, value) {\n    return mapRange(min, max, 0, 1, value);\n}, _wrapArray = function _wrapArray(a, wrapper, value) {\n    return _conditionalReturn(value, function(index) {\n        return a[~~wrapper(index)];\n    });\n}, wrap = function wrap(min, max, value) {\n    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n    var range = max - min;\n    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {\n        return (range + (value - min) % range) % range + min;\n    });\n}, wrapYoyo = function wrapYoyo(min, max, value) {\n    var range = max - min, total = range * 2;\n    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {\n        value = (total + (value - min) % total) % total || 0;\n        return min + (value > range ? total - value : value);\n    });\n}, _replaceRandom = function _replaceRandom(s) {\n    return s.replace(_randomExp, function(match) {\n        //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n        var arIndex = match.indexOf(\"[\") + 1, values = match.substring(arIndex || 7, arIndex ? match.indexOf(\"]\") : match.length - 1).split(_commaDelimExp);\n        return random(arIndex ? values : +values[0], arIndex ? 0 : +values[1], +values[2] || 1e-5);\n    });\n}, mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n    var inRange = inMax - inMin, outRange = outMax - outMin;\n    return _conditionalReturn(value, function(value) {\n        return outMin + ((value - inMin) / inRange * outRange || 0);\n    });\n}, interpolate = function interpolate(start, end, progress, mutate) {\n    var func = isNaN(start + end) ? 0 : function(p) {\n        return (1 - p) * start + p * end;\n    };\n    if (!func) {\n        var isString = _isString(start), master = {}, p, i, interpolators, l, il;\n        progress === true && (mutate = 1) && (progress = null);\n        if (isString) {\n            start = {\n                p: start\n            };\n            end = {\n                p: end\n            };\n        } else if (_isArray(start) && !_isArray(end)) {\n            interpolators = [];\n            l = start.length;\n            il = l - 2;\n            for(i = 1; i < l; i++){\n                interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n            }\n            l--;\n            func = function func(p) {\n                p *= l;\n                var i = Math.min(il, ~~p);\n                return interpolators[i](p - i);\n            };\n            progress = end;\n        } else if (!mutate) {\n            start = _merge(_isArray(start) ? [] : {}, start);\n        }\n        if (!interpolators) {\n            for(p in end){\n                _addPropTween.call(master, start, p, \"get\", end[p]);\n            }\n            func = function func(p) {\n                return _renderPropTweens(p, master) || (isString ? start.p : start);\n            };\n        }\n    }\n    return _conditionalReturn(progress, func);\n}, _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n    //used for nextLabel() and previousLabel()\n    var labels = timeline.labels, min = _bigNum, p, distance, label;\n    for(p in labels){\n        distance = labels[p] - fromTime;\n        if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n            label = p;\n            min = distance;\n        }\n    }\n    return label;\n}, _callback = function _callback(animation, type, executeLazyFirst) {\n    var v = animation.vars, callback = v[type], prevContext = _context, context = animation._ctx, params, scope, result;\n    if (!callback) {\n        return;\n    }\n    params = v[type + \"Params\"];\n    scope = v.callbackScope || animation;\n    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n    context && (_context = context);\n    result = params ? callback.apply(scope, params) : callback.call(scope);\n    _context = prevContext;\n    return result;\n}, _interrupt = function _interrupt(animation) {\n    _removeFromParent(animation);\n    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n    animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n    return animation;\n}, _quickTween, _registerPluginQueue = [], _createPlugin = function _createPlugin(config) {\n    if (!config) return;\n    config = !config.name && config[\"default\"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n    if (_windowExists() || config.headless) {\n        // edge case: some build tools may pass in a null/undefined value\n        var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function() {\n            this._props = [];\n        } : config, //in case someone passes in an object that's not a plugin, like CustomEase\n        instanceDefaults = {\n            init: _emptyFunc,\n            render: _renderPropTweens,\n            add: _addPropTween,\n            kill: _killPropTweensOf,\n            modifier: _addPluginModifier,\n            rawVars: 0\n        }, statics = {\n            targetTest: 0,\n            get: 0,\n            getSetter: _getSetter,\n            aliases: {},\n            register: 0\n        };\n        _wake();\n        if (config !== Plugin) {\n            if (_plugins[name]) {\n                return;\n            }\n            _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n            _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n            _plugins[Plugin.prop = name] = Plugin;\n            if (config.targetTest) {\n                _harnessPlugins.push(Plugin);\n                _reservedProps[name] = 1;\n            }\n            name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\"; //for the global name. \"motionPath\" should become MotionPathPlugin\n        }\n        _addGlobal(name, Plugin);\n        config.register && config.register(gsap, Plugin, PropTween);\n    } else {\n        _registerPluginQueue.push(config);\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */ _255 = 255, _colorLookup = {\n    aqua: [\n        0,\n        _255,\n        _255\n    ],\n    lime: [\n        0,\n        _255,\n        0\n    ],\n    silver: [\n        192,\n        192,\n        192\n    ],\n    black: [\n        0,\n        0,\n        0\n    ],\n    maroon: [\n        128,\n        0,\n        0\n    ],\n    teal: [\n        0,\n        128,\n        128\n    ],\n    blue: [\n        0,\n        0,\n        _255\n    ],\n    navy: [\n        0,\n        0,\n        128\n    ],\n    white: [\n        _255,\n        _255,\n        _255\n    ],\n    olive: [\n        128,\n        128,\n        0\n    ],\n    yellow: [\n        _255,\n        _255,\n        0\n    ],\n    orange: [\n        _255,\n        165,\n        0\n    ],\n    gray: [\n        128,\n        128,\n        128\n    ],\n    purple: [\n        128,\n        0,\n        128\n    ],\n    green: [\n        0,\n        128,\n        0\n    ],\n    red: [\n        _255,\n        0,\n        0\n    ],\n    pink: [\n        _255,\n        192,\n        203\n    ],\n    cyan: [\n        0,\n        _255,\n        _255\n    ],\n    transparent: [\n        _255,\n        _255,\n        _255,\n        0\n    ]\n}, // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:\n// let ctx = _doc.createElement(\"canvas\").getContext(\"2d\");\n// _forEachName(\"aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan\", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});\n_hue = function _hue(h, m1, m2) {\n    h += h < 0 ? 1 : h > 1 ? -1 : 0;\n    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n}, splitColor = function splitColor(v, toHSL, forceAlpha) {\n    var a = !v ? _colorLookup.black : _isNumber(v) ? [\n        v >> 16,\n        v >> 8 & _255,\n        v & _255\n    ] : 0, r, g, b, h, s, l, max, min, d, wasHSL;\n    if (!a) {\n        if (v.substr(-1) === \",\") {\n            //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:\"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)\" - in this example \"blue,\" has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.\n            v = v.substr(0, v.length - 1);\n        }\n        if (_colorLookup[v]) {\n            a = _colorLookup[v];\n        } else if (v.charAt(0) === \"#\") {\n            if (v.length < 6) {\n                //for shorthand like #9F0 or #9F0F (could have alpha)\n                r = v.charAt(1);\n                g = v.charAt(2);\n                b = v.charAt(3);\n                v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n            }\n            if (v.length === 9) {\n                // hex with alpha, like #fd5e53ff\n                a = parseInt(v.substr(1, 6), 16);\n                return [\n                    a >> 16,\n                    a >> 8 & _255,\n                    a & _255,\n                    parseInt(v.substr(7), 16) / 255\n                ];\n            }\n            v = parseInt(v.substr(1), 16);\n            a = [\n                v >> 16,\n                v >> 8 & _255,\n                v & _255\n            ];\n        } else if (v.substr(0, 3) === \"hsl\") {\n            a = wasHSL = v.match(_strictNumExp);\n            if (!toHSL) {\n                h = +a[0] % 360 / 360;\n                s = +a[1] / 100;\n                l = +a[2] / 100;\n                g = l <= .5 ? l * (s + 1) : l + s - l * s;\n                r = l * 2 - g;\n                a.length > 3 && (a[3] *= 1); //cast as number\n                a[0] = _hue(h + 1 / 3, r, g);\n                a[1] = _hue(h, r, g);\n                a[2] = _hue(h - 1 / 3, r, g);\n            } else if (~v.indexOf(\"=\")) {\n                //if relative values are found, just return the raw strings with the relative prefixes in place.\n                a = v.match(_numExp);\n                forceAlpha && a.length < 4 && (a[3] = 1);\n                return a;\n            }\n        } else {\n            a = v.match(_strictNumExp) || _colorLookup.transparent;\n        }\n        a = a.map(Number);\n    }\n    if (toHSL && !wasHSL) {\n        r = a[0] / _255;\n        g = a[1] / _255;\n        b = a[2] / _255;\n        max = Math.max(r, g, b);\n        min = Math.min(r, g, b);\n        l = (max + min) / 2;\n        if (max === min) {\n            h = s = 0;\n        } else {\n            d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n            h *= 60;\n        }\n        a[0] = ~~(h + .5);\n        a[1] = ~~(s * 100 + .5);\n        a[2] = ~~(l * 100 + .5);\n    }\n    forceAlpha && a.length < 4 && (a[3] = 1);\n    return a;\n}, _colorOrderData = function _colorOrderData(v) {\n    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a \"c\" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n    var values = [], c = [], i = -1;\n    v.split(_colorExp).forEach(function(v) {\n        var a = v.match(_numWithUnitExp) || [];\n        values.push.apply(values, a);\n        c.push(i += a.length + 1);\n    });\n    values.c = c;\n    return values;\n}, _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n    var result = \"\", colors = (s + result).match(_colorExp), type = toHSL ? \"hsla(\" : \"rgba(\", i = 0, c, shell, d, l;\n    if (!colors) {\n        return s;\n    }\n    colors = colors.map(function(color) {\n        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n    });\n    if (orderMatchData) {\n        d = _colorOrderData(s);\n        c = orderMatchData.c;\n        if (c.join(result) !== d.c.join(result)) {\n            shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n            l = shell.length - 1;\n            for(; i < l; i++){\n                result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n            }\n        }\n    }\n    if (!shell) {\n        shell = s.split(_colorExp);\n        l = shell.length - 1;\n        for(; i < l; i++){\n            result += shell[i] + colors[i];\n        }\n    }\n    return result + shell[l];\n}, _colorExp = function() {\n    var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\", //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n    p;\n    for(p in _colorLookup){\n        s += \"|\" + p + \"\\\\b\";\n    }\n    return new RegExp(s + \")\", \"gi\");\n}(), _hslExp = /hsl[a]?\\(/, _colorStringFilter = function _colorStringFilter(a) {\n    var combined = a.join(\" \"), toHSL;\n    _colorExp.lastIndex = 0;\n    if (_colorExp.test(combined)) {\n        toHSL = _hslExp.test(combined);\n        a[1] = _formatColors(a[1], toHSL);\n        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n        return true;\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */ _tickerActive, _ticker = function() {\n    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1000 / 240, _nextTime = _gap, _listeners = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick(v) {\n        var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;\n        (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\n        _lastUpdate += elapsed;\n        time = _lastUpdate - _startTime;\n        overlap = time - _nextTime;\n        if (overlap > 0 || manual) {\n            frame = ++_self.frame;\n            _delta = time - _self.time * 1000;\n            _self.time = time = time / 1000;\n            _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n            dispatch = 1;\n        }\n        manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\n        if (dispatch) {\n            for(_i = 0; _i < _listeners.length; _i++){\n                // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.\n                _listeners[_i](time, _delta, frame, v);\n            }\n        }\n    };\n    _self = {\n        time: 0,\n        frame: 0,\n        tick: function tick() {\n            _tick(true);\n        },\n        deltaRatio: function deltaRatio(fps) {\n            return _delta / (1000 / (fps || 60));\n        },\n        wake: function wake() {\n            if (_coreReady) {\n                if (!_coreInitted && _windowExists()) {\n                    _win = _coreInitted = window;\n                    _doc = _win.document || {};\n                    _globals.gsap = gsap;\n                    (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n                    _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n                    _registerPluginQueue.forEach(_createPlugin);\n                }\n                _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\n                _id && _self.sleep();\n                _req = _raf || function(f) {\n                    return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n                };\n                _tickerActive = 1;\n                _tick(2);\n            }\n        },\n        sleep: function sleep() {\n            (_raf ? cancelAnimationFrame : clearTimeout)(_id);\n            _tickerActive = 0;\n            _req = _emptyFunc;\n        },\n        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n            _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited\n            _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n        },\n        fps: function fps(_fps) {\n            _gap = 1000 / (_fps || 240);\n            _nextTime = _self.time * 1000 + _gap;\n        },\n        add: function add(callback, once, prioritize) {\n            var func = once ? function(t, d, f, v) {\n                callback(t, d, f, v);\n                _self.remove(func);\n            } : callback;\n            _self.remove(callback);\n            _listeners[prioritize ? \"unshift\" : \"push\"](func);\n            _wake();\n            return func;\n        },\n        remove: function remove(callback, i) {\n            ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n        },\n        _listeners: _listeners\n    };\n    return _self;\n}(), _wake = function _wake() {\n    return !_tickerActive && _ticker.wake();\n}, //also ensures the core classes are initialized.\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/ _easeMap = {}, _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/, _quotesExp = /[\"']/g, _parseObjectInString = function _parseObjectInString(value) {\n    //takes a string like \"{wiggles:10, type:anticipate})\" and turns it into a real object. Notice it ends in \")\" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n    var obj = {}, split = value.substr(1, value.length - 3).split(\":\"), key = split[0], i = 1, l = split.length, index, val, parsedVal;\n    for(; i < l; i++){\n        val = split[i];\n        index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n        parsedVal = val.substr(0, index);\n        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n        key = val.substr(index + 1).trim();\n    }\n    return obj;\n}, _valueInParentheses = function _valueInParentheses(value) {\n    var open = value.indexOf(\"(\") + 1, close = value.indexOf(\")\"), nested = value.indexOf(\"(\", open);\n    return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n}, _configEaseFromString = function _configEaseFromString(name) {\n    //name can be a string like \"elastic.out(1,0.5)\", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n    var split = (name + \"\").split(\"(\"), ease = _easeMap[split[0]];\n    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [\n        _parseObjectInString(split[1])\n    ] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n}, _invertEase = function _invertEase(ease) {\n    return function(p) {\n        return 1 - ease(1 - p);\n    };\n}, // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n    var child = timeline._first, ease;\n    while(child){\n        if (child instanceof Timeline) {\n            _propagateYoyoEase(child, isYoyo);\n        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n            if (child.timeline) {\n                _propagateYoyoEase(child.timeline, isYoyo);\n            } else {\n                ease = child._ease;\n                child._ease = child._yEase;\n                child._yEase = ease;\n                child._yoyo = isYoyo;\n            }\n        }\n        child = child._next;\n    }\n}, _parseEase = function _parseEase(ease, defaultEase) {\n    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n}, _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n    if (easeOut === void 0) {\n        easeOut = function easeOut(p) {\n            return 1 - easeIn(1 - p);\n        };\n    }\n    if (easeInOut === void 0) {\n        easeInOut = function easeInOut(p) {\n            return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n        };\n    }\n    var ease = {\n        easeIn: easeIn,\n        easeOut: easeOut,\n        easeInOut: easeInOut\n    }, lowercaseName;\n    _forEachName(names, function(name) {\n        _easeMap[name] = _globals[name] = ease;\n        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n        for(var p in ease){\n            _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n        }\n    });\n    return ease;\n}, _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n    return function(p) {\n        return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n    };\n}, _configElastic = function _configElastic(type, amplitude, period) {\n    var p1 = amplitude >= 1 ? amplitude : 1, //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.\n    p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut(p) {\n        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n    }, ease = type === \"out\" ? easeOut : type === \"in\" ? function(p) {\n        return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n    p2 = _2PI / p2; //precalculate to optimize\n    ease.config = function(amplitude, period) {\n        return _configElastic(type, amplitude, period);\n    };\n    return ease;\n}, _configBack = function _configBack(type, overshoot) {\n    if (overshoot === void 0) {\n        overshoot = 1.70158;\n    }\n    var easeOut = function easeOut(p) {\n        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n    }, ease = type === \"out\" ? easeOut : type === \"in\" ? function(p) {\n        return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n    ease.config = function(overshoot) {\n        return _configBack(type, overshoot);\n    };\n    return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function(name, i) {\n    var power = i < 5 ? i + 1 : i;\n    _insertEase(name + \",Power\" + (power - 1), i ? function(p) {\n        return Math.pow(p, power);\n    } : function(p) {\n        return p;\n    }, function(p) {\n        return 1 - Math.pow(1 - p, power);\n    }, function(p) {\n        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n    });\n});\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n(function(n, c) {\n    var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut(p) {\n        return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n    };\n    _insertEase(\"Bounce\", function(p) {\n        return 1 - easeOut(1 - p);\n    }, easeOut);\n})(7.5625, 2.75);\n_insertEase(\"Expo\", function(p) {\n    return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);\n}); // previously 2 ** (10 * (p - 1)) but that doesn't end up with the value quite at the right spot so we do a blended ease to ensure it lands where it should perfectly.\n_insertEase(\"Circ\", function(p) {\n    return -(_sqrt(1 - p * p) - 1);\n});\n_insertEase(\"Sine\", function(p) {\n    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n    config: function config(steps, immediateStart) {\n        if (steps === void 0) {\n            steps = 1;\n        }\n        var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;\n        return function(p) {\n            return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n        };\n    }\n};\n_defaults.ease = _easeMap[\"quad.out\"];\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function(name) {\n    return _callbackNames += name + \",\" + name + \"Params,\";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */ var GSCache = function GSCache(target, harness) {\n    this.id = _gsID++;\n    target._gsap = this;\n    this.target = target;\n    this.harness = harness;\n    this.get = harness ? harness.get : _getProperty;\n    this.set = harness ? harness.getSetter : _getSetter;\n};\n_c = GSCache;\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */ var Animation = /*#__PURE__*/ function() {\n    function Animation(vars) {\n        this.vars = vars;\n        this._delay = +vars.delay || 0;\n        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n            // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.\n            this._rDelay = vars.repeatDelay || 0;\n            this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n        }\n        this._ts = 1;\n        _setDuration(this, +vars.duration, 1, 1);\n        this.data = vars.data;\n        if (_context) {\n            this._ctx = _context;\n            _context.data.push(this);\n        }\n        _tickerActive || _ticker.wake();\n    }\n    var _proto = Animation.prototype;\n    _proto.delay = function delay(value) {\n        if (value || value === 0) {\n            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n            this._delay = value;\n            return this;\n        }\n        return this._delay;\n    };\n    _proto.duration = function duration(value) {\n        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n    };\n    _proto.totalDuration = function totalDuration(value) {\n        if (!arguments.length) {\n            return this._tDur;\n        }\n        this._dirty = 0;\n        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n    };\n    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n        _wake();\n        if (!arguments.length) {\n            return this._tTime;\n        }\n        var parent = this._dp;\n        if (parent && parent.smoothChildTiming && this._ts) {\n            _alignPlayhead(this, _totalTime);\n            !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n            //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n            while(parent && parent.parent){\n                if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n                    parent.totalTime(parent._tTime, true);\n                }\n                parent = parent.parent;\n            }\n            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n                //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.\n                _addToTimeline(this._dp, this, this._start - this._delay);\n            }\n        }\n        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !this._initted && this._dur && _totalTime || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n            // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)\n            this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause\n            //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)\n            //   this._lock = 1;\n            _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\n        //}\n        }\n        return this;\n    };\n    _proto.time = function time(value, suppressEvents) {\n        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n    };\n    _proto.totalProgress = function totalProgress(value, suppressEvents) {\n        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;\n    };\n    _proto.progress = function progress(value, suppressEvents) {\n        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\n    };\n    _proto.iteration = function iteration(value, suppressEvents) {\n        var cycleDuration = this.duration() + this._rDelay;\n        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n    } // potential future addition:\n    ;\n    _proto.timeScale = function timeScale(value, suppressEvents) {\n        if (!arguments.length) {\n            return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.\n        }\n        if (this._rts === value) {\n            return this;\n        }\n        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n        // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.\n        //(+value < 0 && this._rts >= 0) && _callback(this, \"onReverse\", true);\n        // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n        this._rts = +value || 0;\n        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n        this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);\n        _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.\n        return _recacheAncestors(this);\n    };\n    _proto.paused = function paused(value) {\n        if (!arguments.length) {\n            return this._ps;\n        } // possible future addition - if an animation is removed from its parent and then .restart() or .play() or .resume() is called, perhaps we should force it back into the globalTimeline but be careful because what if it's already at its end? We don't want it to just persist forever and not get released for GC.\n        // !this.parent && !value && this._tTime < this._tDur && this !== _globalTimeline && _globalTimeline.add(this);\n        if (this._ps !== value) {\n            this._ps = value;\n            if (value) {\n                this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.\n                this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the \"real\" timeScale as _rts (recorded time scale)\n            } else {\n                _wake();\n                this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.\n                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.\n            }\n        }\n        return this;\n    };\n    _proto.startTime = function startTime(value) {\n        if (arguments.length) {\n            this._start = _roundPrecise(value);\n            var parent = this.parent || this._dp;\n            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, this._start - this._delay);\n            return this;\n        }\n        return this._start;\n    };\n    _proto.endTime = function endTime(includeRepeats) {\n        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n    };\n    _proto.rawTime = function rawTime(wrapRepeats) {\n        var parent = this.parent || this._dp; // _dp = detached parent\n        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n    };\n    _proto.revert = function revert(config) {\n        if (config === void 0) {\n            config = _revertConfig;\n        }\n        var prevIsReverting = _reverting;\n        _reverting = config;\n        if (_isRevertWorthy(this)) {\n            this.timeline && this.timeline.revert(config);\n            this.totalTime(-0.01, config.suppressEvents);\n        }\n        this.data !== \"nested\" && config.kill !== false && this.kill();\n        _reverting = prevIsReverting;\n        return this;\n    };\n    _proto.globalTime = function globalTime(rawTime) {\n        var animation = this, time = arguments.length ? rawTime : animation.rawTime();\n        while(animation){\n            time = animation._start + time / (Math.abs(animation._ts) || 1);\n            animation = animation._dp;\n        }\n        return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). \"_sat\" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().\n    };\n    _proto.repeat = function repeat(value) {\n        if (arguments.length) {\n            this._repeat = value === Infinity ? -2 : value;\n            return _onUpdateTotalDuration(this);\n        }\n        return this._repeat === -2 ? Infinity : this._repeat;\n    };\n    _proto.repeatDelay = function repeatDelay(value) {\n        if (arguments.length) {\n            var time = this._time;\n            this._rDelay = value;\n            _onUpdateTotalDuration(this);\n            return time ? this.time(time) : this;\n        }\n        return this._rDelay;\n    };\n    _proto.yoyo = function yoyo(value) {\n        if (arguments.length) {\n            this._yoyo = value;\n            return this;\n        }\n        return this._yoyo;\n    };\n    _proto.seek = function seek(position, suppressEvents) {\n        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n    };\n    _proto.restart = function restart(includeDelay, suppressEvents) {\n        this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n        this._dur || (this._zTime = -_tinyNum); // ensures onComplete fires on a zero-duration animation that gets restarted.\n        return this;\n    };\n    _proto.play = function play(from, suppressEvents) {\n        from != null && this.seek(from, suppressEvents);\n        return this.reversed(false).paused(false);\n    };\n    _proto.reverse = function reverse(from, suppressEvents) {\n        from != null && this.seek(from || this.totalDuration(), suppressEvents);\n        return this.reversed(true).paused(false);\n    };\n    _proto.pause = function pause(atTime, suppressEvents) {\n        atTime != null && this.seek(atTime, suppressEvents);\n        return this.paused(true);\n    };\n    _proto.resume = function resume() {\n        return this.paused(false);\n    };\n    _proto.reversed = function reversed(value) {\n        if (arguments.length) {\n            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n            return this;\n        }\n        return this._rts < 0;\n    };\n    _proto.invalidate = function invalidate() {\n        this._initted = this._act = 0;\n        this._zTime = -_tinyNum;\n        return this;\n    };\n    _proto.isActive = function isActive() {\n        var parent = this.parent || this._dp, start = this._start, rawTime;\n        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n    };\n    _proto.eventCallback = function eventCallback(type, callback, params) {\n        var vars = this.vars;\n        if (arguments.length > 1) {\n            if (!callback) {\n                delete vars[type];\n            } else {\n                vars[type] = callback;\n                params && (vars[type + \"Params\"] = params);\n                type === \"onUpdate\" && (this._onUpdate = callback);\n            }\n            return this;\n        }\n        return vars[type];\n    };\n    _proto.then = function then(onFulfilled) {\n        var self = this, prevProm = self._prom;\n        return new Promise(function(resolve) {\n            var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve() {\n                var _then = self.then;\n                self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n                prevProm && prevProm();\n                _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n                resolve(f);\n                self.then = _then;\n            };\n            if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n                _resolve();\n            } else {\n                self._prom = _resolve;\n            }\n        });\n    };\n    _proto.kill = function kill() {\n        _interrupt(this);\n    };\n    return Animation;\n}();\n_setDefaults(Animation.prototype, {\n    _time: 0,\n    _start: 0,\n    _end: 0,\n    _tTime: 0,\n    _tDur: 0,\n    _dirty: 0,\n    _repeat: 0,\n    _yoyo: false,\n    parent: null,\n    _initted: false,\n    _rDelay: 0,\n    _ts: 1,\n    _dp: 0,\n    ratio: 0,\n    _zTime: -_tinyNum,\n    _prom: 0,\n    _ps: false,\n    _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */ var Timeline = /*#__PURE__*/ function(_Animation) {\n    _inheritsLoose(Timeline, _Animation);\n    function Timeline(vars, position) {\n        var _this;\n        if (vars === void 0) {\n            vars = {};\n        }\n        _this = _Animation.call(this, vars) || this;\n        _this.labels = {};\n        _this.smoothChildTiming = !!vars.smoothChildTiming;\n        _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n        _this._sort = _isNotFalse(vars.sortChildren);\n        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n        vars.reversed && _this.reverse();\n        vars.paused && _this.paused(true);\n        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n        return _this;\n    }\n    var _proto2 = Timeline.prototype;\n    _proto2.to = function to(targets, vars, position) {\n        _createTweenType(0, arguments, this);\n        return this;\n    };\n    _proto2.from = function from(targets, vars, position) {\n        _createTweenType(1, arguments, this);\n        return this;\n    };\n    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n        _createTweenType(2, arguments, this);\n        return this;\n    };\n    _proto2.set = function set(targets, vars, position) {\n        vars.duration = 0;\n        vars.parent = this;\n        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n        vars.immediateRender = !!vars.immediateRender;\n        new Tween(targets, vars, _parsePosition(this, position), 1);\n        return this;\n    };\n    _proto2.call = function call(callback, params, position) {\n        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n    } //ONLY for backward compatibility! Maybe delete?\n    ;\n    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        vars.duration = duration;\n        vars.stagger = vars.stagger || stagger;\n        vars.onComplete = onCompleteAll;\n        vars.onCompleteParams = onCompleteAllParams;\n        vars.parent = this;\n        new Tween(targets, vars, _parsePosition(this, position));\n        return this;\n    };\n    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        vars.runBackwards = 1;\n        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        toVars.startAt = fromVars;\n        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n    _proto2.render = function render(totalTime, suppressEvents, force) {\n        var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.\n        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;\n        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n        if (tTime !== this._tTime || force || crossingStart) {\n            if (prevTime !== this._time && dur) {\n                //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).\n                tTime += this._time - prevTime;\n                totalTime += this._time - prevTime;\n            }\n            time = tTime;\n            prevStart = this._start;\n            timeScale = this._ts;\n            prevPaused = !timeScale;\n            if (crossingStart) {\n                dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n                (totalTime || !suppressEvents) && (this._zTime = totalTime);\n            }\n            if (this._repeat) {\n                //adjust the time for repeats and yoyos\n                yoyo = this._yoyo;\n                cycleDuration = dur + this._rDelay;\n                if (this._repeat < -1 && totalTime < 0) {\n                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                }\n                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n                if (tTime === tDur) {\n                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n                    iteration = this._repeat;\n                    time = dur;\n                } else {\n                    prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)\n                    iteration = ~~prevIteration;\n                    if (iteration && iteration === prevIteration) {\n                        time = dur;\n                        iteration--;\n                    }\n                    time > dur && (time = dur);\n                }\n                prevIteration = _animationCycle(this._tTime, cycleDuration);\n                !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the \"repeatDelay\" portion\n                if (yoyo && iteration & 1) {\n                    time = dur - time;\n                    isYoyo = 1;\n                }\n                /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */ if (iteration !== prevIteration && !this._lock) {\n                    var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);\n                    iteration < prevIteration && (rewinding = !rewinding);\n                    prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.\n                    this._lock = 1;\n                    this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n                    this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.\n                    !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n                    if (this.vars.repeatRefresh && !isYoyo) {\n                        this.invalidate()._lock = 1;\n                        prevIteration = iteration; // otherwise, the onStart() may fire on the 2nd iteration.\n                    }\n                    if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n                        // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.\n                        return this;\n                    }\n                    dur = this._dur; // in case the duration changed in the onRepeat\n                    tDur = this._tDur;\n                    if (doesWrap) {\n                        this._lock = 2;\n                        prevTime = rewinding ? dur : -0.0001;\n                        this.render(prevTime, true);\n                        this.vars.repeatRefresh && !isYoyo && this.invalidate();\n                    }\n                    this._lock = 0;\n                    if (!this._ts && !prevPaused) {\n                        return this;\n                    } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.\n                    _propagateYoyoEase(this, isYoyo);\n                }\n            }\n            if (this._hasPause && !this._forcing && this._lock < 2) {\n                pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n                if (pauseTween) {\n                    tTime -= time - (time = pauseTween._start);\n                }\n            }\n            this._tTime = tTime;\n            this._time = time;\n            this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n            if (!this._initted) {\n                this._onUpdate = this.vars.onUpdate;\n                this._initted = 1;\n                this._zTime = totalTime;\n                prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n            }\n            if (!prevTime && tTime && dur && !suppressEvents && !prevIteration) {\n                _callback(this, \"onStart\");\n                if (this._tTime !== tTime) {\n                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n                    return this;\n                }\n            }\n            if (time >= prevTime && totalTime >= 0) {\n                child = this._first;\n                while(child){\n                    next = child._next;\n                    if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n                        if (child.parent !== this) {\n                            // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n                            return this.render(totalTime, suppressEvents, force);\n                        }\n                        child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n                        if (time !== this._time || !this._ts && !prevPaused) {\n                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n                            pauseTween = 0;\n                            next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that the next time render() is called it'll be forced (to render any remaining children)\n                            break;\n                        }\n                    }\n                    child = next;\n                }\n            } else {\n                child = this._last;\n                var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n                while(child){\n                    next = child._prev;\n                    if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n                        if (child.parent !== this) {\n                            // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n                            return this.render(totalTime, suppressEvents, force);\n                        }\n                        child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.\n                        if (time !== this._time || !this._ts && !prevPaused) {\n                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n                            pauseTween = 0;\n                            next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)\n                            break;\n                        }\n                    }\n                    child = next;\n                }\n            }\n            if (pauseTween && !suppressEvents) {\n                this.pause();\n                pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n                if (this._ts) {\n                    //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).\n                    this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.\n                    _setEnd(this);\n                    return this.render(totalTime, suppressEvents, force);\n                }\n            }\n            this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n            if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {\n                if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {\n                    if (!this._lock) {\n                        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.\n                        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n                        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n                            _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                        }\n                    }\n                }\n            }\n        }\n        return this;\n    };\n    _proto2.add = function add(child, position) {\n        var _this2 = this;\n        _isNumber(position) || (position = _parsePosition(this, position, child));\n        if (!(child instanceof Animation)) {\n            if (_isArray(child)) {\n                child.forEach(function(obj) {\n                    return _this2.add(obj, position);\n                });\n                return this;\n            }\n            if (_isString(child)) {\n                return this.addLabel(child, position);\n            }\n            if (_isFunction(child)) {\n                child = Tween.delayedCall(0, child);\n            } else {\n                return this;\n            }\n        }\n        return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!\n    };\n    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n        if (nested === void 0) {\n            nested = true;\n        }\n        if (tweens === void 0) {\n            tweens = true;\n        }\n        if (timelines === void 0) {\n            timelines = true;\n        }\n        if (ignoreBeforeTime === void 0) {\n            ignoreBeforeTime = -_bigNum;\n        }\n        var a = [], child = this._first;\n        while(child){\n            if (child._start >= ignoreBeforeTime) {\n                if (child instanceof Tween) {\n                    tweens && a.push(child);\n                } else {\n                    timelines && a.push(child);\n                    nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n                }\n            }\n            child = child._next;\n        }\n        return a;\n    };\n    _proto2.getById = function getById(id) {\n        var animations = this.getChildren(1, 1, 1), i = animations.length;\n        while(i--){\n            if (animations[i].vars.id === id) {\n                return animations[i];\n            }\n        }\n    };\n    _proto2.remove = function remove(child) {\n        if (_isString(child)) {\n            return this.removeLabel(child);\n        }\n        if (_isFunction(child)) {\n            return this.killTweensOf(child);\n        }\n        child.parent === this && _removeLinkedListItem(this, child);\n        if (child === this._recent) {\n            this._recent = this._last;\n        }\n        return _uncache(this);\n    };\n    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n        if (!arguments.length) {\n            return this._tTime;\n        }\n        this._forcing = 1;\n        if (!this._dp && this._ts) {\n            //special case for the global timeline (or any other that has no parent or detached parent).\n            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n        }\n        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n        this._forcing = 0;\n        return this;\n    };\n    _proto2.addLabel = function addLabel(label, position) {\n        this.labels[label] = _parsePosition(this, position);\n        return this;\n    };\n    _proto2.removeLabel = function removeLabel(label) {\n        delete this.labels[label];\n        return this;\n    };\n    _proto2.addPause = function addPause(position, callback, params) {\n        var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n        t.data = \"isPause\";\n        this._hasPause = 1;\n        return _addToTimeline(this, t, _parsePosition(this, position));\n    };\n    _proto2.removePause = function removePause(position) {\n        var child = this._first;\n        position = _parsePosition(this, position);\n        while(child){\n            if (child._start === position && child.data === \"isPause\") {\n                _removeFromParent(child);\n            }\n            child = child._next;\n        }\n    };\n    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n        var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;\n        while(i--){\n            _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n        }\n        return this;\n    };\n    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n        var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), // a number is interpreted as a global time. If the animation spans\n        children;\n        while(child){\n            if (child instanceof Tween) {\n                if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n                    // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.\n                    a.push(child);\n                }\n            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n                a.push.apply(a, children);\n            }\n            child = child._next;\n        }\n        return a;\n    } // potential future feature - targets() on timelines\n    ;\n    _proto2.tweenTo = function tweenTo(position, vars) {\n        vars = vars || {};\n        var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({\n            ease: vars.ease || \"none\",\n            lazy: false,\n            immediateRender: false,\n            time: endTime,\n            overwrite: \"auto\",\n            duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n            onStart: function onStart() {\n                tl.pause();\n                if (!initted) {\n                    var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n                    tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n                    initted = 1;\n                }\n                _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.\n            }\n        }, vars));\n        return immediateRender ? tween.render(0) : tween;\n    };\n    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n        return this.tweenTo(toPosition, _setDefaults({\n            startAt: {\n                time: _parsePosition(this, fromPosition)\n            }\n        }, vars));\n    };\n    _proto2.recent = function recent() {\n        return this._recent;\n    };\n    _proto2.nextLabel = function nextLabel(afterTime) {\n        if (afterTime === void 0) {\n            afterTime = this._time;\n        }\n        return _getLabelInDirection(this, _parsePosition(this, afterTime));\n    };\n    _proto2.previousLabel = function previousLabel(beforeTime) {\n        if (beforeTime === void 0) {\n            beforeTime = this._time;\n        }\n        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n    };\n    _proto2.currentLabel = function currentLabel(value) {\n        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n    };\n    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n        if (ignoreBeforeTime === void 0) {\n            ignoreBeforeTime = 0;\n        }\n        var child = this._first, labels = this.labels, p;\n        amount = _roundPrecise(amount);\n        while(child){\n            if (child._start >= ignoreBeforeTime) {\n                child._start += amount;\n                child._end += amount;\n            }\n            child = child._next;\n        }\n        if (adjustLabels) {\n            for(p in labels){\n                if (labels[p] >= ignoreBeforeTime) {\n                    labels[p] += amount;\n                }\n            }\n        }\n        return _uncache(this);\n    };\n    _proto2.invalidate = function invalidate(soft) {\n        var child = this._first;\n        this._lock = 0;\n        while(child){\n            child.invalidate(soft);\n            child = child._next;\n        }\n        return _Animation.prototype.invalidate.call(this, soft);\n    };\n    _proto2.clear = function clear(includeLabels) {\n        if (includeLabels === void 0) {\n            includeLabels = true;\n        }\n        var child = this._first, next;\n        while(child){\n            next = child._next;\n            this.remove(child);\n            child = next;\n        }\n        this._dp && (this._time = this._tTime = this._pTime = 0);\n        includeLabels && (this.labels = {});\n        return _uncache(this);\n    };\n    _proto2.totalDuration = function totalDuration(value) {\n        var max = 0, self = this, child = self._last, prevStart = _bigNum, prev, start, parent;\n        if (arguments.length) {\n            return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n        }\n        if (self._dirty) {\n            parent = self.parent;\n            while(child){\n                prev = child._prev; //record it here in case the tween changes position in the sequence...\n                child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.\n                start = child._start;\n                if (start > prevStart && self._sort && child._ts && !self._lock) {\n                    //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n                    self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n                    _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n                } else {\n                    prevStart = start;\n                }\n                if (start < 0 && child._ts) {\n                    //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n                    max -= start;\n                    if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n                        self._start += _roundPrecise(start / self._ts);\n                        self._time -= start;\n                        self._tTime -= start;\n                    }\n                    self.shiftChildren(-start, false, -Infinity);\n                    prevStart = 0;\n                }\n                child._end > max && child._ts && (max = child._end);\n                child = prev;\n            }\n            _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n            self._dirty = 0;\n        }\n        return self._tDur;\n    };\n    Timeline.updateRoot = function updateRoot(time) {\n        if (_globalTimeline._ts) {\n            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n            _lastRenderedFrame = _ticker.frame;\n        }\n        if (_ticker.frame >= _nextGCFrame) {\n            _nextGCFrame += _config.autoSleep || 120;\n            var child = _globalTimeline._first;\n            if (!child || !child._ts) {\n                if (_config.autoSleep && _ticker._listeners.length < 2) {\n                    while(child && !child._ts){\n                        child = child._next;\n                    }\n                    child || _ticker.sleep();\n                }\n            }\n        }\n    };\n    return Timeline;\n}(Animation);\n_setDefaults(Timeline.prototype, {\n    _lock: 0,\n    _hasPause: 0,\n    _forcing: 0\n});\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;\n    pt.b = start;\n    pt.e = end;\n    start += \"\"; //ensure values are strings\n    end += \"\";\n    if (hasRandom = ~end.indexOf(\"random(\")) {\n        end = _replaceRandom(end);\n    }\n    if (stringFilter) {\n        a = [\n            start,\n            end\n        ];\n        stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n        start = a[0];\n        end = a[1];\n    }\n    startNums = start.match(_complexStringNumExp) || [];\n    while(result = _complexStringNumExp.exec(end)){\n        endNum = result[0];\n        chunk = end.substring(index, result.index);\n        if (color) {\n            color = (color + 1) % 5;\n        } else if (chunk.substr(-5) === \"rgba(\") {\n            color = 1;\n        }\n        if (endNum !== startNums[matchIndex++]) {\n            startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n            pt._pt = {\n                _next: pt._pt,\n                p: chunk || matchIndex === 1 ? chunk : \",\",\n                //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n                s: startNum,\n                c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n                m: color && color < 4 ? Math.round : 0\n            };\n            index = _complexStringNumExp.lastIndex;\n        }\n    }\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n    pt.fp = funcParam;\n    if (_relExp.test(end) || hasRandom) {\n        pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n    }\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    return pt;\n}, _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n    _isFunction(end) && (end = end(index || 0, target, targets));\n    var currentValue = target[prop], parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;\n    if (_isString(end)) {\n        if (~end.indexOf(\"random(\")) {\n            end = _replaceRandom(end);\n        }\n        if (end.charAt(1) === \"=\") {\n            pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n            if (pt || pt === 0) {\n                // to avoid isNaN, like if someone passes in a value like \"!= whatever\"\n                end = pt;\n            }\n        }\n    }\n    if (!optional || parsedStart !== end || _forceAllPropTweens) {\n        if (!isNaN(parsedStart * end) && end !== \"\") {\n            // fun fact: any number multiplied by \"\" is evaluated as the number 0!\n            pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n            funcParam && (pt.fp = funcParam);\n            modifier && pt.modifier(modifier, this, target);\n            return this._pt = pt;\n        }\n        !currentValue && !(prop in target) && _missingPlugin(prop, end);\n        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n    }\n}, //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with \"random()\" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n        return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n    }\n    var copy = {}, p;\n    for(p in vars){\n        copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n    }\n    return copy;\n}, _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n    var plugin, pt, ptLookup, i;\n    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n        if (tween !== _quickTween) {\n            ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.\n            i = plugin._props.length;\n            while(i--){\n                ptLookup[plugin._props[i]] = pt;\n            }\n        }\n    }\n    return plugin;\n}, _overwritingTween, //store a reference temporarily so we can avoid overwriting itself.\n_forceAllPropTweens, _initTween = function _initTween(tween, time, tTime) {\n    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;\n    tl && (!keyframes || !ease) && (ease = \"none\");\n    tween._ease = _parseEase(ease, _defaults.ease);\n    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n    if (yoyoEase && tween._yoyo && !tween._repeat) {\n        //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n        yoyoEase = tween._yEase;\n        tween._yEase = tween._ease;\n        tween._ease = yoyoEase;\n    }\n    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n    if (!tl || keyframes && !vars.stagger) {\n        //if there's an internal timeline, skip all the parsing because we passed that task down the chain.\n        harness = targets[0] ? _getCache(targets[0]).harness : 0;\n        harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an \"x\" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n        cleanVars = _copyExcluding(vars, _reservedProps);\n        if (prevStartAt) {\n            prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.\n            time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a \"startAt\" (not \"from()\" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)\n            // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for \"startAt\" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.\n            prevStartAt._lazy = 0;\n        }\n        if (startAt) {\n            _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n                data: \"isStart\",\n                overwrite: false,\n                parent: parent,\n                immediateRender: true,\n                lazy: !prevStartAt && _isNotFalse(lazy),\n                startAt: null,\n                delay: 0,\n                onUpdate: onUpdate && function() {\n                    return _callback(tween, \"onUpdate\");\n                },\n                stagger: 0\n            }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n            tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.\n            tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween\n            time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.\n            if (immediateRender) {\n                if (dur && time <= 0 && tTime <= 0) {\n                    // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.\n                    time && (tween._zTime = time);\n                    return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\n                }\n            }\n        } else if (runBackwards && dur) {\n            //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n            if (!prevStartAt) {\n                time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\n                p = _setDefaults({\n                    overwrite: false,\n                    data: \"isFromStart\",\n                    //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n                    lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n                    immediateRender: immediateRender,\n                    //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n                    stagger: 0,\n                    parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\n                }, cleanVars);\n                harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n                _removeFromParent(tween._startAt = Tween.set(targets, p));\n                tween._startAt._dp = 0; // don't allow it to get put back into root timeline!\n                tween._startAt._sat = tween; // used in globalTime()\n                time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n                tween._zTime = time;\n                if (!immediateRender) {\n                    _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded\n                } else if (!time) {\n                    return;\n                }\n            }\n        }\n        tween._pt = tween._ptCache = 0;\n        lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n        for(i = 0; i < targets.length; i++){\n            target = targets[i];\n            gsData = target._gsap || _harness(targets)[i]._gsap;\n            tween._ptLookup[i] = ptLookup = {};\n            _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n            index = fullTargets === targets ? i : fullTargets.indexOf(target);\n            if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n                tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n                plugin._props.forEach(function(name) {\n                    ptLookup[name] = pt;\n                });\n                plugin.priority && (hasPriority = 1);\n            }\n            if (!harness || harnessVars) {\n                for(p in cleanVars){\n                    if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n                        plugin.priority && (hasPriority = 1);\n                    } else {\n                        ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n                    }\n                }\n            }\n            tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n            if (autoOverwrite && tween._pt) {\n                _overwritingTween = tween;\n                _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!\n                overwritten = !tween.parent;\n                _overwritingTween = 0;\n            }\n            tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n        }\n        hasPriority && _sortPropTweensByPriority(tween);\n        tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.\n    }\n    tween._onUpdate = onUpdate;\n    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n    keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the \"before\" state for any staggered/delayed animations thus when the following tween initializes, it'll use the \"before\" state instead of the \"after\" state as the initial values.\n}, _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\n    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;\n    if (!ptCache) {\n        ptCache = tween._ptCache[property] = [];\n        lookup = tween._ptLookup;\n        i = tween._targets.length;\n        while(i--){\n            pt = lookup[i][property];\n            if (pt && pt.d && pt.d._pt) {\n                // it's a plugin, so find the nested PropTween\n                pt = pt.d._pt;\n                while(pt && pt.p !== property && pt.fp !== property){\n                    // \"fp\" is functionParam for things like setting CSS variables which require .setProperty(\"--var-name\", value)\n                    pt = pt._next;\n                }\n            }\n            if (!pt) {\n                // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this\n                // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo(\"x\", 200) for example.\n                _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.\n                tween.vars[property] = \"+=0\";\n                _initTween(tween, time);\n                _forceAllPropTweens = 0;\n                return skipRecursion ? _warn(property + \" not eligible for reset\") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().\n            }\n            ptCache.push(pt);\n        }\n    }\n    i = ptCache.length;\n    while(i--){\n        rootPT = ptCache[i];\n        pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.\n        pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n        pt.c = value - pt.s;\n        rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)\n        rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)\n    }\n}, _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;\n    if (!propertyAliases) {\n        return vars;\n    }\n    copy = _merge({}, vars);\n    for(p in propertyAliases){\n        if (p in copy) {\n            aliases = propertyAliases[p].split(\",\");\n            i = aliases.length;\n            while(i--){\n                copy[aliases[i]] = copy[p];\n            }\n        }\n    }\n    return copy;\n}, // parses multiple formats, like {\"0%\": {x: 100}, {\"50%\": {x: -20}} and { x: {\"0%\": 100, \"50%\": -20} }, and an \"ease\" can be set on any object. We populate an \"allProps\" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a \"t\" (time), \"v\", (value), and \"e\" (ease) property. This allows us to piece together a timeline later.\n_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n    var ease = obj.ease || easeEach || \"power1.inOut\", p, a;\n    if (_isArray(obj)) {\n        a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease\n        obj.forEach(function(value, i) {\n            return a.push({\n                t: i / (obj.length - 1) * 100,\n                v: value,\n                e: ease\n            });\n        });\n    } else {\n        for(p in obj){\n            a = allProps[p] || (allProps[p] = []);\n            p === \"ease\" || a.push({\n                t: parseFloat(prop),\n                v: obj[p],\n                e: ease\n            });\n        }\n    }\n}, _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n}, _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\", _staggerPropsToSkip = {};\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function(name) {\n    return _staggerPropsToSkip[name] = 1;\n});\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */ var Tween = /*#__PURE__*/ function(_Animation2) {\n    _inheritsLoose(Tween, _Animation2);\n    function Tween(targets, vars, position, skipInherit) {\n        var _this3;\n        if (typeof vars === \"number\") {\n            position.duration = vars;\n            vars = position;\n            position = null;\n        }\n        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n        var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [\n            targets\n        ] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;\n        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\n        _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n        _this3._overwrite = overwrite;\n        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n            vars = _this3.vars;\n            tl = _this3.timeline = new Timeline({\n                data: \"nested\",\n                defaults: defaults || {},\n                targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n            }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.\n            tl.kill();\n            tl.parent = tl._dp = _assertThisInitialized(_this3);\n            tl._start = 0;\n            if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n                l = parsedTargets.length;\n                staggerFunc = stagger && distribute(stagger);\n                if (_isObject(stagger)) {\n                    //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n                    for(p in stagger){\n                        if (~_staggerTweenProps.indexOf(p)) {\n                            staggerVarsToMerge || (staggerVarsToMerge = {});\n                            staggerVarsToMerge[p] = stagger[p];\n                        }\n                    }\n                }\n                for(i = 0; i < l; i++){\n                    copy = _copyExcluding(vars, _staggerPropsToSkip);\n                    copy.stagger = 0;\n                    yoyoEase && (copy.yoyoEase = yoyoEase);\n                    staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n                    curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n                    copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n                    copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n                    if (!stagger && l === 1 && copy.delay) {\n                        // if someone does delay:\"random(1, 5)\", repeat:-1, for example, the delay shouldn't be inside the repeat.\n                        _this3._delay = delay = copy.delay;\n                        _this3._start += delay;\n                        copy.delay = 0;\n                    }\n                    tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n                    tl._ease = _easeMap.none;\n                }\n                tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!\n            } else if (keyframes) {\n                _inheritDefaults(_setDefaults(tl.vars.defaults, {\n                    ease: \"none\"\n                }));\n                tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n                var time = 0, a, kf, v;\n                if (_isArray(keyframes)) {\n                    keyframes.forEach(function(frame) {\n                        return tl.to(parsedTargets, frame, \">\");\n                    });\n                    tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.\n                } else {\n                    copy = {};\n                    for(p in keyframes){\n                        p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n                    }\n                    for(p in copy){\n                        a = copy[p].sort(function(a, b) {\n                            return a.t - b.t;\n                        });\n                        time = 0;\n                        for(i = 0; i < a.length; i++){\n                            kf = a[i];\n                            v = {\n                                ease: kf.e,\n                                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n                            };\n                            v[p] = kf.v;\n                            tl.to(parsedTargets, v, time);\n                            time += v.duration;\n                        }\n                    }\n                    tl.duration() < duration && tl.to({}, {\n                        duration: duration - tl.duration()\n                    }); // in case keyframes didn't go to 100%\n                }\n            }\n            duration || _this3.duration(duration = tl.duration());\n        } else {\n            _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n        }\n        if (overwrite === true && !_suppressOverwrites) {\n            _overwritingTween = _assertThisInitialized(_this3);\n            _globalTimeline.killTweensOf(parsedTargets);\n            _overwritingTween = 0;\n        }\n        _addToTimeline(parent, _assertThisInitialized(_this3), position);\n        vars.reversed && _this3.reverse();\n        vars.paused && _this3.paused(true);\n        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n            _this3._tTime = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n            _this3.render(Math.max(0, -delay) || 0); //in case delay is negative\n        }\n        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n        return _this3;\n    }\n    var _proto3 = Tween.prototype;\n    _proto3.render = function render(totalTime, suppressEvents, force) {\n        var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;\n        if (!dur) {\n            _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {\n            // this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n            time = tTime;\n            timeline = this.timeline;\n            if (this._repeat) {\n                //adjust the time for repeats and yoyos\n                cycleDuration = dur + this._rDelay;\n                if (this._repeat < -1 && isNegative) {\n                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                }\n                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n                if (tTime === tDur) {\n                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n                    iteration = this._repeat;\n                    time = dur;\n                } else {\n                    prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)\n                    iteration = ~~prevIteration;\n                    if (iteration && iteration === prevIteration) {\n                        time = dur;\n                        iteration--;\n                    } else if (time > dur) {\n                        time = dur;\n                    }\n                }\n                isYoyo = this._yoyo && iteration & 1;\n                if (isYoyo) {\n                    yoyoEase = this._yEase;\n                    time = dur - time;\n                }\n                prevIteration = _animationCycle(this._tTime, cycleDuration);\n                if (time === prevTime && !force && this._initted && iteration === prevIteration) {\n                    //could be during the repeatDelay part. No need to render and fire callbacks.\n                    this._tTime = tTime;\n                    return this;\n                }\n                if (iteration !== prevIteration) {\n                    timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n                    if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {\n                        // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).\n                        this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.\n                        this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n                    }\n                }\n            }\n            if (!this._initted) {\n                if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n                    this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.\n                    return this;\n                }\n                if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\n                    // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!\n                    return this;\n                }\n                if (dur !== this._dur) {\n                    // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n                    return this.render(totalTime, suppressEvents, force);\n                }\n            }\n            this._tTime = tTime;\n            this._time = time;\n            if (!this._act && this._ts) {\n                this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n                this._lazy = 0;\n            }\n            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n            if (this._from) {\n                this.ratio = ratio = 1 - ratio;\n            }\n            if (!prevTime && tTime && !suppressEvents && !prevIteration) {\n                _callback(this, \"onStart\");\n                if (this._tTime !== tTime) {\n                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n                    return this;\n                }\n            }\n            pt = this._pt;\n            while(pt){\n                pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n            timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n            if (this._onUpdate && !suppressEvents) {\n                isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n                _callback(this, \"onUpdate\");\n            }\n            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n                isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n                (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n                if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n                    // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n                    _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                }\n            }\n        }\n        return this;\n    };\n    _proto3.targets = function targets() {\n        return this._targets;\n    };\n    _proto3.invalidate = function invalidate(soft) {\n        // \"soft\" gives us a way to clear out everything EXCEPT the recorded pre-\"from\" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the \"from\" values would persist and then on the next render, the from() tweens would initialize and the current value would match the \"from\" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.\n        (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n        this._ptLookup = [];\n        this.timeline && this.timeline.invalidate(soft);\n        return _Animation2.prototype.invalidate.call(this, soft);\n    };\n    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\n        _tickerActive || _ticker.wake();\n        this._ts || this.play();\n        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;\n        this._initted || _initTween(this, time);\n        ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.\n        // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.\n        // if (_isObject(property)) { // performance optimization\n        // \tfor (p in property) {\n        // \t\tif (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {\n        // \t\t\treturn this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n        // \t\t}\n        // \t}\n        // } else {\n        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\n            return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n        } //}\n        _alignPlayhead(this, 0);\n        this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n        return this.render(0);\n    };\n    _proto3.kill = function kill(targets, vars) {\n        if (vars === void 0) {\n            vars = \"all\";\n        }\n        if (!targets && (!vars || vars === \"all\")) {\n            this._lazy = this._pt = 0;\n            this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);\n            return this;\n        }\n        if (this.timeline) {\n            var tDur = this.timeline.totalDuration();\n            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.\n            return this;\n        }\n        var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;\n        if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n            vars === \"all\" && (this._pt = 0);\n            return _interrupt(this);\n        }\n        overwrittenProps = this._op = this._op || [];\n        if (vars !== \"all\") {\n            //so people can pass in a comma-delimited list of property names\n            if (_isString(vars)) {\n                p = {};\n                _forEachName(vars, function(name) {\n                    return p[name] = 1;\n                });\n                vars = p;\n            }\n            vars = _addAliasesToVars(parsedTargets, vars);\n        }\n        i = parsedTargets.length;\n        while(i--){\n            if (~killingTargets.indexOf(parsedTargets[i])) {\n                curLookup = propTweenLookup[i];\n                if (vars === \"all\") {\n                    overwrittenProps[i] = vars;\n                    props = curLookup;\n                    curOverwriteProps = {};\n                } else {\n                    curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n                    props = vars;\n                }\n                for(p in props){\n                    pt = curLookup && curLookup[p];\n                    if (pt) {\n                        if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n                            _removeLinkedListItem(this, pt, \"_pt\");\n                        }\n                        delete curLookup[p];\n                    }\n                    if (curOverwriteProps !== \"all\") {\n                        curOverwriteProps[p] = 1;\n                    }\n                }\n            }\n        }\n        this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\n        return this;\n    };\n    Tween.to = function to(targets, vars) {\n        return new Tween(targets, vars, arguments[2]);\n    };\n    Tween.from = function from(targets, vars) {\n        return _createTweenType(1, arguments);\n    };\n    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n        return new Tween(callback, 0, {\n            immediateRender: false,\n            lazy: false,\n            overwrite: false,\n            delay: delay,\n            onComplete: callback,\n            onReverseComplete: callback,\n            onCompleteParams: params,\n            onReverseCompleteParams: params,\n            callbackScope: scope\n        }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)\n    };\n    Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n        return _createTweenType(2, arguments);\n    };\n    Tween.set = function set(targets, vars) {\n        vars.duration = 0;\n        vars.repeatDelay || (vars.repeat = 0);\n        return new Tween(targets, vars);\n    };\n    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n        return _globalTimeline.killTweensOf(targets, props, onlyActive);\n    };\n    return Tween;\n}(Animation);\n_setDefaults(Tween.prototype, {\n    _targets: [],\n    _lazy: 0,\n    _startAt: 0,\n    _op: 0,\n    _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)\n// _forEachName(\"to,from,fromTo,set,call,add,addLabel,addPause\", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function(name) {\n    Tween[name] = function() {\n        var tl = new Timeline(), params = _slice.call(arguments, 0);\n        params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n        return tl[name].apply(tl, params);\n    };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */ var _setterPlain = function _setterPlain(target, property, value) {\n    return target[property] = value;\n}, _setterFunc = function _setterFunc(target, property, value) {\n    return target[property](value);\n}, _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n    return target[property](data.fp, value);\n}, _setterAttribute = function _setterAttribute(target, property, value) {\n    return target.setAttribute(property, value);\n}, _getSetter = function _getSetter(target, property) {\n    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n}, _renderPlain = function _renderPlain(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\n}, _renderBoolean = function _renderBoolean(ratio, data) {\n    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n}, _renderComplexString = function _renderComplexString(ratio, data) {\n    var pt = data._pt, s = \"\";\n    if (!ratio && data.b) {\n        //b = beginning string\n        s = data.b;\n    } else if (ratio === 1 && data.e) {\n        //e = ending string\n        s = data.e;\n    } else {\n        while(pt){\n            s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the \"p\" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n            pt = pt._next;\n        }\n        s += data.c; //we use the \"c\" of the PropTween to store the final chunk of non-numeric text.\n    }\n    data.set(data.t, data.p, s, data);\n}, _renderPropTweens = function _renderPropTweens(ratio, data) {\n    var pt = data._pt;\n    while(pt){\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n    }\n}, _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n    var pt = this._pt, next;\n    while(pt){\n        next = pt._next;\n        pt.p === property && pt.modifier(modifier, tween, target);\n        pt = next;\n    }\n}, _killPropTweensOf = function _killPropTweensOf(property) {\n    var pt = this._pt, hasNonDependentRemaining, next;\n    while(pt){\n        next = pt._next;\n        if (pt.p === property && !pt.op || pt.op === property) {\n            _removeLinkedListItem(this, pt, \"_pt\");\n        } else if (!pt.dep) {\n            hasNonDependentRemaining = 1;\n        }\n        pt = next;\n    }\n    return !hasNonDependentRemaining;\n}, _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n}, _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n    var pt = parent._pt, next, pt2, first, last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n    while(pt){\n        next = pt._next;\n        pt2 = first;\n        while(pt2 && pt2.pr > pt.pr){\n            pt2 = pt2._next;\n        }\n        if (pt._prev = pt2 ? pt2._prev : last) {\n            pt._prev._next = pt;\n        } else {\n            first = pt;\n        }\n        if (pt._next = pt2) {\n            pt2._prev = pt;\n        } else {\n            last = pt;\n        }\n        pt = next;\n    }\n    parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\nvar PropTween = /*#__PURE__*/ function() {\n    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n        this.t = target;\n        this.s = start;\n        this.c = change;\n        this.p = prop;\n        this.r = renderer || _renderPlain;\n        this.d = data || this;\n        this.set = setter || _setterPlain;\n        this.pr = priority || 0;\n        this._next = next;\n        if (next) {\n            next._prev = this;\n        }\n    }\n    var _proto4 = PropTween.prototype;\n    _proto4.modifier = function modifier(func, tween, target) {\n        this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n        this.set = _setterWithModifier;\n        this.m = func;\n        this.mt = target; //modifier target\n        this.tween = tween;\n    };\n    return PropTween;\n}(); //Initialization tasks\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function(name) {\n    return _reservedProps[name] = 1;\n});\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n    sortChildren: false,\n    defaults: _defaults,\n    autoRemoveChildren: true,\n    id: \"root\",\n    smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\nvar _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch(type) {\n    return (_listeners[type] || _emptyArray).map(function(f) {\n        return f();\n    });\n}, _onMediaChange = function _onMediaChange() {\n    var time = Date.now(), matches = [];\n    if (time - _lastMediaTime > 2) {\n        _dispatch(\"matchMediaInit\");\n        _media.forEach(function(c) {\n            var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;\n            for(p in queries){\n                match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n                match && (anyMatch = 1);\n                if (match !== conditions[p]) {\n                    conditions[p] = match;\n                    toggled = 1;\n                }\n            }\n            if (toggled) {\n                c.revert();\n                anyMatch && matches.push(c);\n            }\n        });\n        _dispatch(\"matchMediaRevert\");\n        matches.forEach(function(c) {\n            return c.onMatch(c, function(func) {\n                return c.add(null, func);\n            });\n        });\n        _lastMediaTime = time;\n        _dispatch(\"matchMedia\");\n    }\n};\nvar Context = /*#__PURE__*/ function() {\n    function Context(func, scope) {\n        this.selector = scope && selector(scope);\n        this.data = [];\n        this._r = []; // returned/cleanup functions\n        this.isReverted = false;\n        this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because \"this\" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely\n        func && this.add(func);\n    }\n    var _proto5 = Context.prototype;\n    _proto5.add = function add(name, func, scope) {\n        // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.\n        // if (name && _isFunction(name.revert)) {\n        // \tthis.data.push(name);\n        // \treturn (name._ctx = this);\n        // }\n        if (_isFunction(name)) {\n            scope = func;\n            func = name;\n            name = _isFunction;\n        }\n        var self = this, f = function f() {\n            var prev = _context, prevSelector = self.selector, result;\n            prev && prev !== self && prev.data.push(self);\n            scope && (self.selector = selector(scope));\n            _context = self;\n            result = func.apply(self, arguments);\n            _isFunction(result) && self._r.push(result);\n            _context = prev;\n            self.selector = prevSelector;\n            self.isReverted = false;\n            return result;\n        };\n        self.last = f;\n        return name === _isFunction ? f(self, function(func) {\n            return self.add(null, func);\n        }) : name ? self[name] = f : f;\n    };\n    _proto5.ignore = function ignore(func) {\n        var prev = _context;\n        _context = null;\n        func(this);\n        _context = prev;\n    };\n    _proto5.getTweens = function getTweens() {\n        var a = [];\n        this.data.forEach(function(e) {\n            return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n        });\n        return a;\n    };\n    _proto5.clear = function clear() {\n        this._r.length = this.data.length = 0;\n    };\n    _proto5.kill = function kill(revert, matchMedia) {\n        var _this4 = this;\n        if (revert) {\n            (function() {\n                var tweens = _this4.getTweens(), i = _this4.data.length, t;\n                while(i--){\n                    // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.\n                    t = _this4.data[i];\n                    if (t.data === \"isFlip\") {\n                        t.revert();\n                        t.getChildren(true, true, false).forEach(function(tween) {\n                            return tweens.splice(tweens.indexOf(tween), 1);\n                        });\n                    }\n                } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort\n                tweens.map(function(t) {\n                    return {\n                        g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,\n                        t: t\n                    };\n                }).sort(function(a, b) {\n                    return b.g - a.g || -Infinity;\n                }).forEach(function(o) {\n                    return o.t.revert(revert);\n                }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the \" || -1\" in the sort keeps the order properly.\n                i = _this4.data.length;\n                while(i--){\n                    // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first\n                    t = _this4.data[i];\n                    if (t instanceof Timeline) {\n                        if (t.data !== \"nested\") {\n                            t.scrollTrigger && t.scrollTrigger.revert();\n                            t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens\n                        }\n                    } else {\n                        !(t instanceof Tween) && t.revert && t.revert(revert);\n                    }\n                }\n                _this4._r.forEach(function(f) {\n                    return f(revert, _this4);\n                });\n                _this4.isReverted = true;\n            })();\n        } else {\n            this.data.forEach(function(e) {\n                return e.kill && e.kill();\n            });\n        }\n        this.clear();\n        if (matchMedia) {\n            var i = _media.length;\n            while(i--){\n                // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.\n                _media[i].id === this.id && _media.splice(i, 1);\n            }\n        }\n    } // killWithCleanup() {\n    ;\n    _proto5.revert = function revert(config) {\n        this.kill(config || {});\n    };\n    return Context;\n}();\nvar MatchMedia = /*#__PURE__*/ function() {\n    function MatchMedia(scope) {\n        this.contexts = [];\n        this.scope = scope;\n        _context && _context.data.push(this);\n    }\n    var _proto6 = MatchMedia.prototype;\n    _proto6.add = function add(conditions, func, scope) {\n        _isObject(conditions) || (conditions = {\n            matches: conditions\n        });\n        var context = new Context(0, scope || this.scope), cond = context.conditions = {}, mq, p, active;\n        _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()\n        this.contexts.push(context);\n        func = context.add(\"onMatch\", func);\n        context.queries = conditions;\n        for(p in conditions){\n            if (p === \"all\") {\n                active = 1;\n            } else {\n                mq = _win.matchMedia(conditions[p]);\n                if (mq) {\n                    _media.indexOf(context) < 0 && _media.push(context);\n                    (cond[p] = mq.matches) && (active = 1);\n                    mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n                }\n            }\n        }\n        active && func(context, function(f) {\n            return context.add(null, f);\n        });\n        return this;\n    } // refresh() {\n    ;\n    _proto6.revert = function revert(config) {\n        this.kill(config || {});\n    };\n    _proto6.kill = function kill(revert) {\n        this.contexts.forEach(function(c) {\n            return c.kill(revert, true);\n        });\n    };\n    return MatchMedia;\n}();\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */ var _gsap = {\n    registerPlugin: function registerPlugin() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        args.forEach(function(config) {\n            return _createPlugin(config);\n        });\n    },\n    timeline: function timeline(vars) {\n        return new Timeline(vars);\n    },\n    getTweensOf: function getTweensOf(targets, onlyActive) {\n        return _globalTimeline.getTweensOf(targets, onlyActive);\n    },\n    getProperty: function getProperty(target, property, unit, uncache) {\n        _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n        var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;\n        unit === \"native\" && (unit = \"\");\n        return !target ? target : !property ? function(property, unit, uncache) {\n            return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    },\n    quickSetter: function quickSetter(target, property, unit) {\n        target = toArray(target);\n        if (target.length > 1) {\n            var setters = target.map(function(t) {\n                return gsap.quickSetter(t, property, unit);\n            }), l = setters.length;\n            return function(value) {\n                var i = l;\n                while(i--){\n                    setters[i](value);\n                }\n            };\n        }\n        target = target[0] || {};\n        var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, // in case it's an alias, like \"rotate\" for \"rotation\".\n        setter = Plugin ? function(value) {\n            var p = new Plugin();\n            _quickTween._pt = 0;\n            p.init(target, unit ? value + unit : value, _quickTween, 0, [\n                target\n            ]);\n            p.render(1, p);\n            _quickTween._pt && _renderPropTweens(1, _quickTween);\n        } : cache.set(target, p);\n        return Plugin ? setter : function(value) {\n            return setter(target, p, unit ? value + unit : value, cache, 1);\n        };\n    },\n    quickTo: function quickTo(target, property, vars) {\n        var _setDefaults2;\n        var tween = gsap.to(target, _setDefaults((_setDefaults2 = {}, _setDefaults2[property] = \"+=0.1\", _setDefaults2.paused = true, _setDefaults2.stagger = 0, _setDefaults2), vars || {})), func = function func(value, start, startIsRelative) {\n            return tween.resetTo(property, value, start, startIsRelative);\n        };\n        func.tween = tween;\n        return func;\n    },\n    isTweening: function isTweening(targets) {\n        return _globalTimeline.getTweensOf(targets, true).length > 0;\n    },\n    defaults: function defaults(value) {\n        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n        return _mergeDeep(_defaults, value || {});\n    },\n    config: function config(value) {\n        return _mergeDeep(_config, value || {});\n    },\n    registerEffect: function registerEffect(_ref3) {\n        var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults = _ref3.defaults, extendTimeline = _ref3.extendTimeline;\n        (plugins || \"\").split(\",\").forEach(function(pluginName) {\n            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n        });\n        _effects[name] = function(targets, vars, tl) {\n            return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n        };\n        if (extendTimeline) {\n            Timeline.prototype[name] = function(targets, vars, position) {\n                return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n            };\n        }\n    },\n    registerEase: function registerEase(name, ease) {\n        _easeMap[name] = _parseEase(ease);\n    },\n    parseEase: function parseEase(ease, defaultEase) {\n        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n    },\n    getById: function getById(id) {\n        return _globalTimeline.getById(id);\n    },\n    exportRoot: function exportRoot(vars, includeDelayedCalls) {\n        if (vars === void 0) {\n            vars = {};\n        }\n        var tl = new Timeline(vars), child, next;\n        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n        _globalTimeline.remove(tl);\n        tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).\n        tl._time = tl._tTime = _globalTimeline._time;\n        child = _globalTimeline._first;\n        while(child){\n            next = child._next;\n            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n                _addToTimeline(tl, child, child._start - child._delay);\n            }\n            child = next;\n        }\n        _addToTimeline(_globalTimeline, tl, 0);\n        return tl;\n    },\n    context: function context(func, scope) {\n        return func ? new Context(func, scope) : _context;\n    },\n    matchMedia: function matchMedia(scope) {\n        return new MatchMedia(scope);\n    },\n    matchMediaRefresh: function matchMediaRefresh() {\n        return _media.forEach(function(c) {\n            var cond = c.conditions, found, p;\n            for(p in cond){\n                if (cond[p]) {\n                    cond[p] = false;\n                    found = 1;\n                }\n            }\n            found && c.revert();\n        }) || _onMediaChange();\n    },\n    addEventListener: function addEventListener(type, callback) {\n        var a = _listeners[type] || (_listeners[type] = []);\n        ~a.indexOf(callback) || a.push(callback);\n    },\n    removeEventListener: function removeEventListener(type, callback) {\n        var a = _listeners[type], i = a && a.indexOf(callback);\n        i >= 0 && a.splice(i, 1);\n    },\n    utils: {\n        wrap: wrap,\n        wrapYoyo: wrapYoyo,\n        distribute: distribute,\n        random: random,\n        snap: snap,\n        normalize: normalize,\n        getUnit: getUnit,\n        clamp: clamp,\n        splitColor: splitColor,\n        toArray: toArray,\n        selector: selector,\n        mapRange: mapRange,\n        pipe: pipe,\n        unitize: unitize,\n        interpolate: interpolate,\n        shuffle: shuffle\n    },\n    install: _install,\n    effects: _effects,\n    ticker: _ticker,\n    updateRoot: Timeline.updateRoot,\n    plugins: _plugins,\n    globalTimeline: _globalTimeline,\n    core: {\n        PropTween: PropTween,\n        globals: _addGlobal,\n        Tween: Tween,\n        Timeline: Timeline,\n        Animation: Animation,\n        getCache: _getCache,\n        _removeLinkedListItem: _removeLinkedListItem,\n        reverting: function reverting() {\n            return _reverting;\n        },\n        context: function context(toAdd) {\n            if (toAdd && _context) {\n                _context.data.push(toAdd);\n                toAdd._ctx = _context;\n            }\n            return _context;\n        },\n        suppressOverwrites: function suppressOverwrites(value) {\n            return _suppressOverwrites = value;\n        }\n    }\n};\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function(name) {\n    return _gsap[name] = Tween[name];\n});\n_ticker.add(Timeline.updateRoot);\n_quickTween = _gsap.to({}, {\n    duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n    var pt = plugin._pt;\n    while(pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop){\n        pt = pt._next;\n    }\n    return pt;\n}, _addModifiers = function _addModifiers(tween, modifiers) {\n    var targets = tween._targets, p, i, pt;\n    for(p in modifiers){\n        i = targets.length;\n        while(i--){\n            pt = tween._ptLookup[i][p];\n            if (pt && (pt = pt.d)) {\n                if (pt._pt) {\n                    // is a plugin\n                    pt = _getPluginPropTween(pt, p);\n                }\n                pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n            }\n        }\n    }\n}, _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n    return {\n        name: name,\n        headless: 1,\n        rawVars: 1,\n        //don't pre-process function-based values or \"random()\" strings.\n        init: function init(target, vars, tween) {\n            tween._onInit = function(tween) {\n                var temp, p;\n                if (_isString(vars)) {\n                    temp = {};\n                    _forEachName(vars, function(name) {\n                        return temp[name] = 1;\n                    }); //if the user passes in a comma-delimited list of property names to roundProps, like \"x,y\", we round to whole numbers.\n                    vars = temp;\n                }\n                if (modifier) {\n                    temp = {};\n                    for(p in vars){\n                        temp[p] = modifier(vars[p]);\n                    }\n                    vars = temp;\n                }\n                _addModifiers(tween, vars);\n            };\n        }\n    };\n}; //register core plugins\nvar gsap = _gsap.registerPlugin({\n    name: \"attr\",\n    init: function init(target, vars, tween, index, targets) {\n        var p, pt, v;\n        this.tween = tween;\n        for(p in vars){\n            v = target.getAttribute(p) || \"\";\n            pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n            pt.op = p;\n            pt.b = v; // record the beginning value so we can revert()\n            this._props.push(p);\n        }\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt;\n        while(pt){\n            _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)\n            pt = pt._next;\n        }\n    }\n}, {\n    name: \"endArray\",\n    headless: 1,\n    init: function init(target, value) {\n        var i = value.length;\n        while(i--){\n            this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n        }\n    }\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\nTween.version = Timeline.version = gsap.version = \"3.14.2\";\n_coreReady = 1;\n_windowExists() && _wake();\nvar Power0 = _easeMap.Power0, Power1 = _easeMap.Power1, Power2 = _easeMap.Power2, Power3 = _easeMap.Power3, Power4 = _easeMap.Power4, Linear = _easeMap.Linear, Quad = _easeMap.Quad, Cubic = _easeMap.Cubic, Quart = _easeMap.Quart, Quint = _easeMap.Quint, Strong = _easeMap.Strong, Elastic = _easeMap.Elastic, Back = _easeMap.Back, SteppedEase = _easeMap.SteppedEase, Bounce = _easeMap.Bounce, Sine = _easeMap.Sine, Expo = _easeMap.Expo, Circ = _easeMap.Circ;\n\n //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\nvar _c;\n$RefreshReg$(_c, \"GSCache\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nc2FwL2dzYXAtY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSx1QkFBdUJDLElBQUk7SUFBSSxJQUFJQSxTQUFTLEtBQUssR0FBRztRQUFFLE1BQU0sSUFBSUMsZUFBZTtJQUE4RDtJQUFFLE9BQU9EO0FBQU07QUFFckssU0FBU0UsZUFBZUMsUUFBUSxFQUFFQyxVQUFVO0lBQUlELFNBQVNFLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSCxXQUFXQyxTQUFTO0lBQUdGLFNBQVNFLFNBQVMsQ0FBQ0csV0FBVyxHQUFHTDtJQUFVQSxTQUFTTSxTQUFTLEdBQUdMO0FBQVk7QUFFdEw7Ozs7Ozs7QUFPQSxHQUVBLGtCQUFrQixHQUNsQixJQUFJTSxVQUFVO0lBQ1pDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxnQkFBZ0I7SUFDaEJDLE9BQU87UUFDTEMsWUFBWTtJQUNkO0FBQ0YsR0FDSUMsWUFBWTtJQUNkQyxVQUFVO0lBQ1ZDLFdBQVc7SUFDWEMsT0FBTztBQUNULEdBQ0lDLHFCQUNBQyxZQUNBQyxVQUNBQyxVQUFVLEtBQ1ZDLFdBQVcsSUFBSUQsU0FDZkUsT0FBT0MsS0FBS0MsRUFBRSxHQUFHLEdBQ2pCQyxXQUFXSCxPQUFPLEdBQ2xCSSxRQUFRLEdBQ1JDLFFBQVFKLEtBQUtLLElBQUksRUFDakJDLE9BQU9OLEtBQUtPLEdBQUcsRUFDZkMsT0FBT1IsS0FBS1MsR0FBRyxFQUNmQyxZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0lDLGNBQWMsU0FBU0EsWUFBWUQsS0FBSztJQUMxQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUUsWUFBWSxTQUFTQSxVQUFVRixLQUFLO0lBQ3RDLE9BQU8sT0FBT0EsVUFBVTtB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S0FBSyxFQUN0QkMsUUFBUXBVLFNBQVNvVSxLQUFLLEVBQ3RCQyxRQUFRclUsU0FBU3FVLEtBQUssRUFDdEJDLFNBQVN0VSxTQUFTc1UsTUFBTSxFQUN4QkMsVUFBVXZVLFNBQVN1VSxPQUFPLEVBQzFCQyxPQUFPeFUsU0FBU3dVLElBQUksRUFDcEI3UixjQUFjM0MsU0FBUzJDLFdBQVcsRUFDbEM4UixTQUFTelUsU0FBU3lVLE1BQU0sRUFDeEJDLE9BQU8xVSxTQUFTMFUsSUFBSSxFQUNwQkMsT0FBTzNVLFNBQVMyVSxJQUFJLEVBQ3BCQyxPQUFPNVUsU0FBUzRVLElBQUk7QUFDMkg7QUFDcUgsQ0FBQywwSUFBMEk7QUFFbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvZ3NhcC1jb3JlLmpzPzcyOGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIEdTQVAgMy4xNC4yXG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2NvbmZpZyA9IHtcbiAgYXV0b1NsZWVwOiAxMjAsXG4gIGZvcmNlM0Q6IFwiYXV0b1wiLFxuICBudWxsVGFyZ2V0V2FybjogMSxcbiAgdW5pdHM6IHtcbiAgICBsaW5lSGVpZ2h0OiBcIlwiXG4gIH1cbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICBkdXJhdGlvbjogLjUsXG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIGRlbGF5OiAwXG59LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX3JldmVydGluZyxcbiAgICBfY29udGV4dCxcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG4gICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgIF9IQUxGX1BJID0gXzJQSSAvIDQsXG4gICAgX2dzSUQgPSAwLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9jb3MgPSBNYXRoLmNvcyxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgfHwgX2lzU3RyaW5nKHZhbHVlKTtcbn0sXG4gICAgX2lzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAvLyBub3RlOiBJRTEwIGhhcyBBcnJheUJ1ZmZlciwgYnV0IE5PVCBBcnJheUJ1ZmZlci5pc1ZpZXcoKS5cbl9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBfcmFuZG9tRXhwID0gL3JhbmRvbVxcKFteKV0rXFwpL2csXG4gICAgX2NvbW1hRGVsaW1FeHAgPSAvLFxccyovZyxcbiAgICBfc3RyaWN0TnVtRXhwID0gLyg/Oi0/XFwuP1xcZHxcXC4pKy9naSxcbiAgICAvL29ubHkgbnVtYmVycyAoaW5jbHVkaW5nIG5lZ2F0aXZlcyBhbmQgZGVjaW1hbHMpIGJ1dCBOT1QgcmVsYXRpdmUgdmFsdWVzLlxuX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcbiAgICAvL2ZpbmRzIGFueSBudW1iZXJzLCBpbmNsdWRpbmcgb25lcyB0aGF0IHN0YXJ0IHdpdGggKz0gb3IgLT0sIG5lZ2F0aXZlIG51bWJlcnMsIGFuZCBvbmVzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAxZS04LlxuX251bVdpdGhVbml0RXhwID0gL1stKz0uXSpcXGQrWy5lLV0qXFxkKlthLXolXSovZyxcbiAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcbiAgICAvL2R1cGxpY2F0ZSBzbyB0aGF0IHdoaWxlIHdlJ3JlIGxvb3BpbmcgdGhyb3VnaCBtYXRjaGVzIGZyb20gZXhlYygpLCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBsYXN0SW5kZXggb2YgX251bUV4cCB3aGljaCB3ZSB1c2UgdG8gc2VhcmNoIGZvciBjb2xvcnMgdG9vLlxuX3JlbEV4cCA9IC9bKy1dPS0/Wy5cXGRdKy8sXG4gICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxuICAgIC8vIHByZXZpb3VzbHkgL1sjXFwtKy5dKlxcYlthLXpcXGRcXC09KyUuXSsvZ2kgYnV0IGRpZG4ndCBjYXRjaCBzcGVjaWFsIGNoYXJhY3RlcnMuXG5fdW5pdEV4cCA9IC9eWytcXC09ZVxcc1xcZF0qXFxkK1suXFxkXSooW2Etel0qfCUpXFxzKiQvaSxcbiAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2RvYyxcbiAgICBfZ2xvYmFscyA9IHt9LFxuICAgIF9pbnN0YWxsU2NvcGUgPSB7fSxcbiAgICBfY29yZVJlYWR5LFxuICAgIF9pbnN0YWxsID0gZnVuY3Rpb24gX2luc3RhbGwoc2NvcGUpIHtcbiAgcmV0dXJuIChfaW5zdGFsbFNjb3BlID0gX21lcmdlKHNjb3BlLCBfZ2xvYmFscykpICYmIGdzYXA7XG59LFxuICAgIF9taXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gX21pc3NpbmdQbHVnaW4ocHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UsIHN1cHByZXNzKSB7XG4gIHJldHVybiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufSxcbiAgICBfYWRkR2xvYmFsID0gZnVuY3Rpb24gX2FkZEdsb2JhbChuYW1lLCBvYmopIHtcbiAgcmV0dXJuIG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiBfaW5zdGFsbFNjb3BlICYmIChfaW5zdGFsbFNjb3BlW25hbWVdID0gb2JqKSB8fCBfZ2xvYmFscztcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiAwO1xufSxcbiAgICBfc3RhcnRBdFJldmVydENvbmZpZyA9IHtcbiAgc3VwcHJlc3NFdmVudHM6IHRydWUsXG4gIGlzU3RhcnQ6IHRydWUsXG4gIGtpbGw6IGZhbHNlXG59LFxuICAgIF9yZXZlcnRDb25maWdOb0tpbGwgPSB7XG4gIHN1cHByZXNzRXZlbnRzOiB0cnVlLFxuICBraWxsOiBmYWxzZVxufSxcbiAgICBfcmV2ZXJ0Q29uZmlnID0ge1xuICBzdXBwcmVzc0V2ZW50czogdHJ1ZVxufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuICAgIF9sYXp5VHdlZW5zID0gW10sXG4gICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICBfbGFzdFJlbmRlcmVkRnJhbWUsXG4gICAgX3BsdWdpbnMgPSB7fSxcbiAgICBfZWZmZWN0cyA9IHt9LFxuICAgIF9uZXh0R0NGcmFtZSA9IDMwLFxuICAgIF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICBfaGFybmVzcyA9IGZ1bmN0aW9uIF9oYXJuZXNzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbMF0sXG4gICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgaTtcbiAgX2lzT2JqZWN0KHRhcmdldCkgfHwgX2lzRnVuY3Rpb24odGFyZ2V0KSB8fCAodGFyZ2V0cyA9IFt0YXJnZXRzXSk7XG5cbiAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggYSBoYXJuZXNzLiBXZSBhc3N1bWUgdGFyZ2V0cyBwYXNzZWQgaW50byBhbiBhbmltYXRpb24gd2lsbCBiZSBvZiBzaW1pbGFyIHR5cGUsIG1lYW5pbmcgdGhlIHNhbWUga2luZCBvZiBoYXJuZXNzIGNhbiBiZSB1c2VkIGZvciB0aGVtIGFsbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgIGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG4gIH1cblxuICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldHM7XG59LFxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwO1xufSxcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICByZXR1cm4gKHYgPSB0YXJnZXRbcHJvcGVydHldKSAmJiBfaXNGdW5jdGlvbih2KSA/IHRhcmdldFtwcm9wZXJ0eV0oKSA6IF9pc1VuZGVmaW5lZCh2KSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpIHx8IHY7XG59LFxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICByZXR1cm4gKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpIHx8IG5hbWVzO1xufSxcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMDApIC8gMTAwMDAwMDAgfHwgMDtcbn0sXG4gICAgLy8gaW5jcmVhc2VkIHByZWNpc2lvbiBtb3N0bHkgZm9yIHRpbWluZyB2YWx1ZXMuXG5fcGFyc2VSZWxhdGl2ZSA9IGZ1bmN0aW9uIF9wYXJzZVJlbGF0aXZlKHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXG4gICAgICBlbmQgPSBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cigyKSk7XG4gIHN0YXJ0ID0gcGFyc2VGbG9hdChzdGFydCk7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcbn0sXG4gICAgX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfaXNSZXZlcnRXb3J0aHkgPSBmdW5jdGlvbiBfaXNSZXZlcnRXb3J0aHkoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhIShhbmltYXRpb24uX2luaXR0ZWQgfHwgYW5pbWF0aW9uLl9zdGFydEF0IHx8IGFuaW1hdGlvbi5hZGQpO1xufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmICFfcmV2ZXJ0aW5nICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8ICEhKF9yZXZlcnRpbmcgJiYgdGltZSA8IDAgJiYgX2lzUmV2ZXJ0V29ydGh5KGFuaW1hdGlvbikpKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmICFfcmV2ZXJ0aW5nICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKGV4Y2x1ZGVEdXJhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgICBwIGluIG9iaiB8fCBwID09PSBcImR1cmF0aW9uXCIgJiYgZXhjbHVkZUR1cmF0aW9uIHx8IHAgPT09IFwiZWFzZVwiIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gICAgfVxuICB9O1xufSxcbiAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gdG9NZXJnZVtwXTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIHAgIT09IFwiX19wcm90b19fXCIgJiYgcCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIHAgIT09IFwicHJvdG90eXBlXCIgJiYgKGJhc2VbcF0gPSBfaXNPYmplY3QodG9NZXJnZVtwXSkgPyBfbWVyZ2VEZWVwKGJhc2VbcF0gfHwgKGJhc2VbcF0gPSB7fSksIHRvTWVyZ2VbcF0pIDogdG9NZXJnZVtwXSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgcCBpbiBleGNsdWRpbmcgfHwgKGNvcHlbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcbiAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgIGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzKF9pc0FycmF5KHZhcnMua2V5ZnJhbWVzKSkgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUgJiYgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gIGNoaWxkLl9hY3QgPSAwO1xufSxcbiAgICBfdW5jYWNoZSA9IGZ1bmN0aW9uIF91bmNhY2hlKGFuaW1hdGlvbiwgY2hpbGQpIHtcbiAgaWYgKGFuaW1hdGlvbiAmJiAoIWNoaWxkIHx8IGNoaWxkLl9lbmQgPiBhbmltYXRpb24uX2R1ciB8fCBjaGlsZC5fc3RhcnQgPCAwKSkge1xuICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaWYgYSBjaGlsZCBhbmltYXRpb24gaXMgcGFzc2VkIGluIHdlIHNob3VsZCBvbmx5IHVuY2FjaGUgaWYgdGhhdCBjaGlsZCBFWFRFTkRTIHRoZSBhbmltYXRpb24gKGl0cyBlbmQgdGltZSBpcyBiZXlvbmQgdGhlIGVuZClcbiAgICB2YXIgYSA9IGFuaW1hdGlvbjtcblxuICAgIHdoaWxlIChhKSB7XG4gICAgICBhLl9kaXJ0eSA9IDE7XG4gICAgICBhID0gYS5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3JlY2FjaGVBbmNlc3RvcnMgPSBmdW5jdGlvbiBfcmVjYWNoZUFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5wYXJlbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgLy9zb21ldGltZXMgd2UgbXVzdCBmb3JjZSBhIHJlLXNvcnQgb2YgYWxsIGNoaWxkcmVuIGFuZCB1cGRhdGUgdGhlIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gb2YgYWxsIGFuY2VzdG9yIHRpbWVsaW5lcyBpbW1lZGlhdGVseSBpbiBjYXNlLCBmb3IgZXhhbXBsZSwgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciBsb29wLCBvbmUgdHdlZW4gYWx0ZXJzIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgd2hpY2ggc2hvdmVzIGl0cyBzdGFydFRpbWUgYmVmb3JlIDAsIGZvcmNpbmcgdGhlIHBhcmVudCB0aW1lbGluZSB0byBzaGlmdCBhcm91bmQgYW5kIHNoaWZ0Q2hpbGRyZW4oKSB3aGljaCBjb3VsZCBhZmZlY3QgdGhhdCBuZXh0IHR3ZWVuJ3MgcmVuZGVyIChzdGFydFRpbWUpLiBEb2Vzbid0IG1hdHRlciBmb3IgdGhlIHJvb3QgdGltZWxpbmUgdGhvdWdoLlxuICAgIHBhcmVudC5fZGlydHkgPSAxO1xuICAgIHBhcmVudC50b3RhbER1cmF0aW9uKCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZXdpbmRTdGFydEF0ID0gZnVuY3Rpb24gX3Jld2luZFN0YXJ0QXQodHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHJldHVybiB0d2Vlbi5fc3RhcnRBdCAmJiAoX3JldmVydGluZyA/IHR3ZWVuLl9zdGFydEF0LnJldmVydChfcmV2ZXJ0Q29uZmlnTm9LaWxsKSA6IHR3ZWVuLnZhcnMuaW1tZWRpYXRlUmVuZGVyICYmICF0d2Vlbi52YXJzLmF1dG9SZXZlcnQgfHwgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpKTtcbn0sXG4gICAgX2hhc05vUGF1c2VkQW5jZXN0b3JzID0gZnVuY3Rpb24gX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbikge1xuICByZXR1cm4gIWFuaW1hdGlvbiB8fCBhbmltYXRpb24uX3RzICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24ucGFyZW50KTtcbn0sXG4gICAgX2VsYXBzZWRDeWNsZUR1cmF0aW9uID0gZnVuY3Rpb24gX2VsYXBzZWRDeWNsZUR1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUoYW5pbWF0aW9uLl90VGltZSwgYW5pbWF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKyBhbmltYXRpb24uX3JEZWxheSkgKiBhbmltYXRpb24gOiAwO1xufSxcbiAgICAvLyBmZWVkIGluIHRoZSB0b3RhbFRpbWUgYW5kIGN5Y2xlRHVyYXRpb24gYW5kIGl0J2xsIHJldHVybiB0aGUgY3ljbGUgKGl0ZXJhdGlvbiBtaW51cyAxKSBhbmQgaWYgdGhlIHBsYXloZWFkIGlzIGV4YWN0bHkgYXQgdGhlIHZlcnkgRU5ELCBpdCB3aWxsIE5PVCBidW1wIHVwIHRvIHRoZSBuZXh0IGN5Y2xlLlxuX2FuaW1hdGlvbkN5Y2xlID0gZnVuY3Rpb24gX2FuaW1hdGlvbkN5Y2xlKHRUaW1lLCBjeWNsZUR1cmF0aW9uKSB7XG4gIHZhciB3aG9sZSA9IE1hdGguZmxvb3IodFRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lIC8gY3ljbGVEdXJhdGlvbikpO1xuICByZXR1cm4gdFRpbWUgJiYgd2hvbGUgPT09IHRUaW1lID8gd2hvbGUgLSAxIDogd2hvbGU7XG59LFxuICAgIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lID0gZnVuY3Rpb24gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50VGltZSwgY2hpbGQpIHtcbiAgcmV0dXJuIChwYXJlbnRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyArIChjaGlsZC5fdHMgPj0gMCA/IDAgOiBjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cik7XG59LFxuICAgIF9zZXRFbmQgPSBmdW5jdGlvbiBfc2V0RW5kKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uLl9lbmQgPSBfcm91bmRQcmVjaXNlKGFuaW1hdGlvbi5fc3RhcnQgKyAoYW5pbWF0aW9uLl90RHVyIC8gTWF0aC5hYnMoYW5pbWF0aW9uLl90cyB8fCBhbmltYXRpb24uX3J0cyB8fCBfdGlueU51bSkgfHwgMCkpO1xufSxcbiAgICBfYWxpZ25QbGF5aGVhZCA9IGZ1bmN0aW9uIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgdG90YWxUaW1lKSB7XG4gIC8vIGFkanVzdHMgdGhlIGFuaW1hdGlvbidzIF9zdGFydCBhbmQgX2VuZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHRvdGFsVGltZSAob25seSBpZiB0aGUgcGFyZW50J3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSBhbmQgdGhlIGFuaW1hdGlvbiBpc24ndCBwYXVzZWQpLiBJdCBkb2Vzbid0IGRvIGFueSByZW5kZXJpbmcgb3IgZm9yY2luZyB0aGluZ3MgYmFjayBpbnRvIHBhcmVudCB0aW1lbGluZXMsIGV0Yy4gLSB0aGF0J3Mgd2hhdCB0b3RhbFRpbWUoKSBpcyBmb3IuXG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24uX2RwO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcbiAgICBhbmltYXRpb24uX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShwYXJlbnQuX3RpbWUgLSAoYW5pbWF0aW9uLl90cyA+IDAgPyB0b3RhbFRpbWUgLyBhbmltYXRpb24uX3RzIDogKChhbmltYXRpb24uX2RpcnR5ID8gYW5pbWF0aW9uLnRvdGFsRHVyYXRpb24oKSA6IGFuaW1hdGlvbi5fdER1cikgLSB0b3RhbFRpbWUpIC8gLWFuaW1hdGlvbi5fdHMpKTtcblxuICAgIF9zZXRFbmQoYW5pbWF0aW9uKTtcblxuICAgIHBhcmVudC5fZGlydHkgfHwgX3VuY2FjaGUocGFyZW50LCBhbmltYXRpb24pOyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuXG4vKlxuX3RvdGFsVGltZVRvVGltZSA9IChjbGFtcGVkVG90YWxUaW1lLCBkdXJhdGlvbiwgcmVwZWF0LCByZXBlYXREZWxheSwgeW95bykgPT4ge1xuXHRsZXQgY3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgcmVwZWF0RGVsYXksXG5cdFx0dGltZSA9IF9yb3VuZChjbGFtcGVkVG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbik7XG5cdGlmICh0aW1lID4gZHVyYXRpb24pIHtcblx0XHR0aW1lID0gZHVyYXRpb247XG5cdH1cblx0cmV0dXJuICh5b3lvICYmICh+fihjbGFtcGVkVG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgJiAxKSkgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xufSxcbiovXG5fcG9zdEFkZENoZWNrcyA9IGZ1bmN0aW9uIF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCkge1xuICB2YXIgdDtcblxuICBpZiAoY2hpbGQuX3RpbWUgfHwgIWNoaWxkLl9kdXIgJiYgY2hpbGQuX2luaXR0ZWQgfHwgY2hpbGQuX3N0YXJ0IDwgdGltZWxpbmUuX3RpbWUgJiYgKGNoaWxkLl9kdXIgfHwgIWNoaWxkLmFkZCkpIHtcbiAgICAvLyBpbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydCBpcyBtb3ZlZCBvbiBhIHR3ZWVuIHRoYXQgaGFzIGFscmVhZHkgcmVuZGVyZWQsIG9yIGlmIGl0J3MgYmVpbmcgaW5zZXJ0ZWQgaW50byBhIHRpbWVsaW5lIEJFRk9SRSB3aGVyZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5LiBJbWFnaW5lIGl0J3MgYXQgaXRzIGVuZCBzdGF0ZSwgdGhlbiB0aGUgc3RhcnRUaW1lIGlzIG1vdmVkIFdBWSBsYXRlciAoYWZ0ZXIgdGhlIGVuZCBvZiB0aGlzIHRpbWVsaW5lKSwgaXQgc2hvdWxkIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLiBTcGVjaWFsIGNhc2U6IGlmIGl0J3MgYSB0aW1lbGluZSAoaGFzIC5hZGQoKSBtZXRob2QpIGFuZCBubyBkdXJhdGlvbiwgd2UgY2FuIHNraXAgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHVzZXIgbWF5IGJlIHBvcHVsYXRpbmcgaXQgQUZURVIgYWRkaW5nIGl0IHRvIGEgcGFyZW50IHRpbWVsaW5lICh1bmNvbnZlbnRpb25hbCwgYnV0IHBvc3NpYmxlLCBhbmQgd2Ugd291bGRuJ3Qgd2FudCBpdCB0byBnZXQgcmVtb3ZlZCBpZiB0aGUgcGFyZW50J3MgYXV0b1JlbW92ZUNoaWxkcmVuIGlzIHRydWUpLlxuICAgIHQgPSBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lbGluZS5yYXdUaW1lKCksIGNoaWxkKTtcblxuICAgIGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG4gICAgICBjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXG5cbiAgaWYgKF91bmNhY2hlKHRpbWVsaW5lLCBjaGlsZCkuX2RwICYmIHRpbWVsaW5lLl9pbml0dGVkICYmIHRpbWVsaW5lLl90aW1lID49IHRpbWVsaW5lLl9kdXIgJiYgdGltZWxpbmUuX3RzKSB7XG4gICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuICAgIGlmICh0aW1lbGluZS5fZHVyIDwgdGltZWxpbmUuZHVyYXRpb24oKSkge1xuICAgICAgdCA9IHRpbWVsaW5lO1xuXG4gICAgICB3aGlsZSAodC5fZHApIHtcbiAgICAgICAgdC5yYXdUaW1lKCkgPj0gMCAmJiB0LnRvdGFsVGltZSh0Ll90VGltZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LiBJZiBpdCdzIGN1cnJlbnRseSB6ZXJvLCB0aG91Z2gsIGl0IG1heSBub3QgYmUgc2NoZWR1bGVkIHRvIHJlbmRlciB1bnRpbCBsYXRlciBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgaXQgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBwbGF5aGVhZCBwb3NpdGlvbi4gT25seSBtb3ZlIHRvIGNhdGNoIHVwIHdpdGggdGhlIHBsYXloZWFkLlxuXG4gICAgICAgIHQgPSB0Ll9kcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lbGluZS5felRpbWUgPSAtX3RpbnlOdW07IC8vIGhlbHBzIGVuc3VyZSB0aGF0IHRoZSBuZXh0IHJlbmRlcigpIHdpbGwgYmUgZm9yY2VkIChjcm9zc2luZ1N0YXJ0ID0gdHJ1ZSBpbiByZW5kZXIoKSksIGV2ZW4gaWYgdGhlIGR1cmF0aW9uIGhhc24ndCBjaGFuZ2VkICh3ZSdyZSBhZGRpbmcgYSBjaGlsZCB3aGljaCB3b3VsZCBuZWVkIHRvIGdldCByZW5kZXJlZCkuIERlZmluaXRlbHkgYW4gZWRnZSBjYXNlLiBOb3RlOiB3ZSBNVVNUIGRvIHRoaXMgQUZURVIgdGhlIGxvb3AgYWJvdmUgd2hlcmUgdGhlIHRvdGFsVGltZSgpIG1pZ2h0IHRyaWdnZXIgYSByZW5kZXIoKSBiZWNhdXNlIHRoaXMgX2FkZFRvVGltZWxpbmUoKSBtZXRob2QgZ2V0cyBjYWxsZWQgZnJvbSB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBCRUZPUkUgdHdlZW5zIGV2ZW4gcmVjb3JkIHRoZWlyIHRhcmdldHMsIGV0Yy4gc28gd2Ugd291bGRuJ3Qgd2FudCB0aGluZ3MgdG8gZ2V0IHRyaWdnZXJlZCBpbiB0aGUgd3Jvbmcgb3JkZXIuXG4gIH1cbn0sXG4gICAgX2FkZFRvVGltZWxpbmUgPSBmdW5jdGlvbiBfYWRkVG9UaW1lbGluZSh0aW1lbGluZSwgY2hpbGQsIHBvc2l0aW9uLCBza2lwQ2hlY2tzKSB7XG4gIGNoaWxkLnBhcmVudCAmJiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCk7XG4gIGNoaWxkLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoKF9pc051bWJlcihwb3NpdGlvbikgPyBwb3NpdGlvbiA6IHBvc2l0aW9uIHx8IHRpbWVsaW5lICE9PSBfZ2xvYmFsVGltZWxpbmUgPyBfcGFyc2VQb3NpdGlvbih0aW1lbGluZSwgcG9zaXRpb24sIGNoaWxkKSA6IHRpbWVsaW5lLl90aW1lKSArIGNoaWxkLl9kZWxheSk7XG4gIGNoaWxkLl9lbmQgPSBfcm91bmRQcmVjaXNlKGNoaWxkLl9zdGFydCArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBNYXRoLmFicyhjaGlsZC50aW1lU2NhbGUoKSkgfHwgMCkpO1xuXG4gIF9hZGRMaW5rZWRMaXN0SXRlbSh0aW1lbGluZSwgY2hpbGQsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGltZWxpbmUuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG5cbiAgX2lzRnJvbU9yRnJvbVN0YXJ0KGNoaWxkKSB8fCAodGltZWxpbmUuX3JlY2VudCA9IGNoaWxkKTtcbiAgc2tpcENoZWNrcyB8fCBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpO1xuICB0aW1lbGluZS5fdHMgPCAwICYmIF9hbGlnblBsYXloZWFkKHRpbWVsaW5lLCB0aW1lbGluZS5fdFRpbWUpOyAvLyBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBuZXcgY2hpbGQgbWFrZXMgaXQgbG9uZ2VyLCB3ZSBtYXkgbmVlZCB0byBhZGp1c3QgdGhlIHBhcmVudCdzIF9zdGFydCAocHVzaCBpdCBiYWNrKVxuXG4gIHJldHVybiB0aW1lbGluZTtcbn0sXG4gICAgX3Njcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2Nyb2xsVHJpZ2dlcihhbmltYXRpb24sIHRyaWdnZXIpIHtcbiAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcbn0sXG4gICAgX2F0dGVtcHRJbml0VHdlZW4gPSBmdW5jdGlvbiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzLCB0VGltZSkge1xuICBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lLCB0VGltZSk7XG5cbiAgaWYgKCF0d2Vlbi5faW5pdHRlZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKCFmb3JjZSAmJiB0d2Vlbi5fcHQgJiYgIV9yZXZlcnRpbmcgJiYgKHR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5ICE9PSBmYWxzZSB8fCAhdHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkpICYmIF9sYXN0UmVuZGVyZWRGcmFtZSAhPT0gX3RpY2tlci5mcmFtZSkge1xuICAgIF9sYXp5VHdlZW5zLnB1c2godHdlZW4pO1xuXG4gICAgdHdlZW4uX2xhenkgPSBbdFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChfcmVmKSB7XG4gIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xufSxcbiAgICAvLyBjaGVjayBwYXJlbnQncyBfbG9jayBiZWNhdXNlIHdoZW4gYSB0aW1lbGluZSByZXBlYXRzL3lveW9zIGFuZCBkb2VzIGl0cyBhcnRpZmljaWFsIHdyYXBwaW5nLCB3ZSBzaG91bGRuJ3QgZm9yY2UgdGhlIHJhdGlvIGJhY2sgdG8gMFxuX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgcmV0dXJuIGRhdGEgPT09IFwiaXNGcm9tU3RhcnRcIiB8fCBkYXRhID09PSBcImlzU3RhcnRcIjtcbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLiBFZGdlIGNhc2U6IGlmIGEgZnJvbSgpIG9yIGZyb21UbygpIHN0YWdnZXIgdHdlZW4gaXMgcGxhY2VkIGxhdGVyIGluIGEgdGltZWxpbmUsIHRoZSBcInN0YXJ0QXRcIiB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGNvdWxkIGluaXRpYWxseSByZW5kZXIgYXQgYSB0aW1lIHdoZW4gdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGlzIHRlY2huaWNhbGx5IEJFRk9SRSB3aGVyZSB0aGlzIHR3ZWVuIGlzLCBzbyBtYWtlIHN1cmUgdGhhdCBhbnkgXCJmcm9tXCIgYW5kIFwiZnJvbVRvXCIgc3RhcnRBdCB0d2VlbnMgYXJlIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lIGF0IGEgcmF0aW8gb2YgMS5cbiAgcmVwZWF0RGVsYXkgPSB0d2Vlbi5fckRlbGF5LFxuICAgICAgdFRpbWUgPSAwLFxuICAgICAgcHQsXG4gICAgICBpdGVyYXRpb24sXG4gICAgICBwcmV2SXRlcmF0aW9uO1xuXG4gIGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy8gaW4gY2FzZSB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiB0aGF0IGhhcyBhIHJlcGVhdCB3aXRoIGEgcmVwZWF0RGVsYXlcbiAgICB0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcbiAgICBpdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIHJlcGVhdERlbGF5KTtcbiAgICB0d2Vlbi5feW95byAmJiBpdGVyYXRpb24gJiAxICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG5cbiAgICBpZiAoaXRlcmF0aW9uICE9PSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSkpIHtcbiAgICAgIC8vIGlmIGl0ZXJhdGlvbiBjaGFuZ2VkXG4gICAgICBwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IF9yZXZlcnRpbmcgfHwgZm9yY2UgfHwgdHdlZW4uX3pUaW1lID09PSBfdGlueU51bSB8fCAhdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkge1xuICAgIGlmICghdHdlZW4uX2luaXR0ZWQgJiYgX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzLCB0VGltZSkpIHtcbiAgICAgIC8vIGlmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2SXRlcmF0aW9uID0gdHdlZW4uX3pUaW1lO1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApOyAvLyB3aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgIHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7IC8vIGlmIGl0IHdhcyByZW5kZXJlZCBwcmV2aW91c2x5IGF0IGV4YWN0bHkgMCAoX3pUaW1lKSBhbmQgbm93IHRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcgYXdheSwgRE9OJ1QgZmlyZSBjYWxsYmFja3Mgb3RoZXJ3aXNlIHRoZXknbGwgc2VlbSBsaWtlIGR1cGxpY2F0ZXMuXG5cbiAgICB0d2Vlbi5yYXRpbyA9IHJhdGlvO1xuICAgIHR3ZWVuLl9mcm9tICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG4gICAgdHdlZW4uX3RpbWUgPSAwO1xuICAgIHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuICAgIHB0ID0gdHdlZW4uX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgdG90YWxUaW1lIDwgMCAmJiBfcmV3aW5kU3RhcnRBdCh0d2VlbiwgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgdHJ1ZSk7XG4gICAgdHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG4gICAgdFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcblxuICAgIGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xuXG4gICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICFfcmV2ZXJ0aW5nKSB7XG4gICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZTtcbiAgfVxufSxcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XG4gIHZhciBjaGlsZDtcblxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuICAgICAgaWYgKGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlLCBsZWF2ZVBsYXloZWFkKSB7XG4gIHZhciByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcbiAgICAgIGR1ciA9IF9yb3VuZFByZWNpc2UoZHVyYXRpb24pIHx8IDAsXG4gICAgICB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cjtcbiAgdG90YWxQcm9ncmVzcyAmJiAhbGVhdmVQbGF5aGVhZCAmJiAoYW5pbWF0aW9uLl90aW1lICo9IGR1ciAvIGFuaW1hdGlvbi5fZHVyKTtcbiAgYW5pbWF0aW9uLl9kdXIgPSBkdXI7XG4gIGFuaW1hdGlvbi5fdER1ciA9ICFyZXBlYXQgPyBkdXIgOiByZXBlYXQgPCAwID8gMWUxMCA6IF9yb3VuZFByZWNpc2UoZHVyICogKHJlcGVhdCArIDEpICsgYW5pbWF0aW9uLl9yRGVsYXkgKiByZXBlYXQpO1xuICB0b3RhbFByb2dyZXNzID4gMCAmJiAhbGVhdmVQbGF5aGVhZCAmJiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIGFuaW1hdGlvbi5fdFRpbWUgPSBhbmltYXRpb24uX3REdXIgKiB0b3RhbFByb2dyZXNzKTtcbiAgYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gIHNraXBVbmNhY2hlIHx8IF91bmNhY2hlKGFuaW1hdGlvbi5wYXJlbnQsIGFuaW1hdGlvbik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xufSxcbiAgICBfemVyb1Bvc2l0aW9uID0ge1xuICBfc3RhcnQ6IDAsXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmMsXG4gIHRvdGFsRHVyYXRpb246IF9lbXB0eUZ1bmNcbn0sXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLCBwZXJjZW50QW5pbWF0aW9uKSB7XG4gIHZhciBsYWJlbHMgPSBhbmltYXRpb24ubGFiZWxzLFxuICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gIGksXG4gICAgICBvZmZzZXQsXG4gICAgICBpc1BlcmNlbnQ7XG5cbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cbiAgICBvZmZzZXQgPSBwb3NpdGlvbi5jaGFyQXQoMCk7XG4gICAgaXNQZXJjZW50ID0gcG9zaXRpb24uc3Vic3RyKC0xKSA9PT0gXCIlXCI7XG4gICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gXCI8XCIgfHwgb2Zmc2V0ID09PSBcIj5cIikge1xuICAgICAgaSA+PSAwICYmIChwb3NpdGlvbiA9IHBvc2l0aW9uLnJlcGxhY2UoLz0vLCBcIlwiKSk7XG4gICAgICByZXR1cm4gKG9mZnNldCA9PT0gXCI8XCIgPyByZWNlbnQuX3N0YXJ0IDogcmVjZW50LmVuZFRpbWUocmVjZW50Ll9yZXBlYXQgPj0gMCkpICsgKHBhcnNlRmxvYXQocG9zaXRpb24uc3Vic3RyKDEpKSB8fCAwKSAqIChpc1BlcmNlbnQgPyAoaSA8IDAgPyByZWNlbnQgOiBwZXJjZW50QW5pbWF0aW9uKS50b3RhbER1cmF0aW9uKCkgLyAxMDAgOiAxKTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHBvc2l0aW9uIGluIGxhYmVscyB8fCAobGFiZWxzW3Bvc2l0aW9uXSA9IGNsaXBwZWREdXJhdGlvbik7XG4gICAgICByZXR1cm4gbGFiZWxzW3Bvc2l0aW9uXTtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KHBvc2l0aW9uLmNoYXJBdChpIC0gMSkgKyBwb3NpdGlvbi5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChpc1BlcmNlbnQgJiYgcGVyY2VudEFuaW1hdGlvbikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IC8gMTAwICogKF9pc0FycmF5KHBlcmNlbnRBbmltYXRpb24pID8gcGVyY2VudEFuaW1hdGlvblswXSA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaSA+IDEgPyBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLnN1YnN0cigwLCBpIC0gMSksIHBlcmNlbnRBbmltYXRpb24pICsgb2Zmc2V0IDogY2xpcHBlZER1cmF0aW9uICsgb2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uID09IG51bGwgPyBjbGlwcGVkRHVyYXRpb24gOiArcG9zaXRpb247XG59LFxuICAgIF9jcmVhdGVUd2VlblR5cGUgPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW5UeXBlKHR5cGUsIHBhcmFtcywgdGltZWxpbmUpIHtcbiAgdmFyIGlzTGVnYWN5ID0gX2lzTnVtYmVyKHBhcmFtc1sxXSksXG4gICAgICB2YXJzSW5kZXggPSAoaXNMZWdhY3kgPyAyIDogMSkgKyAodHlwZSA8IDIgPyAwIDogMSksXG4gICAgICB2YXJzID0gcGFyYW1zW3ZhcnNJbmRleF0sXG4gICAgICBpclZhcnMsXG4gICAgICBwYXJlbnQ7XG5cbiAgaXNMZWdhY3kgJiYgKHZhcnMuZHVyYXRpb24gPSBwYXJhbXNbMV0pO1xuICB2YXJzLnBhcmVudCA9IHRpbWVsaW5lO1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaXJWYXJzID0gdmFycztcbiAgICBwYXJlbnQgPSB0aW1lbGluZTtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgIShcImltbWVkaWF0ZVJlbmRlclwiIGluIGlyVmFycykpIHtcbiAgICAgIC8vIGluaGVyaXRhbmNlIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGJ1dCBzb21lb25lIG1heSBoYXZlIHNldCBhIGRlZmF1bHQgaW4gYW4gYW5jZXN0b3IgdGltZWxpbmUuIFdlIGNvdWxkIGRvIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIpIGJ1dCB0aGF0J2QgZXhhY3QgYSBzbGlnaHQgcGVyZm9ybWFuY2UgcGVuYWx0eSBiZWNhdXNlIF9pbmhlcml0RGVmYXVsdHMoKSBhbHNvIHJ1bnMgaW4gdGhlIFR3ZWVuIGNvbnN0cnVjdG9yLiBXZSdyZSBwYXlpbmcgYSBzbWFsbCBrYiBwcmljZSBoZXJlIHRvIGdhaW4gc3BlZWQuXG4gICAgICBpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcbiAgICAgIHBhcmVudCA9IF9pc05vdEZhbHNlKHBhcmVudC52YXJzLmluaGVyaXQpICYmIHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShpclZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICB0eXBlIDwgMiA/IHZhcnMucnVuQmFja3dhcmRzID0gMSA6IHZhcnMuc3RhcnRBdCA9IHBhcmFtc1t2YXJzSW5kZXggLSAxXTsgLy8gXCJmcm9tXCIgdmFyc1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUd2VlbihwYXJhbXNbMF0sIHZhcnMsIHBhcmFtc1t2YXJzSW5kZXggKyAxXSk7XG59LFxuICAgIF9jb25kaXRpb25hbFJldHVybiA9IGZ1bmN0aW9uIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuYykge1xuICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBmdW5jKHZhbHVlKSA6IGZ1bmM7XG59LFxuICAgIF9jbGFtcCA9IGZ1bmN0aW9uIF9jbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbn0sXG4gICAgZ2V0VW5pdCA9IGZ1bmN0aW9uIGdldFVuaXQodmFsdWUsIHYpIHtcbiAgcmV0dXJuICFfaXNTdHJpbmcodmFsdWUpIHx8ICEodiA9IF91bml0RXhwLmV4ZWModmFsdWUpKSA/IFwiXCIgOiB2WzFdO1xufSxcbiAgICAvLyBub3RlOiBwcm90ZWN0IGFnYWluc3QgcGFkZGVkIG51bWJlcnMgYXMgc3RyaW5ncywgbGlrZSBcIjEwMC4xMDBcIi4gVGhhdCBzaG91bGRuJ3QgcmV0dXJuIFwiMDBcIiBhcyB0aGUgdW5pdC4gSWYgaXQncyBudW1lcmljLCByZXR1cm4gbm8gdW5pdC5cbmNsYW1wID0gZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIF9jbGFtcChtaW4sIG1heCwgdik7XG4gIH0pO1xufSxcbiAgICBfc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBfaXNBcnJheUxpa2UodmFsdWUsIG5vbkVtcHR5KSB7XG4gIHJldHVybiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWUpICYmIFwibGVuZ3RoXCIgaW4gdmFsdWUgJiYgKCFub25FbXB0eSAmJiAhdmFsdWUubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCAtIDEgaW4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlWzBdKSkgJiYgIXZhbHVlLm5vZGVUeXBlICYmIHZhbHVlICE9PSBfd2luO1xufSxcbiAgICBfZmxhdHRlbiA9IGZ1bmN0aW9uIF9mbGF0dGVuKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yKSB7XG4gIGlmIChhY2N1bXVsYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfYWNjdW11bGF0b3I7XG5cbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzIHx8IF9pc0FycmF5TGlrZSh2YWx1ZSwgMSkgPyAoX2FjY3VtdWxhdG9yID0gYWNjdW11bGF0b3IpLnB1c2guYXBwbHkoX2FjY3VtdWxhdG9yLCB0b0FycmF5KHZhbHVlKSkgOiBhY2N1bXVsYXRvci5wdXNoKHZhbHVlKTtcbiAgfSkgfHwgYWNjdW11bGF0b3I7XG59LFxuICAgIC8vIHRha2VzIGFueSB2YWx1ZSBhbmQgcmV0dXJucyBhbiBBcnJheS4gSWYgaXQncyBhIHN0cmluZyAoYW5kIGxlYXZlU3RyaW5ncyBpc24ndCB0cnVlKSwgaXQnbGwgdXNlIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKSBhbmQgY29udmVydCB0aGF0IHRvIGFuIGFycmF5LiBJdCdsbCBhbHNvIGFjY2VwdCBpdGVyYWJsZXMgbGlrZSBqUXVlcnkgb2JqZWN0cy5cbnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KHZhbHVlLCBzY29wZSwgbGVhdmVTdHJpbmdzKSB7XG4gIHJldHVybiBfY29udGV4dCAmJiAhc2NvcGUgJiYgX2NvbnRleHQuc2VsZWN0b3IgPyBfY29udGV4dC5zZWxlY3Rvcih2YWx1ZSkgOiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgJiYgKF9jb3JlSW5pdHRlZCB8fCAhX3dha2UoKSkgPyBfc2xpY2UuY2FsbCgoc2NvcGUgfHwgX2RvYykucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSksIDApIDogX2lzQXJyYXkodmFsdWUpID8gX2ZsYXR0ZW4odmFsdWUsIGxlYXZlU3RyaW5ncykgOiBfaXNBcnJheUxpa2UodmFsdWUpID8gX3NsaWNlLmNhbGwodmFsdWUsIDApIDogdmFsdWUgPyBbdmFsdWVdIDogW107XG59LFxuICAgIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3IodmFsdWUpIHtcbiAgdmFsdWUgPSB0b0FycmF5KHZhbHVlKVswXSB8fCBfd2FybihcIkludmFsaWQgc2NvcGVcIikgfHwge307XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIHZhciBlbCA9IHZhbHVlLmN1cnJlbnQgfHwgdmFsdWUubmF0aXZlRWxlbWVudCB8fCB2YWx1ZTtcbiAgICByZXR1cm4gdG9BcnJheSh2LCBlbC5xdWVyeVNlbGVjdG9yQWxsID8gZWwgOiBlbCA9PT0gdmFsdWUgPyBfd2FybihcIkludmFsaWQgc2NvcGVcIikgfHwgX2RvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpIDogdmFsdWUpO1xuICB9O1xufSxcbiAgICBzaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZShhKSB7XG4gIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAuNSAtIE1hdGgucmFuZG9tKCk7XG4gIH0pO1xufSxcbiAgICAvLyBhbHRlcm5hdGl2ZSB0aGF0J3MgYSBiaXQgZmFzdGVyIGFuZCBtb3JlIHJlbGlhYmx5IGRpdmVyc2UgYnV0IGJpZ2dlcjogICBmb3IgKGxldCBqLCB2LCBpID0gYS5sZW5ndGg7IGk7IGogPSAoTWF0aC5yYW5kb20oKSAqIGkpIHwgMCwgdiA9IGFbLS1pXSwgYVtpXSA9IGFbal0sIGFbal0gPSB2KTsgcmV0dXJuIGE7XG4vLyBmb3IgZGlzdHJpYnV0aW5nIHZhbHVlcyBhY3Jvc3MgYW4gQXJyYXkuIENhbiBhY2NlcHQgYSBudW1iZXIsIGEgZnVuY3Rpb24gb3IgKG1vc3QgY29tbW9ubHkpIGFuIG9iamVjdCB3aGljaCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHtiYXNlLCBhbW91bnQsIGZyb20sIGVhc2UsIGdyaWQsIGF4aXMsIGxlbmd0aCwgZWFjaH0uIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOiBpbmRleCwgdGFyZ2V0LCBhcnJheS5cbmRpc3RyaWJ1dGUgPSBmdW5jdGlvbiBkaXN0cmlidXRlKHYpIHtcbiAgaWYgKF9pc0Z1bmN0aW9uKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICB2YXIgdmFycyA9IF9pc09iamVjdCh2KSA/IHYgOiB7XG4gICAgZWFjaDogdlxuICB9LFxuICAgICAgLy9uOjEgaXMganVzdCB0byBpbmRpY2F0ZSB2IHdhcyBhIG51bWJlcjsgd2UgbGV2ZXJhZ2UgdGhhdCBsYXRlciB0byBzZXQgdiBhY2NvcmRpbmcgdG8gdGhlIGxlbmd0aCB3ZSBnZXQuIElmIGEgbnVtYmVyIGlzIHBhc3NlZCBpbiwgd2UgdHJlYXQgaXQgbGlrZSB0aGUgb2xkIHN0YWdnZXIgdmFsdWUgd2hlcmUgMC4xLCBmb3IgZXhhbXBsZSwgd291bGQgbWVhbiB0aGF0IHRoaW5ncyB3b3VsZCBiZSBkaXN0cmlidXRlZCB3aXRoIDAuMSBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgcmF0aGVyIHRoYW4gYSB0b3RhbCBcImFtb3VudFwiIHRoYXQncyBjaHVua2VkIG91dCBhbW9uZyB0aGVtIGFsbC5cbiAgZWFzZSA9IF9wYXJzZUVhc2UodmFycy5lYXNlKSxcbiAgICAgIGZyb20gPSB2YXJzLmZyb20gfHwgMCxcbiAgICAgIGJhc2UgPSBwYXJzZUZsb2F0KHZhcnMuYmFzZSkgfHwgMCxcbiAgICAgIGNhY2hlID0ge30sXG4gICAgICBpc0RlY2ltYWwgPSBmcm9tID4gMCAmJiBmcm9tIDwgMSxcbiAgICAgIHJhdGlvcyA9IGlzTmFOKGZyb20pIHx8IGlzRGVjaW1hbCxcbiAgICAgIGF4aXMgPSB2YXJzLmF4aXMsXG4gICAgICByYXRpb1ggPSBmcm9tLFxuICAgICAgcmF0aW9ZID0gZnJvbTtcblxuICBpZiAoX2lzU3RyaW5nKGZyb20pKSB7XG4gICAgcmF0aW9YID0gcmF0aW9ZID0ge1xuICAgICAgY2VudGVyOiAuNSxcbiAgICAgIGVkZ2VzOiAuNSxcbiAgICAgIGVuZDogMVxuICAgIH1bZnJvbV0gfHwgMDtcbiAgfSBlbHNlIGlmICghaXNEZWNpbWFsICYmIHJhdGlvcykge1xuICAgIHJhdGlvWCA9IGZyb21bMF07XG4gICAgcmF0aW9ZID0gZnJvbVsxXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaSwgdGFyZ2V0LCBhKSB7XG4gICAgdmFyIGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdLFxuICAgICAgICBvcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBkLFxuICAgICAgICBqLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgd3JhcEF0O1xuXG4gICAgaWYgKCFkaXN0YW5jZXMpIHtcbiAgICAgIHdyYXBBdCA9IHZhcnMuZ3JpZCA9PT0gXCJhdXRvXCIgPyAwIDogKHZhcnMuZ3JpZCB8fCBbMSwgX2JpZ051bV0pWzFdO1xuXG4gICAgICBpZiAoIXdyYXBBdCkge1xuICAgICAgICBtYXggPSAtX2JpZ051bTtcblxuICAgICAgICB3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHt9XG5cbiAgICAgICAgd3JhcEF0IDwgbCAmJiB3cmFwQXQtLTtcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0gPSBbXTtcbiAgICAgIG9yaWdpblggPSByYXRpb3MgPyBNYXRoLm1pbih3cmFwQXQsIGwpICogcmF0aW9YIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xuICAgICAgb3JpZ2luWSA9IHdyYXBBdCA9PT0gX2JpZ051bSA/IDAgOiByYXRpb3MgPyBsICogcmF0aW9ZIC8gd3JhcEF0IC0gLjUgOiBmcm9tIC8gd3JhcEF0IHwgMDtcbiAgICAgIG1heCA9IDA7XG4gICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIHggPSBqICUgd3JhcEF0IC0gb3JpZ2luWDtcbiAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICBkaXN0YW5jZXNbal0gPSBkID0gIWF4aXMgPyBfc3FydCh4ICogeCArIHkgKiB5KSA6IE1hdGguYWJzKGF4aXMgPT09IFwieVwiID8geSA6IHgpO1xuICAgICAgICBkID4gbWF4ICYmIChtYXggPSBkKTtcbiAgICAgICAgZCA8IG1pbiAmJiAobWluID0gZCk7XG4gICAgICB9XG5cbiAgICAgIGZyb20gPT09IFwicmFuZG9tXCIgJiYgc2h1ZmZsZShkaXN0YW5jZXMpO1xuICAgICAgZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcbiAgICAgIGRpc3RhbmNlcy5taW4gPSBtaW47XG4gICAgICBkaXN0YW5jZXMudiA9IGwgPSAocGFyc2VGbG9hdCh2YXJzLmFtb3VudCkgfHwgcGFyc2VGbG9hdCh2YXJzLmVhY2gpICogKHdyYXBBdCA+IGwgPyBsIC0gMSA6ICFheGlzID8gTWF0aC5tYXgod3JhcEF0LCBsIC8gd3JhcEF0KSA6IGF4aXMgPT09IFwieVwiID8gbCAvIHdyYXBBdCA6IHdyYXBBdCkgfHwgMCkgKiAoZnJvbSA9PT0gXCJlZGdlc1wiID8gLTEgOiAxKTtcbiAgICAgIGRpc3RhbmNlcy5iID0gbCA8IDAgPyBiYXNlIC0gbCA6IGJhc2U7XG4gICAgICBkaXN0YW5jZXMudSA9IGdldFVuaXQodmFycy5hbW91bnQgfHwgdmFycy5lYWNoKSB8fCAwOyAvL3VuaXRcblxuICAgICAgZWFzZSA9IGVhc2UgJiYgbCA8IDAgPyBfaW52ZXJ0RWFzZShlYXNlKSA6IGVhc2U7XG4gICAgfVxuXG4gICAgbCA9IChkaXN0YW5jZXNbaV0gLSBkaXN0YW5jZXMubWluKSAvIGRpc3RhbmNlcy5tYXggfHwgMDtcbiAgICByZXR1cm4gX3JvdW5kUHJlY2lzZShkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gTWF0aC5wb3coMTAsICgodiArIFwiXCIpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGgpOyAvL3RvIGF2b2lkIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChsaWtlIDI0ICogMC4xID09IDIuNDAwMDAwMDAwMDAwMDAwNCksIHdlIGNob3Agb2ZmIGF0IGEgc3BlY2lmaWMgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIChtdWNoIGZhc3RlciB0aGFuIHRvRml4ZWQoKSlcblxuICByZXR1cm4gZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciBuID0gX3JvdW5kUHJlY2lzZShNYXRoLnJvdW5kKHBhcnNlRmxvYXQocmF3KSAvIHYpICogdiAqIHApO1xuXG4gICAgcmV0dXJuIChuIC0gbiAlIDEpIC8gcCArIChfaXNOdW1iZXIocmF3KSA/IDAgOiBnZXRVbml0KHJhdykpOyAvLyBuIC0gbiAlIDEgcmVwbGFjZXMgTWF0aC5mbG9vcigpIGluIG9yZGVyIHRvIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZXMgcHJvcGVybHkuIEZvciBleGFtcGxlLCBNYXRoLmZsb29yKC0xNTAuMDAwMDAwMDAwMDAwMDMpIGlzIDE1MSFcbiAgfTtcbn0sXG4gICAgc25hcCA9IGZ1bmN0aW9uIHNuYXAoc25hcFRvLCB2YWx1ZSkge1xuICB2YXIgaXNBcnJheSA9IF9pc0FycmF5KHNuYXBUbyksXG4gICAgICByYWRpdXMsXG4gICAgICBpczJEO1xuXG4gIGlmICghaXNBcnJheSAmJiBfaXNPYmplY3Qoc25hcFRvKSkge1xuICAgIHJhZGl1cyA9IGlzQXJyYXkgPSBzbmFwVG8ucmFkaXVzIHx8IF9iaWdOdW07XG5cbiAgICBpZiAoc25hcFRvLnZhbHVlcykge1xuICAgICAgc25hcFRvID0gdG9BcnJheShzbmFwVG8udmFsdWVzKTtcblxuICAgICAgaWYgKGlzMkQgPSAhX2lzTnVtYmVyKHNuYXBUb1swXSkpIHtcbiAgICAgICAgcmFkaXVzICo9IHJhZGl1czsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gd2UgZG9uJ3QgaGF2ZSB0byBNYXRoLnNxcnQoKSBpbiB0aGUgbG9vcC5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc25hcFRvID0gX3JvdW5kTW9kaWZpZXIoc25hcFRvLmluY3JlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgIWlzQXJyYXkgPyBfcm91bmRNb2RpZmllcihzbmFwVG8pIDogX2lzRnVuY3Rpb24oc25hcFRvKSA/IGZ1bmN0aW9uIChyYXcpIHtcbiAgICBpczJEID0gc25hcFRvKHJhdyk7XG4gICAgcmV0dXJuIE1hdGguYWJzKGlzMkQgLSByYXcpIDw9IHJhZGl1cyA/IGlzMkQgOiByYXc7XG4gIH0gOiBmdW5jdGlvbiAocmF3KSB7XG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueCA6IHJhdyksXG4gICAgICAgIHkgPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueSA6IDApLFxuICAgICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgaSA9IHNuYXBUby5sZW5ndGgsXG4gICAgICAgIGR4LFxuICAgICAgICBkeTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChpczJEKSB7XG4gICAgICAgIGR4ID0gc25hcFRvW2ldLnggLSB4O1xuICAgICAgICBkeSA9IHNuYXBUb1tpXS55IC0geTtcbiAgICAgICAgZHggPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMoc25hcFRvW2ldIC0geCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkeCA8IG1pbikge1xuICAgICAgICBtaW4gPSBkeDtcbiAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VzdCA9ICFyYWRpdXMgfHwgbWluIDw9IHJhZGl1cyA/IHNuYXBUb1tjbG9zZXN0XSA6IHJhdztcbiAgICByZXR1cm4gaXMyRCB8fCBjbG9zZXN0ID09PSByYXcgfHwgX2lzTnVtYmVyKHJhdykgPyBjbG9zZXN0IDogY2xvc2VzdCArIGdldFVuaXQocmF3KTtcbiAgfSk7XG59LFxuICAgIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgcm91bmRpbmdJbmNyZW1lbnQsIHJldHVybkZ1bmN0aW9uKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4oX2lzQXJyYXkobWluKSA/ICFtYXggOiByb3VuZGluZ0luY3JlbWVudCA9PT0gdHJ1ZSA/ICEhKHJvdW5kaW5nSW5jcmVtZW50ID0gMCkgOiAhcmV0dXJuRnVuY3Rpb24sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQXJyYXkobWluKSA/IG1pblt+fihNYXRoLnJhbmRvbSgpICogbWluLmxlbmd0aCldIDogKHJvdW5kaW5nSW5jcmVtZW50ID0gcm91bmRpbmdJbmNyZW1lbnQgfHwgMWUtNSkgJiYgKHJldHVybkZ1bmN0aW9uID0gcm91bmRpbmdJbmNyZW1lbnQgPCAxID8gTWF0aC5wb3coMTAsIChyb3VuZGluZ0luY3JlbWVudCArIFwiXCIpLmxlbmd0aCAtIDIpIDogMSkgJiYgTWF0aC5mbG9vcihNYXRoLnJvdW5kKChtaW4gLSByb3VuZGluZ0luY3JlbWVudCAvIDIgKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIHJvdW5kaW5nSW5jcmVtZW50ICogLjk5KSkgLyByb3VuZGluZ0luY3JlbWVudCkgKiByb3VuZGluZ0luY3JlbWVudCAqIHJldHVybkZ1bmN0aW9uKSAvIHJldHVybkZ1bmN0aW9uO1xuICB9KTtcbn0sXG4gICAgcGlwZSA9IGZ1bmN0aW9uIHBpcGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3Rpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbnMucmVkdWNlKGZ1bmN0aW9uICh2LCBmKSB7XG4gICAgICByZXR1cm4gZih2KTtcbiAgICB9LCB2YWx1ZSk7XG4gIH07XG59LFxuICAgIHVuaXRpemUgPSBmdW5jdGlvbiB1bml0aXplKGZ1bmMsIHVuaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHBhcnNlRmxvYXQodmFsdWUpKSArICh1bml0IHx8IGdldFVuaXQodmFsdWUpKTtcbiAgfTtcbn0sXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gbWFwUmFuZ2UobWluLCBtYXgsIDAsIDEsIHZhbHVlKTtcbn0sXG4gICAgX3dyYXBBcnJheSA9IGZ1bmN0aW9uIF93cmFwQXJyYXkoYSwgd3JhcHBlciwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIGFbfn53cmFwcGVyKGluZGV4KV07XG4gIH0pO1xufSxcbiAgICB3cmFwID0gZnVuY3Rpb24gd3JhcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgLy8gTk9URTogd3JhcCgpIENBTk5PVCBiZSBhbiBhcnJvdyBmdW5jdGlvbiEgQSB2ZXJ5IG9kZCBjb21waWxpbmcgYnVnIGNhdXNlcyBwcm9ibGVtcyAodW5yZWxhdGVkIHRvIEdTQVApLlxuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG4gIHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXAoMCwgbWluLmxlbmd0aCksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAocmFuZ2UgKyAodmFsdWUgLSBtaW4pICUgcmFuZ2UpICUgcmFuZ2UgKyBtaW47XG4gIH0pO1xufSxcbiAgICB3cmFwWW95byA9IGZ1bmN0aW9uIHdyYXBZb3lvKG1pbiwgbWF4LCB2YWx1ZSkge1xuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW4sXG4gICAgICB0b3RhbCA9IHJhbmdlICogMjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcFlveW8oMCwgbWluLmxlbmd0aCAtIDEpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9ICh0b3RhbCArICh2YWx1ZSAtIG1pbikgJSB0b3RhbCkgJSB0b3RhbCB8fCAwO1xuICAgIHJldHVybiBtaW4gKyAodmFsdWUgPiByYW5nZSA/IHRvdGFsIC0gdmFsdWUgOiB2YWx1ZSk7XG4gIH0pO1xufSxcbiAgICBfcmVwbGFjZVJhbmRvbSA9IGZ1bmN0aW9uIF9yZXBsYWNlUmFuZG9tKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShfcmFuZG9tRXhwLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAvL3JlcGxhY2VzIGFsbCBvY2N1cnJlbmNlcyBvZiByYW5kb20oLi4uKSBpbiBhIHN0cmluZyB3aXRoIHRoZSBjYWxjdWxhdGVkIHJhbmRvbSB2YWx1ZS4gY2FuIGJlIGEgcmFuZ2UgbGlrZSByYW5kb20oLTEwMCwgMTAwLCA1KSBvciBhbiBhcnJheSBsaWtlIHJhbmRvbShbMCwgMTAwLCA1MDBdKVxuICAgIHZhciBhckluZGV4ID0gbWF0Y2guaW5kZXhPZihcIltcIikgKyAxLFxuICAgICAgICB2YWx1ZXMgPSBtYXRjaC5zdWJzdHJpbmcoYXJJbmRleCB8fCA3LCBhckluZGV4ID8gbWF0Y2guaW5kZXhPZihcIl1cIikgOiBtYXRjaC5sZW5ndGggLSAxKS5zcGxpdChfY29tbWFEZWxpbUV4cCk7XG4gICAgcmV0dXJuIHJhbmRvbShhckluZGV4ID8gdmFsdWVzIDogK3ZhbHVlc1swXSwgYXJJbmRleCA/IDAgOiArdmFsdWVzWzFdLCArdmFsdWVzWzJdIHx8IDFlLTUpO1xuICB9KTtcbn0sXG4gICAgbWFwUmFuZ2UgPSBmdW5jdGlvbiBtYXBSYW5nZShpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4LCB2YWx1ZSkge1xuICB2YXIgaW5SYW5nZSA9IGluTWF4IC0gaW5NaW4sXG4gICAgICBvdXRSYW5nZSA9IG91dE1heCAtIG91dE1pbjtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG91dE1pbiArICgodmFsdWUgLSBpbk1pbikgLyBpblJhbmdlICogb3V0UmFuZ2UgfHwgMCk7XG4gIH0pO1xufSxcbiAgICBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCBlbmQsIHByb2dyZXNzLCBtdXRhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc05hTihzdGFydCArIGVuZCkgPyAwIDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gKDEgLSBwKSAqIHN0YXJ0ICsgcCAqIGVuZDtcbiAgfTtcblxuICBpZiAoIWZ1bmMpIHtcbiAgICB2YXIgaXNTdHJpbmcgPSBfaXNTdHJpbmcoc3RhcnQpLFxuICAgICAgICBtYXN0ZXIgPSB7fSxcbiAgICAgICAgcCxcbiAgICAgICAgaSxcbiAgICAgICAgaW50ZXJwb2xhdG9ycyxcbiAgICAgICAgbCxcbiAgICAgICAgaWw7XG5cbiAgICBwcm9ncmVzcyA9PT0gdHJ1ZSAmJiAobXV0YXRlID0gMSkgJiYgKHByb2dyZXNzID0gbnVsbCk7XG5cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHN0YXJ0ID0ge1xuICAgICAgICBwOiBzdGFydFxuICAgICAgfTtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgcDogZW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2lzQXJyYXkoc3RhcnQpICYmICFfaXNBcnJheShlbmQpKSB7XG4gICAgICBpbnRlcnBvbGF0b3JzID0gW107XG4gICAgICBsID0gc3RhcnQubGVuZ3RoO1xuICAgICAgaWwgPSBsIC0gMjtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnRlcnBvbGF0b3JzLnB1c2goaW50ZXJwb2xhdGUoc3RhcnRbaSAtIDFdLCBzdGFydFtpXSkpOyAvL2J1aWxkIHRoZSBpbnRlcnBvbGF0b3JzIHVwIGZyb250IGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG1hbnkgdGltZXMsIGl0IGNhbiBqdXN0IHJldXNlIHRoZW0uXG4gICAgICB9XG5cbiAgICAgIGwtLTtcblxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xuICAgICAgICBwICo9IGw7XG4gICAgICAgIHZhciBpID0gTWF0aC5taW4oaWwsIH5+cCk7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0b3JzW2ldKHAgLSBpKTtcbiAgICAgIH07XG5cbiAgICAgIHByb2dyZXNzID0gZW5kO1xuICAgIH0gZWxzZSBpZiAoIW11dGF0ZSkge1xuICAgICAgc3RhcnQgPSBfbWVyZ2UoX2lzQXJyYXkoc3RhcnQpID8gW10gOiB7fSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghaW50ZXJwb2xhdG9ycykge1xuICAgICAgZm9yIChwIGluIGVuZCkge1xuICAgICAgICBfYWRkUHJvcFR3ZWVuLmNhbGwobWFzdGVyLCBzdGFydCwgcCwgXCJnZXRcIiwgZW5kW3BdKTtcbiAgICAgIH1cblxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xuICAgICAgICByZXR1cm4gX3JlbmRlclByb3BUd2VlbnMocCwgbWFzdGVyKSB8fCAoaXNTdHJpbmcgPyBzdGFydC5wIDogc3RhcnQpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHByb2dyZXNzLCBmdW5jKTtcbn0sXG4gICAgX2dldExhYmVsSW5EaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aW1lbGluZSwgZnJvbVRpbWUsIGJhY2t3YXJkKSB7XG4gIC8vdXNlZCBmb3IgbmV4dExhYmVsKCkgYW5kIHByZXZpb3VzTGFiZWwoKVxuICB2YXIgbGFiZWxzID0gdGltZWxpbmUubGFiZWxzLFxuICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgIHAsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGxhYmVsO1xuXG4gIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICBkaXN0YW5jZSA9IGxhYmVsc1twXSAtIGZyb21UaW1lO1xuXG4gICAgaWYgKGRpc3RhbmNlIDwgMCA9PT0gISFiYWNrd2FyZCAmJiBkaXN0YW5jZSAmJiBtaW4gPiAoZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSkpKSB7XG4gICAgICBsYWJlbCA9IHA7XG4gICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWw7XG59LFxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhhbmltYXRpb24sIHR5cGUsIGV4ZWN1dGVMYXp5Rmlyc3QpIHtcbiAgdmFyIHYgPSBhbmltYXRpb24udmFycyxcbiAgICAgIGNhbGxiYWNrID0gdlt0eXBlXSxcbiAgICAgIHByZXZDb250ZXh0ID0gX2NvbnRleHQsXG4gICAgICBjb250ZXh0ID0gYW5pbWF0aW9uLl9jdHgsXG4gICAgICBwYXJhbXMsXG4gICAgICBzY29wZSxcbiAgICAgIHJlc3VsdDtcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcGFyYW1zID0gdlt0eXBlICsgXCJQYXJhbXNcIl07XG4gIHNjb3BlID0gdi5jYWxsYmFja1Njb3BlIHx8IGFuaW1hdGlvbjtcbiAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cbiAgY29udGV4dCAmJiAoX2NvbnRleHQgPSBjb250ZXh0KTtcbiAgcmVzdWx0ID0gcGFyYW1zID8gY2FsbGJhY2suYXBwbHkoc2NvcGUsIHBhcmFtcykgOiBjYWxsYmFjay5jYWxsKHNjb3BlKTtcbiAgX2NvbnRleHQgPSBwcmV2Q29udGV4dDtcbiAgcmV0dXJuIHJlc3VsdDtcbn0sXG4gICAgX2ludGVycnVwdCA9IGZ1bmN0aW9uIF9pbnRlcnJ1cHQoYW5pbWF0aW9uKSB7XG4gIF9yZW1vdmVGcm9tUGFyZW50KGFuaW1hdGlvbik7XG5cbiAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgJiYgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIua2lsbCghIV9yZXZlcnRpbmcpO1xuICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3F1aWNrVHdlZW4sXG4gICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUgPSBbXSxcbiAgICBfY3JlYXRlUGx1Z2luID0gZnVuY3Rpb24gX2NyZWF0ZVBsdWdpbihjb25maWcpIHtcbiAgaWYgKCFjb25maWcpIHJldHVybjtcbiAgY29uZmlnID0gIWNvbmZpZy5uYW1lICYmIGNvbmZpZ1tcImRlZmF1bHRcIl0gfHwgY29uZmlnOyAvLyBVTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cbiAgaWYgKF93aW5kb3dFeGlzdHMoKSB8fCBjb25maWcuaGVhZGxlc3MpIHtcbiAgICAvLyBlZGdlIGNhc2U6IHNvbWUgYnVpbGQgdG9vbHMgbWF5IHBhc3MgaW4gYSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuICAgIHZhciBuYW1lID0gY29uZmlnLm5hbWUsXG4gICAgICAgIGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG4gICAgICAgIFBsdWdpbiA9IG5hbWUgJiYgIWlzRnVuYyAmJiBjb25maWcuaW5pdCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Byb3BzID0gW107XG4gICAgfSA6IGNvbmZpZyxcbiAgICAgICAgLy9pbiBjYXNlIHNvbWVvbmUgcGFzc2VzIGluIGFuIG9iamVjdCB0aGF0J3Mgbm90IGEgcGx1Z2luLCBsaWtlIEN1c3RvbUVhc2VcbiAgICBpbnN0YW5jZURlZmF1bHRzID0ge1xuICAgICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICAgIHJlbmRlcjogX3JlbmRlclByb3BUd2VlbnMsXG4gICAgICBhZGQ6IF9hZGRQcm9wVHdlZW4sXG4gICAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICAgIG1vZGlmaWVyOiBfYWRkUGx1Z2luTW9kaWZpZXIsXG4gICAgICByYXdWYXJzOiAwXG4gICAgfSxcbiAgICAgICAgc3RhdGljcyA9IHtcbiAgICAgIHRhcmdldFRlc3Q6IDAsXG4gICAgICBnZXQ6IDAsXG4gICAgICBnZXRTZXR0ZXI6IF9nZXRTZXR0ZXIsXG4gICAgICBhbGlhc2VzOiB7fSxcbiAgICAgIHJlZ2lzdGVyOiAwXG4gICAgfTtcblxuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICAgIGlmIChfcGx1Z2luc1tuYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9zZXREZWZhdWx0cyhQbHVnaW4sIF9zZXREZWZhdWx0cyhfY29weUV4Y2x1ZGluZyhjb25maWcsIGluc3RhbmNlRGVmYXVsdHMpLCBzdGF0aWNzKSk7IC8vc3RhdGljIG1ldGhvZHNcblxuXG4gICAgICBfbWVyZ2UoUGx1Z2luLnByb3RvdHlwZSwgX21lcmdlKGluc3RhbmNlRGVmYXVsdHMsIF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgc3RhdGljcykpKTsgLy9pbnN0YW5jZSBtZXRob2RzXG5cblxuICAgICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcblxuICAgICAgaWYgKGNvbmZpZy50YXJnZXRUZXN0KSB7XG4gICAgICAgIF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XG5cbiAgICAgICAgX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICAgICAgfVxuXG4gICAgICBuYW1lID0gKG5hbWUgPT09IFwiY3NzXCIgPyBcIkNTU1wiIDogbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKSArIFwiUGx1Z2luXCI7IC8vZm9yIHRoZSBnbG9iYWwgbmFtZS4gXCJtb3Rpb25QYXRoXCIgc2hvdWxkIGJlY29tZSBNb3Rpb25QYXRoUGx1Z2luXG4gICAgfVxuXG4gICAgX2FkZEdsb2JhbChuYW1lLCBQbHVnaW4pO1xuXG4gICAgY29uZmlnLnJlZ2lzdGVyICYmIGNvbmZpZy5yZWdpc3Rlcihnc2FwLCBQbHVnaW4sIFByb3BUd2Vlbik7XG4gIH0gZWxzZSB7XG4gICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUucHVzaChjb25maWcpO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENPTE9SU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXzI1NSA9IDI1NSxcbiAgICBfY29sb3JMb29rdXAgPSB7XG4gIGFxdWE6IFswLCBfMjU1LCBfMjU1XSxcbiAgbGltZTogWzAsIF8yNTUsIDBdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgYmx1ZTogWzAsIDAsIF8yNTVdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgd2hpdGU6IFtfMjU1LCBfMjU1LCBfMjU1XSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxuICBvcmFuZ2U6IFtfMjU1LCAxNjUsIDBdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICByZWQ6IFtfMjU1LCAwLCAwXSxcbiAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcbiAgY3lhbjogWzAsIF8yNTUsIF8yNTVdLFxuICB0cmFuc3BhcmVudDogW18yNTUsIF8yNTUsIF8yNTUsIDBdXG59LFxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBpZGVhIHRvIHJlcGxhY2UgdGhlIGhhcmQtY29kZWQgY29sb3IgbmFtZSB2YWx1ZXMgLSBwdXQgdGhpcyBpbiB0aGUgdGlja2VyLndha2UoKSB3aGVyZSB3ZSBzZXQgdGhlIF9kb2M6XG4vLyBsZXQgY3R4ID0gX2RvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcbi8vIF9mb3JFYWNoTmFtZShcImFxdWEsbGltZSxzaWx2ZXIsYmxhY2ssbWFyb29uLHRlYWwsYmx1ZSxuYXZ5LHdoaXRlLG9saXZlLHllbGxvdyxvcmFuZ2UsZ3JheSxwdXJwbGUsZ3JlZW4scmVkLHBpbmssY3lhblwiLCBjb2xvciA9PiB7Y3R4LmZpbGxTdHlsZSA9IGNvbG9yOyBfY29sb3JMb29rdXBbY29sb3JdID0gc3BsaXRDb2xvcihjdHguZmlsbFN0eWxlKX0pO1xuX2h1ZSA9IGZ1bmN0aW9uIF9odWUoaCwgbTEsIG0yKSB7XG4gIGggKz0gaCA8IDAgPyAxIDogaCA+IDEgPyAtMSA6IDA7XG4gIHJldHVybiAoaCAqIDYgPCAxID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IGggPCAuNSA/IG0yIDogaCAqIDMgPCAyID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiBfMjU1ICsgLjUgfCAwO1xufSxcbiAgICBzcGxpdENvbG9yID0gZnVuY3Rpb24gc3BsaXRDb2xvcih2LCB0b0hTTCwgZm9yY2VBbHBoYSkge1xuICB2YXIgYSA9ICF2ID8gX2NvbG9yTG9va3VwLmJsYWNrIDogX2lzTnVtYmVyKHYpID8gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXG4gICAgICByLFxuICAgICAgZyxcbiAgICAgIGIsXG4gICAgICBoLFxuICAgICAgcyxcbiAgICAgIGwsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBkLFxuICAgICAgd2FzSFNMO1xuXG4gIGlmICghYSkge1xuICAgIGlmICh2LnN1YnN0cigtMSkgPT09IFwiLFwiKSB7XG4gICAgICAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1hIGlzIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY2hvcCBpdCBvZmYgKHR5cGljYWxseSBmcm9tIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIGxpa2UgYSB0ZXh0U2hhZG93OlwiMnB4IDJweCAycHggYmx1ZSwgNXB4IDVweCA1cHggcmdiKDI1NSwwLDApXCIgLSBpbiB0aGlzIGV4YW1wbGUgXCJibHVlLFwiIGhhcyBhIHRyYWlsaW5nIGNvbW1hLiBXZSBjb3VsZCBzdHJpcCBpdCBvdXQgaW5zaWRlIHBhcnNlQ29tcGxleCgpIGJ1dCB3ZSdkIG5lZWQgdG8gZG8gaXQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBwbHVzIGl0IHdvdWxkbid0IHByb3ZpZGUgcHJvdGVjdGlvbiBmcm9tIG90aGVyIHBvdGVudGlhbCBzY2VuYXJpb3MgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBzaW1pbGFyIHZhbHVlLlxuICAgICAgdiA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKF9jb2xvckxvb2t1cFt2XSkge1xuICAgICAgYSA9IF9jb2xvckxvb2t1cFt2XTtcbiAgICB9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgaWYgKHYubGVuZ3RoIDwgNikge1xuICAgICAgICAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwIG9yICM5RjBGIChjb3VsZCBoYXZlIGFscGhhKVxuICAgICAgICByID0gdi5jaGFyQXQoMSk7XG4gICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcbiAgICAgICAgYiA9IHYuY2hhckF0KDMpO1xuICAgICAgICB2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGIgKyAodi5sZW5ndGggPT09IDUgPyB2LmNoYXJBdCg0KSArIHYuY2hhckF0KDQpIDogXCJcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAvLyBoZXggd2l0aCBhbHBoYSwgbGlrZSAjZmQ1ZTUzZmZcbiAgICAgICAgYSA9IHBhcnNlSW50KHYuc3Vic3RyKDEsIDYpLCAxNik7XG4gICAgICAgIHJldHVybiBbYSA+PiAxNiwgYSA+PiA4ICYgXzI1NSwgYSAmIF8yNTUsIHBhcnNlSW50KHYuc3Vic3RyKDcpLCAxNikgLyAyNTVdO1xuICAgICAgfVxuXG4gICAgICB2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcbiAgICAgIGEgPSBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdO1xuICAgIH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcbiAgICAgIGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApO1xuXG4gICAgICBpZiAoIXRvSFNMKSB7XG4gICAgICAgIGggPSArYVswXSAlIDM2MCAvIDM2MDtcbiAgICAgICAgcyA9ICthWzFdIC8gMTAwO1xuICAgICAgICBsID0gK2FbMl0gLyAxMDA7XG4gICAgICAgIGcgPSBsIDw9IC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICByID0gbCAqIDIgLSBnO1xuICAgICAgICBhLmxlbmd0aCA+IDMgJiYgKGFbM10gKj0gMSk7IC8vY2FzdCBhcyBudW1iZXJcblxuICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuICAgICAgICBhWzFdID0gX2h1ZShoLCByLCBnKTtcbiAgICAgICAgYVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcbiAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcbiAgICAgICAgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG4gICAgICAgIGEgPSB2Lm1hdGNoKF9udW1FeHApO1xuICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIGEgPSBhLm1hcChOdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRvSFNMICYmICF3YXNIU0wpIHtcbiAgICByID0gYVswXSAvIF8yNTU7XG4gICAgZyA9IGFbMV0gLyBfMjU1O1xuICAgIGIgPSBhWzJdIC8gXzI1NTtcbiAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICBoID0gbWF4ID09PSByID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT09IGcgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH1cblxuICAgIGFbMF0gPSB+fihoICsgLjUpO1xuICAgIGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuICAgIGFbMl0gPSB+fihsICogMTAwICsgLjUpO1xuICB9XG5cbiAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgcmV0dXJuIGE7XG59LFxuICAgIF9jb2xvck9yZGVyRGF0YSA9IGZ1bmN0aW9uIF9jb2xvck9yZGVyRGF0YSh2KSB7XG4gIC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxuICB2YXIgdmFsdWVzID0gW10sXG4gICAgICBjID0gW10sXG4gICAgICBpID0gLTE7XG4gIHYuc3BsaXQoX2NvbG9yRXhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGEgPSB2Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcbiAgICBjLnB1c2goaSArPSBhLmxlbmd0aCArIDEpO1xuICB9KTtcbiAgdmFsdWVzLmMgPSBjO1xuICByZXR1cm4gdmFsdWVzO1xufSxcbiAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICBjb2xvcnMgPSAocyArIHJlc3VsdCkubWF0Y2goX2NvbG9yRXhwKSxcbiAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcbiAgICAgIGkgPSAwLFxuICAgICAgYyxcbiAgICAgIHNoZWxsLFxuICAgICAgZCxcbiAgICAgIGw7XG5cbiAgaWYgKCFjb2xvcnMpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIChjb2xvciA9IHNwbGl0Q29sb3IoY29sb3IsIHRvSFNMLCAxKSkgJiYgdHlwZSArICh0b0hTTCA/IGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcbiAgfSk7XG5cbiAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XG4gICAgZCA9IF9jb2xvck9yZGVyRGF0YShzKTtcbiAgICBjID0gb3JkZXJNYXRjaERhdGEuYztcblxuICAgIGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuICAgICAgc2hlbGwgPSBzLnJlcGxhY2UoX2NvbG9yRXhwLCBcIjFcIikuc3BsaXQoX251bVdpdGhVbml0RXhwKTtcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNoZWxsKSB7XG4gICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XG4gICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcbn0sXG4gICAgX2NvbG9yRXhwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszLDR9KXsxLDJ9XFxcXGJcIixcbiAgICAgIC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy4sXG4gIHA7XG5cbiAgZm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuICAgIHMgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocyArIFwiKVwiLCBcImdpXCIpO1xufSgpLFxuICAgIF9oc2xFeHAgPSAvaHNsW2FdP1xcKC8sXG4gICAgX2NvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24gX2NvbG9yU3RyaW5nRmlsdGVyKGEpIHtcbiAgdmFyIGNvbWJpbmVkID0gYS5qb2luKFwiIFwiKSxcbiAgICAgIHRvSFNMO1xuICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICBpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG4gICAgdG9IU0wgPSBfaHNsRXhwLnRlc3QoY29tYmluZWQpO1xuICAgIGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcbiAgICBhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCwgX2NvbG9yT3JkZXJEYXRhKGFbMV0pKTsgLy8gbWFrZSBzdXJlIHRoZSBvcmRlciBvZiBudW1iZXJzL2NvbG9ycyBtYXRjaCB3aXRoIHRoZSBFTkQgdmFsdWUuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSUNLRVJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl90aWNrZXJBY3RpdmUsXG4gICAgX3RpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgICBfbGFnVGhyZXNob2xkID0gNTAwLFxuICAgICAgX2FkanVzdGVkTGFnID0gMzMsXG4gICAgICBfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcbiAgICAgIF9sYXN0VXBkYXRlID0gX3N0YXJ0VGltZSxcbiAgICAgIF9nYXAgPSAxMDAwIC8gMjQwLFxuICAgICAgX25leHRUaW1lID0gX2dhcCxcbiAgICAgIF9saXN0ZW5lcnMgPSBbXSxcbiAgICAgIF9pZCxcbiAgICAgIF9yZXEsXG4gICAgICBfcmFmLFxuICAgICAgX3NlbGYsXG4gICAgICBfZGVsdGEsXG4gICAgICBfaSxcbiAgICAgIF90aWNrID0gZnVuY3Rpb24gX3RpY2sodikge1xuICAgIHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuICAgICAgICBtYW51YWwgPSB2ID09PSB0cnVlLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgdGltZSxcbiAgICAgICAgZnJhbWU7XG5cbiAgICAoZWxhcHNlZCA+IF9sYWdUaHJlc2hvbGQgfHwgZWxhcHNlZCA8IDApICYmIChfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWcpO1xuICAgIF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG4gICAgdGltZSA9IF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZTtcbiAgICBvdmVybGFwID0gdGltZSAtIF9uZXh0VGltZTtcblxuICAgIGlmIChvdmVybGFwID4gMCB8fCBtYW51YWwpIHtcbiAgICAgIGZyYW1lID0gKytfc2VsZi5mcmFtZTtcbiAgICAgIF9kZWx0YSA9IHRpbWUgLSBfc2VsZi50aW1lICogMTAwMDtcbiAgICAgIF9zZWxmLnRpbWUgPSB0aW1lID0gdGltZSAvIDEwMDA7XG4gICAgICBfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyA0IDogX2dhcCAtIG92ZXJsYXApO1xuICAgICAgZGlzcGF0Y2ggPSAxO1xuICAgIH1cblxuICAgIG1hbnVhbCB8fCAoX2lkID0gX3JlcShfdGljaykpOyAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBmb3IgKF9pID0gMDsgX2kgPCBfbGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAvLyB1c2UgX2kgYW5kIGNoZWNrIF9saXN0ZW5lcnMubGVuZ3RoIGluc3RlYWQgb2YgYSB2YXJpYWJsZSBiZWNhdXNlIGEgbGlzdGVuZXIgY291bGQgZ2V0IHJlbW92ZWQgZHVyaW5nIHRoZSBsb29wLCBhbmQgaWYgdGhhdCBoYXBwZW5zIHRvIGFuIGVsZW1lbnQgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGluZGV4LCBpdCdkIHRocm93IHRoaW5ncyBvZmYgaW4gdGhlIGxvb3AuXG4gICAgICAgIF9saXN0ZW5lcnNbX2ldKHRpbWUsIF9kZWx0YSwgZnJhbWUsIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfc2VsZiA9IHtcbiAgICB0aW1lOiAwLFxuICAgIGZyYW1lOiAwLFxuICAgIHRpY2s6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICBfdGljayh0cnVlKTtcbiAgICB9LFxuICAgIGRlbHRhUmF0aW86IGZ1bmN0aW9uIGRlbHRhUmF0aW8oZnBzKSB7XG4gICAgICByZXR1cm4gX2RlbHRhIC8gKDEwMDAgLyAoZnBzIHx8IDYwKSk7XG4gICAgfSxcbiAgICB3YWtlOiBmdW5jdGlvbiB3YWtlKCkge1xuICAgICAgaWYgKF9jb3JlUmVhZHkpIHtcbiAgICAgICAgaWYgKCFfY29yZUluaXR0ZWQgJiYgX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgICAgICAgX3dpbiA9IF9jb3JlSW5pdHRlZCA9IHdpbmRvdztcbiAgICAgICAgICBfZG9jID0gX3dpbi5kb2N1bWVudCB8fCB7fTtcbiAgICAgICAgICBfZ2xvYmFscy5nc2FwID0gZ3NhcDtcbiAgICAgICAgICAoX3dpbi5nc2FwVmVyc2lvbnMgfHwgKF93aW4uZ3NhcFZlcnNpb25zID0gW10pKS5wdXNoKGdzYXAudmVyc2lvbik7XG5cbiAgICAgICAgICBfaW5zdGFsbChfaW5zdGFsbFNjb3BlIHx8IF93aW4uR3JlZW5Tb2NrR2xvYmFscyB8fCAhX3dpbi5nc2FwICYmIF93aW4gfHwge30pO1xuXG4gICAgICAgICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUuZm9yRWFjaChfY3JlYXRlUGx1Z2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yYWYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgX2lkICYmIF9zZWxmLnNsZWVwKCk7XG5cbiAgICAgICAgX3JlcSA9IF9yYWYgfHwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCBfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGlja2VyQWN0aXZlID0gMTtcblxuICAgICAgICBfdGljaygyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgIChfcmFmID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhclRpbWVvdXQpKF9pZCk7XG4gICAgICBfdGlja2VyQWN0aXZlID0gMDtcbiAgICAgIF9yZXEgPSBfZW1wdHlGdW5jO1xuICAgIH0sXG4gICAgbGFnU21vb3RoaW5nOiBmdW5jdGlvbiBsYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuICAgICAgX2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCBJbmZpbml0eTsgLy8gemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXG4gICAgICBfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZyB8fCAzMywgX2xhZ1RocmVzaG9sZCk7XG4gICAgfSxcbiAgICBmcHM6IGZ1bmN0aW9uIGZwcyhfZnBzKSB7XG4gICAgICBfZ2FwID0gMTAwMCAvIChfZnBzIHx8IDI0MCk7XG4gICAgICBfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChjYWxsYmFjaywgb25jZSwgcHJpb3JpdGl6ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBvbmNlID8gZnVuY3Rpb24gKHQsIGQsIGYsIHYpIHtcbiAgICAgICAgY2FsbGJhY2sodCwgZCwgZiwgdik7XG5cbiAgICAgICAgX3NlbGYucmVtb3ZlKGZ1bmMpO1xuICAgICAgfSA6IGNhbGxiYWNrO1xuXG4gICAgICBfc2VsZi5yZW1vdmUoY2FsbGJhY2spO1xuXG4gICAgICBfbGlzdGVuZXJzW3ByaW9yaXRpemUgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiXShmdW5jKTtcblxuICAgICAgX3dha2UoKTtcblxuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaywgaSkge1xuICAgICAgfihpID0gX2xpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSkgJiYgX2xpc3RlbmVycy5zcGxpY2UoaSwgMSkgJiYgX2kgPj0gaSAmJiBfaS0tO1xuICAgIH0sXG4gICAgX2xpc3RlbmVyczogX2xpc3RlbmVyc1xuICB9O1xuICByZXR1cm4gX3NlbGY7XG59KCksXG4gICAgX3dha2UgPSBmdW5jdGlvbiBfd2FrZSgpIHtcbiAgcmV0dXJuICFfdGlja2VyQWN0aXZlICYmIF90aWNrZXIud2FrZSgpO1xufSxcbiAgICAvL2Fsc28gZW5zdXJlcyB0aGUgY29yZSBjbGFzc2VzIGFyZSBpbml0aWFsaXplZC5cblxuLypcbiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBFQVNJTkdcbiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKi9cbl9lYXNlTWFwID0ge30sXG4gICAgX2N1c3RvbUVhc2VFeHAgPSAvXltcXGQuXFwtTV1bXFxkLlxcLSxcXHNdLyxcbiAgICBfcXVvdGVzRXhwID0gL1tcIiddL2csXG4gICAgX3BhcnNlT2JqZWN0SW5TdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VPYmplY3RJblN0cmluZyh2YWx1ZSkge1xuICAvL3Rha2VzIGEgc3RyaW5nIGxpa2UgXCJ7d2lnZ2xlczoxMCwgdHlwZTphbnRpY2lwYXRlfSlcIiBhbmQgdHVybnMgaXQgaW50byBhIHJlYWwgb2JqZWN0LiBOb3RpY2UgaXQgZW5kcyBpbiBcIilcIiBhbmQgaW5jbHVkZXMgdGhlIHt9IHdyYXBwZXJzLiBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3IgcGFyc2luZyBlYXNlIGNvbmZpZ3MgYW5kIHByaW9yaXRpemVkIG9wdGltaXphdGlvbiByYXRoZXIgdGhhbiByZXVzYWJpbGl0eS5cbiAgdmFyIG9iaiA9IHt9LFxuICAgICAgc3BsaXQgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMykuc3BsaXQoXCI6XCIpLFxuICAgICAga2V5ID0gc3BsaXRbMF0sXG4gICAgICBpID0gMSxcbiAgICAgIGwgPSBzcGxpdC5sZW5ndGgsXG4gICAgICBpbmRleCxcbiAgICAgIHZhbCxcbiAgICAgIHBhcnNlZFZhbDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHZhbCA9IHNwbGl0W2ldO1xuICAgIGluZGV4ID0gaSAhPT0gbCAtIDEgPyB2YWwubGFzdEluZGV4T2YoXCIsXCIpIDogdmFsLmxlbmd0aDtcbiAgICBwYXJzZWRWYWwgPSB2YWwuc3Vic3RyKDAsIGluZGV4KTtcbiAgICBvYmpba2V5XSA9IGlzTmFOKHBhcnNlZFZhbCkgPyBwYXJzZWRWYWwucmVwbGFjZShfcXVvdGVzRXhwLCBcIlwiKS50cmltKCkgOiArcGFyc2VkVmFsO1xuICAgIGtleSA9IHZhbC5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfdmFsdWVJblBhcmVudGhlc2VzID0gZnVuY3Rpb24gX3ZhbHVlSW5QYXJlbnRoZXNlcyh2YWx1ZSkge1xuICB2YXIgb3BlbiA9IHZhbHVlLmluZGV4T2YoXCIoXCIpICsgMSxcbiAgICAgIGNsb3NlID0gdmFsdWUuaW5kZXhPZihcIilcIiksXG4gICAgICBuZXN0ZWQgPSB2YWx1ZS5pbmRleE9mKFwiKFwiLCBvcGVuKTtcbiAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhvcGVuLCB+bmVzdGVkICYmIG5lc3RlZCA8IGNsb3NlID8gdmFsdWUuaW5kZXhPZihcIilcIiwgY2xvc2UgKyAxKSA6IGNsb3NlKTtcbn0sXG4gICAgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKG5hbWUpIHtcbiAgLy9uYW1lIGNhbiBiZSBhIHN0cmluZyBsaWtlIFwiZWxhc3RpYy5vdXQoMSwwLjUpXCIsIGFuZCBwYXNzIGluIF9lYXNlTWFwIGFzIG9iaiBhbmQgaXQnbGwgcGFyc2UgaXQgb3V0IGFuZCBjYWxsIHRoZSBhY3R1YWwgZnVuY3Rpb24gbGlrZSBfZWFzZU1hcC5FbGFzdGljLmVhc2VPdXQuY29uZmlnKDEsMC41KS4gSXQgd2lsbCBhbHNvIHBhcnNlIGN1c3RvbSBlYXNlIHN0cmluZ3MgYXMgbG9uZyBhcyBDdXN0b21FYXNlIGlzIGxvYWRlZCBhbmQgcmVnaXN0ZXJlZCAoaW50ZXJuYWxseSBhcyBfZWFzZU1hcC5fQ0UpLlxuICB2YXIgc3BsaXQgPSAobmFtZSArIFwiXCIpLnNwbGl0KFwiKFwiKSxcbiAgICAgIGVhc2UgPSBfZWFzZU1hcFtzcGxpdFswXV07XG4gIHJldHVybiBlYXNlICYmIHNwbGl0Lmxlbmd0aCA+IDEgJiYgZWFzZS5jb25maWcgPyBlYXNlLmNvbmZpZy5hcHBseShudWxsLCB+bmFtZS5pbmRleE9mKFwie1wiKSA/IFtfcGFyc2VPYmplY3RJblN0cmluZyhzcGxpdFsxXSldIDogX3ZhbHVlSW5QYXJlbnRoZXNlcyhuYW1lKS5zcGxpdChcIixcIikubWFwKF9udW1lcmljSWZQb3NzaWJsZSkpIDogX2Vhc2VNYXAuX0NFICYmIF9jdXN0b21FYXNlRXhwLnRlc3QobmFtZSkgPyBfZWFzZU1hcC5fQ0UoXCJcIiwgbmFtZSkgOiBlYXNlO1xufSxcbiAgICBfaW52ZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnZlcnRFYXNlKGVhc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlKDEgLSBwKTtcbiAgfTtcbn0sXG4gICAgLy8gYWxsb3cgeW95b0Vhc2UgdG8gYmUgc2V0IGluIGNoaWxkcmVuIGFuZCBoYXZlIHRob3NlIGFmZmVjdGVkIHdoZW4gdGhlIHBhcmVudC9hbmNlc3RvciB0aW1lbGluZSB5b3lvcy5cbl9wcm9wYWdhdGVZb3lvRWFzZSA9IGZ1bmN0aW9uIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKSB7XG4gIHZhciBjaGlsZCA9IHRpbWVsaW5lLl9maXJzdCxcbiAgICAgIGVhc2U7XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcbiAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZCwgaXNZb3lvKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnZhcnMueW95b0Vhc2UgJiYgKCFjaGlsZC5feW95byB8fCAhY2hpbGQuX3JlcGVhdCkgJiYgY2hpbGQuX3lveW8gIT09IGlzWW95bykge1xuICAgICAgaWYgKGNoaWxkLnRpbWVsaW5lKSB7XG4gICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZC50aW1lbGluZSwgaXNZb3lvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhc2UgPSBjaGlsZC5fZWFzZTtcbiAgICAgICAgY2hpbGQuX2Vhc2UgPSBjaGlsZC5feUVhc2U7XG4gICAgICAgIGNoaWxkLl95RWFzZSA9IGVhc2U7XG4gICAgICAgIGNoaWxkLl95b3lvID0gaXNZb3lvO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gIH1cbn0sXG4gICAgX3BhcnNlRWFzZSA9IGZ1bmN0aW9uIF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgcmV0dXJuICFlYXNlID8gZGVmYXVsdEVhc2UgOiAoX2lzRnVuY3Rpb24oZWFzZSkgPyBlYXNlIDogX2Vhc2VNYXBbZWFzZV0gfHwgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKGVhc2UpKSB8fCBkZWZhdWx0RWFzZTtcbn0sXG4gICAgX2luc2VydEVhc2UgPSBmdW5jdGlvbiBfaW5zZXJ0RWFzZShuYW1lcywgZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXQpIHtcbiAgaWYgKGVhc2VPdXQgPT09IHZvaWQgMCkge1xuICAgIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICAgIHJldHVybiAxIC0gZWFzZUluKDEgLSBwKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGVhc2VJbk91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZUluT3V0ID0gZnVuY3Rpb24gZWFzZUluT3V0KHApIHtcbiAgICAgIHJldHVybiBwIDwgLjUgPyBlYXNlSW4ocCAqIDIpIC8gMiA6IDEgLSBlYXNlSW4oKDEgLSBwKSAqIDIpIC8gMjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGVhc2UgPSB7XG4gICAgZWFzZUluOiBlYXNlSW4sXG4gICAgZWFzZU91dDogZWFzZU91dCxcbiAgICBlYXNlSW5PdXQ6IGVhc2VJbk91dFxuICB9LFxuICAgICAgbG93ZXJjYXNlTmFtZTtcblxuICBfZm9yRWFjaE5hbWUobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfZ2xvYmFsc1tuYW1lXSA9IGVhc2U7XG4gICAgX2Vhc2VNYXBbbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKV0gPSBlYXNlT3V0O1xuXG4gICAgZm9yICh2YXIgcCBpbiBlYXNlKSB7XG4gICAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lICsgKHAgPT09IFwiZWFzZUluXCIgPyBcIi5pblwiIDogcCA9PT0gXCJlYXNlT3V0XCIgPyBcIi5vdXRcIiA6IFwiLmluT3V0XCIpXSA9IF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHBdID0gZWFzZVtwXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlYXNlO1xufSxcbiAgICBfZWFzZUluT3V0RnJvbU91dCA9IGZ1bmN0aW9uIF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/ICgxIC0gZWFzZU91dCgxIC0gcCAqIDIpKSAvIDIgOiAuNSArIGVhc2VPdXQoKHAgLSAuNSkgKiAyKSAvIDI7XG4gIH07XG59LFxuICAgIF9jb25maWdFbGFzdGljID0gZnVuY3Rpb24gX2NvbmZpZ0VsYXN0aWModHlwZSwgYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgdmFyIHAxID0gYW1wbGl0dWRlID49IDEgPyBhbXBsaXR1ZGUgOiAxLFxuICAgICAgLy9ub3RlOiBpZiBhbXBsaXR1ZGUgaXMgPCAxLCB3ZSBzaW1wbHkgYWRqdXN0IHRoZSBwZXJpb2QgZm9yIGEgbW9yZSBuYXR1cmFsIGZlZWwuIE90aGVyd2lzZSB0aGUgbWF0aCBkb2Vzbid0IHdvcmsgcmlnaHQgYW5kIHRoZSBjdXJ2ZSBzdGFydHMgYXQgMS5cbiAgcDIgPSAocGVyaW9kIHx8ICh0eXBlID8gLjMgOiAuNDUpKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSksXG4gICAgICBwMyA9IHAyIC8gXzJQSSAqIChNYXRoLmFzaW4oMSAvIHAxKSB8fCAwKSxcbiAgICAgIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICByZXR1cm4gcCA9PT0gMSA/IDEgOiBwMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogX3NpbigocCAtIHAzKSAqIHAyKSArIDE7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBwMiA9IF8yUEkgLyBwMjsgLy9wcmVjYWxjdWxhdGUgdG8gb3B0aW1pemVcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgIHJldHVybiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCk7XG4gIH07XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9jb25maWdCYWNrID0gZnVuY3Rpb24gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KSB7XG4gIGlmIChvdmVyc2hvb3QgPT09IHZvaWQgMCkge1xuICAgIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG4gIH1cblxuICB2YXIgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID8gLS1wICogcCAqICgob3ZlcnNob290ICsgMSkgKiBwICsgb3ZlcnNob290KSArIDEgOiAwO1xuICB9LFxuICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9IDogX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCk7XG5cbiAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAob3ZlcnNob290KSB7XG4gICAgcmV0dXJuIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCk7XG4gIH07XG5cbiAgcmV0dXJuIGVhc2U7XG59OyAvLyBhIGNoZWFwZXIgKGtiIGFuZCBjcHUpIGJ1dCBtb3JlIG1pbGQgd2F5IHRvIGdldCBhIHBhcmFtZXRlcml6ZWQgd2VpZ2h0ZWQgZWFzZSBieSBmZWVkaW5nIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlID0gcmF0aW8gPT4ge1xuLy8gXHRsZXQgeSA9IDAuNSArIHJhdGlvIC8gMjtcbi8vIFx0cmV0dXJuIHAgPT4gKDIgKiAoMSAtIHApICogcCAqIHkgKyBwICogcCk7XG4vLyB9LFxuLy8gYSBzdHJvbmdlciAoYnV0IG1vcmUgZXhwZW5zaXZlIGtiL2NwdSkgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIHRoYXQgbGV0cyB5b3UgZmVlZCBpbiBhIHZhbHVlIGJldHdlZW4gLTEgKGVhc2VJbikgYW5kIDEgKGVhc2VPdXQpIHdoZXJlIDAgaXMgbGluZWFyLlxuLy8gX3dlaWdodGVkRWFzZVN0cm9uZyA9IHJhdGlvID0+IHtcbi8vIFx0cmF0aW8gPSAuNSArIHJhdGlvIC8gMjtcbi8vIFx0bGV0IG8gPSAxIC8gMyAqIChyYXRpbyA8IC41ID8gcmF0aW8gOiAxIC0gcmF0aW8pLFxuLy8gXHRcdGIgPSByYXRpbyAtIG8sXG4vLyBcdFx0YyA9IHJhdGlvICsgbztcbi8vIFx0cmV0dXJuIHAgPT4gcCA9PT0gMSA/IHAgOiAzICogYiAqICgxIC0gcCkgKiAoMSAtIHApICogcCArIDMgKiBjICogKDEgLSBwKSAqIHAgKiBwICsgcCAqIHAgKiBwO1xuLy8gfTtcblxuXG5fZm9yRWFjaE5hbWUoXCJMaW5lYXIsUXVhZCxDdWJpYyxRdWFydCxRdWludCxTdHJvbmdcIiwgZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgdmFyIHBvd2VyID0gaSA8IDUgPyBpICsgMSA6IGk7XG5cbiAgX2luc2VydEVhc2UobmFtZSArIFwiLFBvd2VyXCIgKyAocG93ZXIgLSAxKSwgaSA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHAsIHBvd2VyKTtcbiAgfSA6IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHA7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gcCwgcG93ZXIpO1xuICB9LCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwIDwgLjUgPyBNYXRoLnBvdyhwICogMiwgcG93ZXIpIC8gMiA6IDEgLSBNYXRoLnBvdygoMSAtIHApICogMiwgcG93ZXIpIC8gMjtcbiAgfSk7XG59KTtcblxuX2Vhc2VNYXAuTGluZWFyLmVhc2VOb25lID0gX2Vhc2VNYXAubm9uZSA9IF9lYXNlTWFwLkxpbmVhci5lYXNlSW47XG5cbl9pbnNlcnRFYXNlKFwiRWxhc3RpY1wiLCBfY29uZmlnRWxhc3RpYyhcImluXCIpLCBfY29uZmlnRWxhc3RpYyhcIm91dFwiKSwgX2NvbmZpZ0VsYXN0aWMoKSk7XG5cbihmdW5jdGlvbiAobiwgYykge1xuICB2YXIgbjEgPSAxIC8gYyxcbiAgICAgIG4yID0gMiAqIG4xLFxuICAgICAgbjMgPSAyLjUgKiBuMSxcbiAgICAgIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICByZXR1cm4gcCA8IG4xID8gbiAqIHAgKiBwIDogcCA8IG4yID8gbiAqIE1hdGgucG93KHAgLSAxLjUgLyBjLCAyKSArIC43NSA6IHAgPCBuMyA/IG4gKiAocCAtPSAyLjI1IC8gYykgKiBwICsgLjkzNzUgOiBuICogTWF0aC5wb3cocCAtIDIuNjI1IC8gYywgMikgKyAuOTg0Mzc1O1xuICB9O1xuXG4gIF9pbnNlcnRFYXNlKFwiQm91bmNlXCIsIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSwgZWFzZU91dCk7XG59KSg3LjU2MjUsIDIuNzUpO1xuXG5faW5zZXJ0RWFzZShcIkV4cG9cIiwgZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgKiBwICsgcCAqIHAgKiBwICogcCAqIHAgKiBwICogKDEgLSBwKTtcbn0pOyAvLyBwcmV2aW91c2x5IDIgKiogKDEwICogKHAgLSAxKSkgYnV0IHRoYXQgZG9lc24ndCBlbmQgdXAgd2l0aCB0aGUgdmFsdWUgcXVpdGUgYXQgdGhlIHJpZ2h0IHNwb3Qgc28gd2UgZG8gYSBibGVuZGVkIGVhc2UgdG8gZW5zdXJlIGl0IGxhbmRzIHdoZXJlIGl0IHNob3VsZCBwZXJmZWN0bHkuXG5cblxuX2luc2VydEVhc2UoXCJDaXJjXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiAtKF9zcXJ0KDEgLSBwICogcCkgLSAxKTtcbn0pO1xuXG5faW5zZXJ0RWFzZShcIlNpbmVcIiwgZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAgPT09IDEgPyAxIDogLV9jb3MocCAqIF9IQUxGX1BJKSArIDE7XG59KTtcblxuX2luc2VydEVhc2UoXCJCYWNrXCIsIF9jb25maWdCYWNrKFwiaW5cIiksIF9jb25maWdCYWNrKFwib3V0XCIpLCBfY29uZmlnQmFjaygpKTtcblxuX2Vhc2VNYXAuU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5zdGVwcyA9IF9nbG9iYWxzLlN0ZXBwZWRFYXNlID0ge1xuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcbiAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkge1xuICAgICAgc3RlcHMgPSAxO1xuICAgIH1cblxuICAgIHZhciBwMSA9IDEgLyBzdGVwcyxcbiAgICAgICAgcDIgPSBzdGVwcyArIChpbW1lZGlhdGVTdGFydCA/IDAgOiAxKSxcbiAgICAgICAgcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwLFxuICAgICAgICBtYXggPSAxIC0gX3RpbnlOdW07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKChwMiAqIF9jbGFtcCgwLCBtYXgsIHApIHwgMCkgKyBwMykgKiBwMTtcbiAgICB9O1xuICB9XG59O1xuX2RlZmF1bHRzLmVhc2UgPSBfZWFzZU1hcFtcInF1YWQub3V0XCJdO1xuXG5fZm9yRWFjaE5hbWUoXCJvbkNvbXBsZXRlLG9uVXBkYXRlLG9uU3RhcnQsb25SZXBlYXQsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9jYWxsYmFja05hbWVzICs9IG5hbWUgKyBcIixcIiArIG5hbWUgKyBcIlBhcmFtcyxcIjtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDQUNIRVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR1NDYWNoZSA9IGZ1bmN0aW9uIEdTQ2FjaGUodGFyZ2V0LCBoYXJuZXNzKSB7XG4gIHRoaXMuaWQgPSBfZ3NJRCsrO1xuICB0YXJnZXQuX2dzYXAgPSB0aGlzO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5oYXJuZXNzID0gaGFybmVzcztcbiAgdGhpcy5nZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXQgOiBfZ2V0UHJvcGVydHk7XG4gIHRoaXMuc2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0U2V0dGVyIDogX2dldFNldHRlcjtcbn07XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFOSU1BVElPTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5leHBvcnQgdmFyIEFuaW1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbih2YXJzKSB7XG4gICAgdGhpcy52YXJzID0gdmFycztcbiAgICB0aGlzLl9kZWxheSA9ICt2YXJzLmRlbGF5IHx8IDA7XG5cbiAgICBpZiAodGhpcy5fcmVwZWF0ID0gdmFycy5yZXBlYXQgPT09IEluZmluaXR5ID8gLTIgOiB2YXJzLnJlcGVhdCB8fCAwKSB7XG4gICAgICAvLyBUT0RPOiByZXBlYXQ6IEluZmluaXR5IG9uIGEgdGltZWxpbmUncyBjaGlsZHJlbiBtdXN0IGZsYWcgdGhhdCB0aW1lbGluZSBpbnRlcm5hbGx5IGFuZCBhZmZlY3QgaXRzIHRvdGFsRHVyYXRpb24sIG90aGVyd2lzZSBpdCdsbCBzdG9wIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gd2hlbiByZWFjaGluZyB0aGUgc3RhcnQuXG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YXJzLnJlcGVhdERlbGF5IHx8IDA7XG4gICAgICB0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xuICAgIH1cblxuICAgIHRoaXMuX3RzID0gMTtcblxuICAgIF9zZXREdXJhdGlvbih0aGlzLCArdmFycy5kdXJhdGlvbiwgMSwgMSk7XG5cbiAgICB0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG5cbiAgICBpZiAoX2NvbnRleHQpIHtcbiAgICAgIHRoaXMuX2N0eCA9IF9jb250ZXh0O1xuXG4gICAgICBfY29udGV4dC5kYXRhLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBbmltYXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLnN0YXJ0VGltZSh0aGlzLl9zdGFydCArIHZhbHVlIC0gdGhpcy5fZGVsYXkpO1xuICAgICAgdGhpcy5fZGVsYXkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kZWxheTtcbiAgfTtcblxuICBfcHJvdG8uZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbER1cmF0aW9uKHRoaXMuX3JlcGVhdCA+IDAgPyB2YWx1ZSArICh2YWx1ZSArIHRoaXMuX3JEZWxheSkgKiB0aGlzLl9yZXBlYXQgOiB2YWx1ZSkgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSAmJiB0aGlzLl9kdXI7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiB0b3RhbER1cmF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdER1cjtcbiAgICB9XG5cbiAgICB0aGlzLl9kaXJ0eSA9IDA7XG4gICAgcmV0dXJuIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9yZXBlYXQgPCAwID8gdmFsdWUgOiAodmFsdWUgLSB0aGlzLl9yZXBlYXQgKiB0aGlzLl9yRGVsYXkpIC8gKHRoaXMuX3JlcGVhdCArIDEpKTtcbiAgfTtcblxuICBfcHJvdG8udG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgX3dha2UoKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLl9kcDtcblxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuX3RzKSB7XG4gICAgICBfYWxpZ25QbGF5aGVhZCh0aGlzLCBfdG90YWxUaW1lKTtcblxuICAgICAgIXBhcmVudC5fZHAgfHwgcGFyZW50LnBhcmVudCB8fCBfcG9zdEFkZENoZWNrcyhwYXJlbnQsIHRoaXMpOyAvLyBlZGdlIGNhc2U6IGlmIHRoaXMgaXMgYSBjaGlsZCBvZiBhIHRpbWVsaW5lIHRoYXQgYWxyZWFkeSBjb21wbGV0ZWQsIGZvciBleGFtcGxlLCB3ZSBtdXN0IHJlLWFjdGl2YXRlIHRoZSBwYXJlbnQuXG4gICAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnQgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQucGFyZW50Ll90aW1lICE9PSBwYXJlbnQuX3N0YXJ0ICsgKHBhcmVudC5fdHMgPj0gMCA/IHBhcmVudC5fdFRpbWUgLyBwYXJlbnQuX3RzIDogKHBhcmVudC50b3RhbER1cmF0aW9uKCkgLSBwYXJlbnQuX3RUaW1lKSAvIC1wYXJlbnQuX3RzKSkge1xuICAgICAgICAgIHBhcmVudC50b3RhbFRpbWUocGFyZW50Ll90VGltZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuX2RwLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiAodGhpcy5fdHMgPiAwICYmIF90b3RhbFRpbWUgPCB0aGlzLl90RHVyIHx8IHRoaXMuX3RzIDwgMCAmJiBfdG90YWxUaW1lID4gMCB8fCAhdGhpcy5fdER1ciAmJiAhX3RvdGFsVGltZSkpIHtcbiAgICAgICAgLy9pZiB0aGUgYW5pbWF0aW9uIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgcHV0IGl0IGJhY2sgaW50byBpdHMgbGFzdCBwYXJlbnQgKHJlY29yZGVkIGFzIF9kcCBmb3IgZXhhY3RseSBjYXNlcyBsaWtlIHRoaXMpLiBMaW1pdCB0byBwYXJlbnRzIHdpdGggYXV0b1JlbW92ZUNoaWxkcmVuIChsaWtlIGdsb2JhbFRpbWVsaW5lKSBzbyB0aGF0IGlmIHRoZSB1c2VyIG1hbnVhbGx5IHJlbW92ZXMgYW4gYW5pbWF0aW9uIGZyb20gYSB0aW1lbGluZSBhbmQgdGhlbiBhbHRlcnMgaXRzIHBsYXloZWFkLCBpdCBkb2Vzbid0IGdldCBhZGRlZCBiYWNrIGluLlxuICAgICAgICBfYWRkVG9UaW1lbGluZSh0aGlzLl9kcCwgdGhpcywgdGhpcy5fc3RhcnQgLSB0aGlzLl9kZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RUaW1lICE9PSBfdG90YWxUaW1lIHx8ICF0aGlzLl9kdXIgJiYgIXN1cHByZXNzRXZlbnRzIHx8IHRoaXMuX2luaXR0ZWQgJiYgTWF0aC5hYnModGhpcy5felRpbWUpID09PSBfdGlueU51bSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl9kdXIgJiYgX3RvdGFsVGltZSB8fCAhX3RvdGFsVGltZSAmJiAhdGhpcy5faW5pdHRlZCAmJiAodGhpcy5hZGQgfHwgdGhpcy5fcHRMb29rdXApKSB7XG4gICAgICAvLyBjaGVjayBmb3IgX3B0TG9va3VwIG9uIGEgVHdlZW4gaW5zdGFuY2UgdG8gZW5zdXJlIGl0IGhhcyBhY3R1YWxseSBmaW5pc2hlZCBiZWluZyBpbnN0YW50aWF0ZWQsIG90aGVyd2lzZSBpZiB0aGlzLnJldmVyc2UoKSBnZXRzIGNhbGxlZCBpbiB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBpdCBjb3VsZCB0cmlnZ2VyIGEgcmVuZGVyKCkgaGVyZSBldmVuIHRob3VnaCB0aGUgX3RhcmdldHMgd2VyZW4ndCBwb3B1bGF0ZWQsIHRodXMgd2hlbiBfaW5pdCgpIGlzIGNhbGxlZCB0aGVyZSB3b24ndCBiZSBhbnkgUHJvcFR3ZWVucyAoaXQnbGwgYWN0IGxpa2UgdGhlIHR3ZWVuIGlzIG5vbi1mdW5jdGlvbmFsKVxuICAgICAgdGhpcy5fdHMgfHwgKHRoaXMuX3BUaW1lID0gX3RvdGFsVGltZSk7IC8vIG90aGVyd2lzZSwgaWYgYW4gYW5pbWF0aW9uIGlzIHBhdXNlZCwgdGhlbiB0aGUgcGxheWhlYWQgaXMgbW92ZWQgYmFjayB0byB6ZXJvLCB0aGVuIHJlc3VtZWQsIGl0J2QgcmV2ZXJ0IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRpbWUgYXQgdGhlIHBhdXNlXG4gICAgICAvL2lmICghdGhpcy5fbG9jaykgeyAvLyBhdm9pZCBlbmRsZXNzIHJlY3Vyc2lvbiAobm90IHN1cmUgd2UgbmVlZCB0aGlzIHlldCBvciBpZiBpdCdzIHdvcnRoIHRoZSBwZXJmb3JtYW5jZSBoaXQpXG4gICAgICAvLyAgIHRoaXMuX2xvY2sgPSAxO1xuXG4gICAgICBfbGF6eVNhZmVSZW5kZXIodGhpcywgX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpOyAvLyAgIHRoaXMuX2xvY2sgPSAwO1xuICAgICAgLy99XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udGltZSA9IGZ1bmN0aW9uIHRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZShNYXRoLm1pbih0aGlzLnRvdGFsRHVyYXRpb24oKSwgdmFsdWUgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcykpICUgKHRoaXMuX2R1ciArIHRoaXMuX3JEZWxheSkgfHwgKHZhbHVlID8gdGhpcy5fZHVyIDogMCksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3RpbWU7IC8vIG5vdGU6IGlmIHRoZSBtb2R1bHVzIHJlc3VsdHMgaW4gMCwgdGhlIHBsYXloZWFkIGNvdWxkIGJlIGV4YWN0bHkgYXQgdGhlIGVuZCBvciB0aGUgYmVnaW5uaW5nLCBhbmQgd2UgYWx3YXlzIGRlZmVyIHRvIHRoZSBFTkQgd2l0aCBhIG5vbi16ZXJvIHZhbHVlLCBvdGhlcndpc2UgaWYgeW91IHNldCB0aGUgdGltZSgpIHRvIHRoZSB2ZXJ5IGVuZCAoZHVyYXRpb24oKSksIGl0IHdvdWxkIHJlbmRlciBhdCB0aGUgU1RBUlQhXG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0b3RhbFByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90VGltZSAvIHRoaXMuX3REdXIpIDogdGhpcy5yYXdUaW1lKCkgPj0gMCAmJiB0aGlzLl9pbml0dGVkID8gMSA6IDA7XG4gIH07XG5cbiAgX3Byb3RvLnByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiAodGhpcy5feW95byAmJiAhKHRoaXMuaXRlcmF0aW9uKCkgJiAxKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5kdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuX2R1cikgOiB0aGlzLnJhd1RpbWUoKSA+IDAgPyAxIDogMDtcbiAgfTtcblxuICBfcHJvdG8uaXRlcmF0aW9uID0gZnVuY3Rpb24gaXRlcmF0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHZhciBjeWNsZUR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpICsgdGhpcy5fckRlbGF5O1xuXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLl90aW1lICsgKHZhbHVlIC0gMSkgKiBjeWNsZUR1cmF0aW9uLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pICsgMSA6IDE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBhZGRpdGlvbjpcbiAgLy8gaXNQbGF5aW5nQmFja3dhcmRzKCkge1xuICAvLyBcdGxldCBhbmltYXRpb24gPSB0aGlzLFxuICAvLyBcdFx0b3JpZW50YXRpb24gPSAxOyAvLyAxID0gZm9yd2FyZCwgLTEgPSBiYWNrd2FyZFxuICAvLyBcdHdoaWxlIChhbmltYXRpb24pIHtcbiAgLy8gXHRcdG9yaWVudGF0aW9uICo9IGFuaW1hdGlvbi5yZXZlcnNlZCgpIHx8IChhbmltYXRpb24ucmVwZWF0KCkgJiYgIShhbmltYXRpb24uaXRlcmF0aW9uKCkgJiAxKSkgPyAtMSA6IDE7XG4gIC8vIFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24ucGFyZW50O1xuICAvLyBcdH1cbiAgLy8gXHRyZXR1cm4gb3JpZW50YXRpb24gPCAwO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8udGltZVNjYWxlID0gZnVuY3Rpb24gdGltZVNjYWxlKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J0cyA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gcmVjb3JkZWQgdGltZVNjYWxlLiBTcGVjaWFsIGNhc2U6IGlmIHNvbWVvbmUgY2FsbHMgcmV2ZXJzZSgpIG9uIGFuIGFuaW1hdGlvbiB3aXRoIHRpbWVTY2FsZSBvZiAwLCB3ZSBhc3NpZ24gaXQgLV90aW55TnVtIHRvIHJlbWVtYmVyIGl0J3MgcmV2ZXJzZWQuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3J0cyA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB0VGltZSA9IHRoaXMucGFyZW50ICYmIHRoaXMuX3RzID8gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGhpcy5wYXJlbnQuX3RpbWUsIHRoaXMpIDogdGhpcy5fdFRpbWU7IC8vIG1ha2Ugc3VyZSB0byBkbyB0aGUgcGFyZW50VG9DaGlsZFRvdGFsVGltZSgpIEJFRk9SRSBzZXR0aW5nIHRoZSBuZXcgX3RzIGJlY2F1c2UgdGhlIG9sZCBvbmUgbXVzdCBiZSB1c2VkIGluIHRoYXQgY2FsY3VsYXRpb24uXG4gICAgLy8gZnV0dXJlIGFkZGl0aW9uPyBVcCBzaWRlOiBmYXN0IGFuZCBtaW5pbWFsIGZpbGUgc2l6ZS4gRG93biBzaWRlOiBvbmx5IHdvcmtzIG9uIHRoaXMgYW5pbWF0aW9uOyBpZiBhIHRpbWVsaW5lIGlzIHJldmVyc2VkLCBmb3IgZXhhbXBsZSwgaXRzIGNoaWxkcmVucycgb25SZXZlcnNlIHdvdWxkbid0IGdldCBjYWxsZWQuXG4gICAgLy8oK3ZhbHVlIDwgMCAmJiB0aGlzLl9ydHMgPj0gMCkgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXZlcnNlXCIsIHRydWUpO1xuICAgIC8vIHByaW9yaXRpemUgcmVuZGVyaW5nIHdoZXJlIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBsaW5lcyB1cCBpbnN0ZWFkIG9mIHRoaXMuX3RUaW1lIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgYSB0d2VlbiB0aGF0J3MgYW5pbWF0aW5nIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgaW4gdGhlIHNhbWUgcmVuZGVyaW5nIGxvb3AgKHNhbWUgcGFyZW50KSwgdGh1cyBpZiB0aGUgdGltZVNjYWxlIHR3ZWVuIHJlbmRlcnMgZmlyc3QsIGl0IHdvdWxkIGFsdGVyIF9zdGFydCBCRUZPUkUgX3RUaW1lIHdhcyBzZXQgb24gdGhhdCB0aWNrIChpbiB0aGUgcmVuZGVyaW5nIGxvb3ApLCBlZmZlY3RpdmVseSBmcmVlemluZyBpdCB1bnRpbCB0aGUgdGltZVNjYWxlIHR3ZWVuIGZpbmlzaGVzLlxuXG4gICAgdGhpcy5fcnRzID0gK3ZhbHVlIHx8IDA7XG4gICAgdGhpcy5fdHMgPSB0aGlzLl9wcyB8fCB2YWx1ZSA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSB3aGljaCB3b3VsZCBiZSAwIGlmIHRoZSBhbmltYXRpb24gaXMgcGF1c2VkLlxuXG4gICAgdGhpcy50b3RhbFRpbWUoX2NsYW1wKC1NYXRoLmFicyh0aGlzLl9kZWxheSksIHRoaXMudG90YWxEdXJhdGlvbigpLCB0VGltZSksIHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSk7XG5cbiAgICBfc2V0RW5kKHRoaXMpOyAvLyBpZiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgd2FzIGZhbHNlLCB0aGUgZW5kIHRpbWUgZGlkbid0IGdldCB1cGRhdGVkIGluIHRoZSBfYWxpZ25QbGF5aGVhZCgpIG1ldGhvZCwgc28gZG8gaXQgaGVyZS5cblxuXG4gICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9IC8vIHBvc3NpYmxlIGZ1dHVyZSBhZGRpdGlvbiAtIGlmIGFuIGFuaW1hdGlvbiBpcyByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgdGhlbiAucmVzdGFydCgpIG9yIC5wbGF5KCkgb3IgLnJlc3VtZSgpIGlzIGNhbGxlZCwgcGVyaGFwcyB3ZSBzaG91bGQgZm9yY2UgaXQgYmFjayBpbnRvIHRoZSBnbG9iYWxUaW1lbGluZSBidXQgYmUgY2FyZWZ1bCBiZWNhdXNlIHdoYXQgaWYgaXQncyBhbHJlYWR5IGF0IGl0cyBlbmQ/IFdlIGRvbid0IHdhbnQgaXQgdG8ganVzdCBwZXJzaXN0IGZvcmV2ZXIgYW5kIG5vdCBnZXQgcmVsZWFzZWQgZm9yIEdDLlxuICAgIC8vICF0aGlzLnBhcmVudCAmJiAhdmFsdWUgJiYgdGhpcy5fdFRpbWUgPCB0aGlzLl90RHVyICYmIHRoaXMgIT09IF9nbG9iYWxUaW1lbGluZSAmJiBfZ2xvYmFsVGltZWxpbmUuYWRkKHRoaXMpO1xuXG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZSh2YWx1ZSk7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdGhpcy5fc3RhcnQgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgY29uZmlnID0gX3JldmVydENvbmZpZztcbiAgICB9XG5cbiAgICB2YXIgcHJldklzUmV2ZXJ0aW5nID0gX3JldmVydGluZztcbiAgICBfcmV2ZXJ0aW5nID0gY29uZmlnO1xuXG4gICAgaWYgKF9pc1JldmVydFdvcnRoeSh0aGlzKSkge1xuICAgICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLnJldmVydChjb25maWcpO1xuICAgICAgdGhpcy50b3RhbFRpbWUoLTAuMDEsIGNvbmZpZy5zdXBwcmVzc0V2ZW50cyk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhICE9PSBcIm5lc3RlZFwiICYmIGNvbmZpZy5raWxsICE9PSBmYWxzZSAmJiB0aGlzLmtpbGwoKTtcbiAgICBfcmV2ZXJ0aW5nID0gcHJldklzUmV2ZXJ0aW5nO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMsXG4gICAgICAgIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID8gcmF3VGltZSA6IGFuaW1hdGlvbi5yYXdUaW1lKCk7XG5cbiAgICB3aGlsZSAoYW5pbWF0aW9uKSB7XG4gICAgICB0aW1lID0gYW5pbWF0aW9uLl9zdGFydCArIHRpbWUgLyAoTWF0aC5hYnMoYW5pbWF0aW9uLl90cykgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5wYXJlbnQgJiYgdGhpcy5fc2F0ID8gdGhpcy5fc2F0Lmdsb2JhbFRpbWUocmF3VGltZSkgOiB0aW1lOyAvLyB0aGUgX3N0YXJ0QXQgdHdlZW5zIGZvciAuZnJvbVRvKCkgYW5kIC5mcm9tKCkgdGhhdCBoYXZlIGltbWVkaWF0ZVJlbmRlciBzaG91bGQgYWx3YXlzIGJlIEZJUlNUIGluIHRoZSB0aW1lbGluZSAoaW1wb3J0YW50IGZvciBjb250ZXh0LnJldmVydCgpKS4gXCJfc2F0XCIgc3RhbmRzIGZvciBfc3RhcnRBdFR3ZWVuLCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCB0d2VlbiB0aGF0IGNyZWF0ZWQgdGhlIF9zdGFydEF0LiBXZSBtdXN0IGRpc2Nlcm4gaWYgdGhhdCB0d2VlbiBoYWQgaW1tZWRpYXRlUmVuZGVyIHNvIHRoYXQgd2UgY2FuIGtub3cgd2hldGhlciBvciBub3QgdG8gcHJpb3JpdGl6ZSBpdCBpbiByZXZlcnQoKS5cbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3JlcGVhdCA9IHZhbHVlID09PSBJbmZpbml0eSA/IC0yIDogdmFsdWU7XG4gICAgICByZXR1cm4gX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVwZWF0ID09PSAtMiA/IEluZmluaXR5IDogdGhpcy5fcmVwZWF0O1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIHJlcGVhdERlbGF5KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0aW1lID0gdGhpcy5fdGltZTtcbiAgICAgIHRoaXMuX3JEZWxheSA9IHZhbHVlO1xuXG4gICAgICBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGltZSA/IHRoaXMudGltZSh0aW1lKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JEZWxheTtcbiAgfTtcblxuICBfcHJvdG8ueW95byA9IGZ1bmN0aW9uIHlveW8odmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5feW95byA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3lveW87XG4gIH07XG5cbiAgX3Byb3RvLnNlZWsgPSBmdW5jdGlvbiBzZWVrKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiksIF9pc05vdEZhbHNlKHN1cHByZXNzRXZlbnRzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3RhcnQgPSBmdW5jdGlvbiByZXN0YXJ0KGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgICB0aGlzLl9kdXIgfHwgKHRoaXMuX3pUaW1lID0gLV90aW55TnVtKTsgLy8gZW5zdXJlcyBvbkNvbXBsZXRlIGZpcmVzIG9uIGEgemVyby1kdXJhdGlvbiBhbmltYXRpb24gdGhhdCBnZXRzIHJlc3RhcnRlZC5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGF0VGltZSAhPSBudWxsICYmIHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlZCA9IGZ1bmN0aW9uIHJldmVyc2VkKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICEhdmFsdWUgIT09IHRoaXMucmV2ZXJzZWQoKSAmJiB0aGlzLnRpbWVTY2FsZSgtdGhpcy5fcnRzIHx8ICh2YWx1ZSA/IC1fdGlueU51bSA6IDApKTsgLy8gaW4gY2FzZSB0aW1lU2NhbGUgaXMgemVybywgcmV2ZXJzaW5nIHdvdWxkIGhhdmUgbm8gZWZmZWN0IHNvIHdlIHVzZSBfdGlueU51bS5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3J0cyA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9hY3QgPSAwO1xuICAgIHRoaXMuX3pUaW1lID0gLV90aW55TnVtO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcCxcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9zdGFydCxcbiAgICAgICAgcmF3VGltZTtcbiAgICByZXR1cm4gISEoIXBhcmVudCB8fCB0aGlzLl90cyAmJiB0aGlzLl9pbml0dGVkICYmIHBhcmVudC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gcGFyZW50LnJhd1RpbWUodHJ1ZSkpID49IHN0YXJ0ICYmIHJhd1RpbWUgPCB0aGlzLmVuZFRpbWUodHJ1ZSkgLSBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiBldmVudENhbGxiYWNrKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICB2YXIgdmFycyA9IHRoaXMudmFycztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBkZWxldGUgdmFyc1t0eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcnNbdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgcGFyYW1zICYmICh2YXJzW3R5cGUgKyBcIlBhcmFtc1wiXSA9IHBhcmFtcyk7XG4gICAgICAgIHR5cGUgPT09IFwib25VcGRhdGVcIiAmJiAodGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJzW3R5cGVdO1xuICB9O1xuXG4gIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgcHJldlByb20gPSBzZWxmLl9wcm9tO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIGYgPSBfaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IF9wYXNzVGhyb3VnaCxcbiAgICAgICAgICBfcmVzb2x2ZSA9IGZ1bmN0aW9uIF9yZXNvbHZlKCkge1xuICAgICAgICB2YXIgX3RoZW4gPSBzZWxmLnRoZW47XG4gICAgICAgIHNlbGYudGhlbiA9IG51bGw7IC8vIHRlbXBvcmFyaWx5IG51bGwgdGhlIHRoZW4oKSBtZXRob2QgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzIyKVxuXG4gICAgICAgIHByZXZQcm9tICYmIHByZXZQcm9tKCk7XG4gICAgICAgIF9pc0Z1bmN0aW9uKGYpICYmIChmID0gZihzZWxmKSkgJiYgKGYudGhlbiB8fCBmID09PSBzZWxmKSAmJiAoc2VsZi50aGVuID0gX3RoZW4pO1xuICAgICAgICByZXNvbHZlKGYpO1xuICAgICAgICBzZWxmLnRoZW4gPSBfdGhlbjtcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZWxmLl9pbml0dGVkICYmIHNlbGYudG90YWxQcm9ncmVzcygpID09PSAxICYmIHNlbGYuX3RzID49IDAgfHwgIXNlbGYuX3RUaW1lICYmIHNlbGYuX3RzIDwgMCkge1xuICAgICAgICBfcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fcHJvbSA9IF9yZXNvbHZlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5raWxsID0gZnVuY3Rpb24ga2lsbCgpIHtcbiAgICBfaW50ZXJydXB0KHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRpb247XG59KCk7XG5cbl9zZXREZWZhdWx0cyhBbmltYXRpb24ucHJvdG90eXBlLCB7XG4gIF90aW1lOiAwLFxuICBfc3RhcnQ6IDAsXG4gIF9lbmQ6IDAsXG4gIF90VGltZTogMCxcbiAgX3REdXI6IDAsXG4gIF9kaXJ0eTogMCxcbiAgX3JlcGVhdDogMCxcbiAgX3lveW86IGZhbHNlLFxuICBwYXJlbnQ6IG51bGwsXG4gIF9pbml0dGVkOiBmYWxzZSxcbiAgX3JEZWxheTogMCxcbiAgX3RzOiAxLFxuICBfZHA6IDAsXG4gIHJhdGlvOiAwLFxuICBfelRpbWU6IC1fdGlueU51bSxcbiAgX3Byb206IDAsXG4gIF9wczogZmFsc2UsXG4gIF9ydHM6IDFcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJTUVMSU5FXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFRpbWVsaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRpbWVsaW5lLCBfQW5pbWF0aW9uKTtcblxuICBmdW5jdGlvbiBUaW1lbGluZSh2YXJzLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BbmltYXRpb24uY2FsbCh0aGlzLCB2YXJzKSB8fCB0aGlzO1xuICAgIF90aGlzLmxhYmVscyA9IHt9O1xuICAgIF90aGlzLnNtb290aENoaWxkVGltaW5nID0gISF2YXJzLnNtb290aENoaWxkVGltaW5nO1xuICAgIF90aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICEhdmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW47XG4gICAgX3RoaXMuX3NvcnQgPSBfaXNOb3RGYWxzZSh2YXJzLnNvcnRDaGlsZHJlbik7XG4gICAgX2dsb2JhbFRpbWVsaW5lICYmIF9hZGRUb1RpbWVsaW5lKHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHBvc2l0aW9uKTtcbiAgICB2YXJzLnJldmVyc2VkICYmIF90aGlzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpcy5wYXVzZWQodHJ1ZSk7XG4gICAgdmFycy5zY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YXJzLnNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gVGltZWxpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMCwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSAhIXZhcnMuaW1tZWRpYXRlUmVuZGVyO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiksIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuY2FsbCA9IGZ1bmN0aW9uIGNhbGwoY2FsbGJhY2ssIHBhcmFtcywgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcyksIHBvc2l0aW9uKTtcbiAgfSAvL09OTFkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkhIE1heWJlIGRlbGV0ZT9cbiAgO1xuXG4gIF9wcm90bzIuc3RhZ2dlclRvID0gZnVuY3Rpb24gc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB2YXJzLnN0YWdnZXIgPSB2YXJzLnN0YWdnZXIgfHwgc3RhZ2dlcjtcbiAgICB2YXJzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlQWxsO1xuICAgIHZhcnMub25Db21wbGV0ZVBhcmFtcyA9IG9uQ29tcGxldGVBbGxQYXJhbXM7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc3RhZ2dlckZyb20gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbSh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB2YXJzLnJ1bkJhY2t3YXJkcyA9IDE7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh2YXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24gc3RhZ2dlckZyb21Ubyh0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModG9WYXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICB9O1xuXG4gIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX2RpcnR5ID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lIDw9IDAgPyAwIDogX3JvdW5kUHJlY2lzZSh0b3RhbFRpbWUpLFxuICAgICAgICAvLyBpZiBhIHBhdXNlZCB0aW1lbGluZSBpcyByZXN1bWVkIChvciBpdHMgX3N0YXJ0IGlzIHVwZGF0ZWQgZm9yIGFub3RoZXIgcmVhc29uLi4ud2hpY2ggcm91bmRzIGl0KSwgdGhhdCBjb3VsZCByZXN1bHQgaW4gdGhlIHBsYXloZWFkIHNoaWZ0aW5nIGEgKip0aW55KiogYW1vdW50IGFuZCBhIHplcm8tZHVyYXRpb24gY2hpbGQgYXQgdGhhdCBzcG90IG1heSBnZXQgcmVuZGVyZWQgYXQgYSBkaWZmZXJlbnQgcmF0aW8sIGxpa2UgaXRzIHRvdGFsVGltZSBpbiByZW5kZXIoKSBtYXkgYmUgMWUtMTcgaW5zdGVhZCBvZiAwLCBmb3IgZXhhbXBsZS5cbiAgICBjcm9zc2luZ1N0YXJ0ID0gdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwICYmICh0aGlzLl9pbml0dGVkIHx8ICFkdXIpLFxuICAgICAgICB0aW1lLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICBwcmV2UGF1c2VkLFxuICAgICAgICBwYXVzZVR3ZWVuLFxuICAgICAgICB0aW1lU2NhbGUsXG4gICAgICAgIHByZXZTdGFydCxcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgeW95byxcbiAgICAgICAgaXNZb3lvO1xuICAgIHRoaXMgIT09IF9nbG9iYWxUaW1lbGluZSAmJiB0VGltZSA+IHREdXIgJiYgdG90YWxUaW1lID49IDAgJiYgKHRUaW1lID0gdER1cik7XG5cbiAgICBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8IGZvcmNlIHx8IGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgIGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSAmJiBkdXIpIHtcbiAgICAgICAgLy9pZiB0b3RhbER1cmF0aW9uKCkgZmluZHMgYSBjaGlsZCB3aXRoIGEgbmVnYXRpdmUgc3RhcnRUaW1lIGFuZCBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCB0aGluZ3MgZ2V0IHNoaWZ0ZWQgYXJvdW5kIGludGVybmFsbHkgc28gd2UgbmVlZCB0byBhZGp1c3QgdGhlIHRpbWUgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiBhIHR3ZWVuIHN0YXJ0cyBhdCAtMzAgd2UgbXVzdCBzaGlmdCBFVkVSWVRISU5HIGZvcndhcmQgMzAgc2Vjb25kcyBhbmQgbW92ZSB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIGJhY2t3YXJkIGJ5IDMwIHNlY29uZHMgc28gdGhhdCB0aGluZ3MgYWxpZ24gd2l0aCB0aGUgcGxheWhlYWQgKG5vIGp1bXApLlxuICAgICAgICB0VGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICAgIHRvdGFsVGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgIHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgdGltZVNjYWxlID0gdGhpcy5fdHM7XG4gICAgICBwcmV2UGF1c2VkID0gIXRpbWVTY2FsZTtcblxuICAgICAgaWYgKGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgICAgZHVyIHx8IChwcmV2VGltZSA9IHRoaXMuX3pUaW1lKTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgICAgICAodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgeW95byA9IHRoaXMuX3lveW87XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2SXRlcmF0aW9uID0gX3JvdW5kUHJlY2lzZSh0VGltZSAvIGN5Y2xlRHVyYXRpb24pOyAvLyBmdWxsIGRlY2ltYWwgdmVyc2lvbiBvZiBpdGVyYXRpb25zLCBub3QgdGhlIHByZXZpb3VzIGl0ZXJhdGlvbiAod2UncmUgcmV1c2luZyBwcmV2SXRlcmF0aW9uIHZhcmlhYmxlIGZvciBlZmZpY2llbmN5KVxuXG4gICAgICAgICAgaXRlcmF0aW9uID0gfn5wcmV2SXRlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuICAgICAgICAhcHJldlRpbWUgJiYgdGhpcy5fdFRpbWUgJiYgcHJldkl0ZXJhdGlvbiAhPT0gaXRlcmF0aW9uICYmIHRoaXMuX3RUaW1lIC0gcHJldkl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24gLSB0aGlzLl9kdXIgPD0gMCAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzIzODIzLWNsb3NpbmctbmF2LWFuaW1hdGlvbi1ub3Qtd29ya2luZy1vbi1pZS1hbmQtaXBob25lLTYtbWF5YmUtb3RoZXItb2xkZXItYnJvd3Nlci8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTEzMDA1IGFsc28sIHRoaXMuX3RUaW1lIC0gcHJldkl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24gLSB0aGlzLl9kdXIgPD0gMCBqdXN0IGNoZWNrcyB0byBtYWtlIHN1cmUgaXQgd2Fzbid0IHByZXZpb3VzbHkgaW4gdGhlIFwicmVwZWF0RGVsYXlcIiBwb3J0aW9uXG5cbiAgICAgICAgaWYgKHlveW8gJiYgaXRlcmF0aW9uICYgMSkge1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICAgIGlzWW95byA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgbWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcbiAgICAgICAgYSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcbiAgICAgICAgd291bGQgZ2V0IHRyYW5zbGF0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG4gICAgICAgIGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xuICAgICAgICB3ZSBuZWVkIHRvIHB1c2ggdGhlIHRpbWVsaW5lIHRvIHRoZSBlbmQgKGFuZC9vciBiZWdpbm5pbmcgZGVwZW5kaW5nIG9uIGl0cyB5b3lvIHZhbHVlKS4gQWxzbyB3ZSBtdXN0XG4gICAgICAgIGVuc3VyZSB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIFRpbWVsaW5lIHdvcmsuXG4gICAgICAgICovXG5cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmICF0aGlzLl9sb2NrKSB7XG4gICAgICAgICAgdmFyIHJld2luZGluZyA9IHlveW8gJiYgcHJldkl0ZXJhdGlvbiAmIDEsXG4gICAgICAgICAgICAgIGRvZXNXcmFwID0gcmV3aW5kaW5nID09PSAoeW95byAmJiBpdGVyYXRpb24gJiAxKTtcbiAgICAgICAgICBpdGVyYXRpb24gPCBwcmV2SXRlcmF0aW9uICYmIChyZXdpbmRpbmcgPSAhcmV3aW5kaW5nKTtcbiAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IDAgOiB0VGltZSAlIGR1ciA/IGR1ciA6IHRUaW1lOyAvLyBpZiB0aGUgcGxheWhlYWQgaXMgbGFuZGluZyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgYW4gaXRlcmF0aW9uLCB1c2UgdGhhdCB0b3RhbFRpbWUgcmF0aGVyIHRoYW4gb25seSB0aGUgZHVyYXRpb24sIG90aGVyd2lzZSBpdCdsbCBza2lwIHRoZSAybmQgcmVuZGVyIHNpbmNlIGl0J3MgZWZmZWN0aXZlbHkgYXQgdGhlIHNhbWUgdGltZS5cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAxO1xuICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lIHx8IChpc1lveW8gPyAwIDogX3JvdW5kUHJlY2lzZShpdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uKSksIHN1cHByZXNzRXZlbnRzLCAhZHVyKS5fbG9jayA9IDA7XG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTsgLy8gaWYgYSB1c2VyIGdldHMgdGhlIGl0ZXJhdGlvbigpIGluc2lkZSB0aGUgb25SZXBlYXQsIGZvciBleGFtcGxlLCBpdCBzaG91bGQgYmUgYWNjdXJhdGUuXG5cbiAgICAgICAgICAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95bykge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCkuX2xvY2sgPSAxO1xuICAgICAgICAgICAgcHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbjsgLy8gb3RoZXJ3aXNlLCB0aGUgb25TdGFydCgpIG1heSBmaXJlIG9uIHRoZSAybmQgaXRlcmF0aW9uLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmV2VGltZSAmJiBwcmV2VGltZSAhPT0gdGhpcy5fdGltZSB8fCBwcmV2UGF1c2VkICE9PSAhdGhpcy5fdHMgfHwgdGhpcy52YXJzLm9uUmVwZWF0ICYmICF0aGlzLnBhcmVudCAmJiAhdGhpcy5fYWN0KSB7XG4gICAgICAgICAgICAvLyBpZiBwcmV2VGltZSBpcyAwIGFuZCB3ZSByZW5kZXIgYXQgdGhlIHZlcnkgZW5kLCBfdGltZSB3aWxsIGJlIHRoZSBlbmQsIHRodXMgd29uJ3QgbWF0Y2guIFNvIGluIHRoaXMgZWRnZSBjYXNlLCBwcmV2VGltZSB3b24ndCBtYXRjaCBfdGltZSBidXQgdGhhdCdzIG9rYXkuIElmIGl0IGdldHMga2lsbGVkIGluIHRoZSBvblJlcGVhdCwgZWplY3QgYXMgd2VsbC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGR1ciA9IHRoaXMuX2R1cjsgLy8gaW4gY2FzZSB0aGUgZHVyYXRpb24gY2hhbmdlZCBpbiB0aGUgb25SZXBlYXRcblxuICAgICAgICAgIHREdXIgPSB0aGlzLl90RHVyO1xuXG4gICAgICAgICAgaWYgKGRvZXNXcmFwKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gMjtcbiAgICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gZHVyIDogLTAuMDAwMTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IC8vaW4gb3JkZXIgZm9yIHlveW9FYXNlIHRvIHdvcmsgcHJvcGVybHkgd2hlbiB0aGVyZSdzIGEgc3RhZ2dlciwgd2UgbXVzdCBzd2FwIG91dCB0aGUgZWFzZSBpbiBlYWNoIHN1Yi10d2Vlbi5cblxuXG4gICAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKHRoaXMsIGlzWW95byk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nICYmIHRoaXMuX2xvY2sgPCAyKSB7XG4gICAgICAgIHBhdXNlVHdlZW4gPSBfZmluZE5leHRQYXVzZVR3ZWVuKHRoaXMsIF9yb3VuZFByZWNpc2UocHJldlRpbWUpLCBfcm91bmRQcmVjaXNlKHRpbWUpKTtcblxuICAgICAgICBpZiAocGF1c2VUd2Vlbikge1xuICAgICAgICAgIHRUaW1lIC09IHRpbWUgLSAodGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9hY3QgPSAhdGltZVNjYWxlOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuICAgICAgICB0aGlzLl9pbml0dGVkID0gMTtcbiAgICAgICAgdGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgIHByZXZUaW1lID0gMDsgLy8gdXBvbiBpbml0LCB0aGUgcGxheWhlYWQgc2hvdWxkIGFsd2F5cyBnbyBmb3J3YXJkOyBzb21lb25lIGNvdWxkIGludmFsaWRhdGUoKSBhIGNvbXBsZXRlZCB0aW1lbGluZSBhbmQgdGhlbiBpZiB0aGV5IHJlc3RhcnQoKSwgdGhhdCB3b3VsZCBtYWtlIGNoaWxkIHR3ZWVucyByZW5kZXIgaW4gcmV2ZXJzZSBvcmRlciB3aGljaCBjb3VsZCBsb2NrIGluIHRoZSB3cm9uZyBzdGFydGluZyB2YWx1ZXMgaWYgdGhleSBidWlsZCBvbiBlYWNoIG90aGVyLCBsaWtlIHRsLnRvKG9iaiwge3g6IDEwMH0pLnRvKG9iaiwge3g6IDB9KS5cbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmV2VGltZSAmJiB0VGltZSAmJiBkdXIgJiYgIXN1cHByZXNzRXZlbnRzICYmICFwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uU3RhcnRcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkge1xuICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG9uU3RhcnQgdHJpZ2dlcmVkIGEgcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QsIGVqZWN0LiBMaWtlIGlmIHNvbWVvbmUgZGlkIGFuaW1hdGlvbi5wYXVzZSgwLjUpIG9yIHNvbWV0aGluZyBpbnNpZGUgdGhlIG9uU3RhcnQuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWUgPj0gcHJldlRpbWUgJiYgdG90YWxUaW1lID49IDApIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gLV90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGZsYWcgelRpbWUgYXMgbmVnYXRpdmUgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9sYXN0O1xuICAgICAgICB2YXIgYWRqdXN0ZWRUaW1lID0gdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWU7IC8vd2hlbiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0IG9mIHRoaXMgdGltZWxpbmUsIHdlIG11c3QgcGFzcyB0aGF0IGluZm9ybWF0aW9uIGRvd24gdG8gdGhlIGNoaWxkIGFuaW1hdGlvbnMgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBrbm93IHdoZXRoZXIgdG8gcmVuZGVyIHRoZWlyIHN0YXJ0aW5nIG9yIGVuZGluZyB2YWx1ZXMuXG5cbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgbmV4dCA9IGNoaWxkLl9wcmV2O1xuXG4gICAgICAgICAgaWYgKChjaGlsZC5fYWN0IHx8IGFkanVzdGVkVGltZSA8PSBjaGlsZC5fZW5kKSAmJiBjaGlsZC5fdHMgJiYgcGF1c2VUd2VlbiAhPT0gY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgLy8gYW4gZXh0cmVtZSBlZGdlIGNhc2UgLSB0aGUgY2hpbGQncyByZW5kZXIgY291bGQgZG8gc29tZXRoaW5nIGxpa2Uga2lsbCgpIHRoZSBcIm5leHRcIiBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0LCBvciByZXBhcmVudCBpdC4gSW4gdGhhdCBjYXNlIHdlIG11c3QgcmUtaW5pdGlhdGUgdGhlIHdob2xlIHJlbmRlciB0byBiZSBzYWZlLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/IChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArIChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UgfHwgX3JldmVydGluZyAmJiBfaXNSZXZlcnRXb3J0aHkoY2hpbGQpKTsgLy8gaWYgcmV2ZXJ0aW5nLCB3ZSBzaG91bGQgYWx3YXlzIGZvcmNlIHJlbmRlcnMgb2YgaW5pdHRlZCB0d2VlbnMgKGJ1dCByZW1lbWJlciB0aGF0IC5mcm9tVG8oKSBvciAuZnJvbSgpIG1heSBoYXZlIGEgX3N0YXJ0QXQgYnV0IG5vdCBfaW5pdHRlZCB5ZXQpLiBJZiwgZm9yIGV4YW1wbGUsIGEgLmZyb21UbygpIHR3ZWVuIHdpdGggYSBzdGFnZ2VyICh3aGljaCBjcmVhdGVzIGFuIGludGVybmFsIHRpbWVsaW5lKSBnZXRzIHJldmVydGVkIEJFRk9SRSBzb21lIG9mIGl0cyBjaGlsZCB0d2VlbnMgcmVuZGVyIGZvciB0aGUgZmlyc3QgdGltZSwgaXQgbWF5IG5vdCBwcm9wZXJseSB0cmlnZ2VyIHRoZW0gdG8gcmV2ZXJ0LlxuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSBhZGp1c3RlZFRpbWUgPyAtX3RpbnlOdW0gOiBfdGlueU51bSk7IC8vIGl0IGRpZG4ndCBmaW5pc2ggcmVuZGVyaW5nLCBzbyBhZGp1c3QgelRpbWUgc28gdGhhdCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgcmVuZGVyKCkgaXMgY2FsbGVkIGl0J2xsIGJlIGZvcmNlZCAodG8gcmVuZGVyIGFueSByZW1haW5pbmcgY2hpbGRyZW4pXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXVzZVR3ZWVuICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIHBhdXNlVHdlZW4ucmVuZGVyKHRpbWUgPj0gcHJldlRpbWUgPyAwIDogLV90aW55TnVtKS5felRpbWUgPSB0aW1lID49IHByZXZUaW1lID8gMSA6IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLl90cykge1xuICAgICAgICAgIC8vdGhlIGNhbGxiYWNrIHJlc3VtZWQgcGxheWJhY2shIFNvIHNpbmNlIHdlIG1heSBoYXZlIGhlbGQgYmFjayB0aGUgcGxheWhlYWQgZHVlIHRvIHdoZXJlIHRoZSBwYXVzZSBpcyBwb3NpdGlvbmVkLCBnbyBhaGVhZCBhbmQganVtcCB0byB3aGVyZSBpdCdzIFNVUFBPU0VEIHRvIGJlIChpZiBubyBwYXVzZSBoYXBwZW5lZCkuXG4gICAgICAgICAgdGhpcy5fc3RhcnQgPSBwcmV2U3RhcnQ7IC8vaWYgdGhlIHBhdXNlIHdhcyBhdCBhbiBlYXJsaWVyIHRpbWUgYW5kIHRoZSB1c2VyIHJlc3VtZWQgaW4gdGhlIGNhbGxiYWNrLCBpdCBjb3VsZCByZXBvc2l0aW9uIHRoZSB0aW1lbGluZSAoY2hhbmdpbmcgaXRzIHN0YXJ0VGltZSksIHRocm93aW5nIHRoaW5ncyBvZmYgc2xpZ2h0bHksIHNvIHdlIG1ha2Ugc3VyZSB0aGUgX3N0YXJ0IGRvZXNuJ3Qgc2hpZnQuXG5cbiAgICAgICAgICBfc2V0RW5kKHRoaXMpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIiwgdHJ1ZSk7XG4gICAgICBpZiAodFRpbWUgPT09IHREdXIgJiYgdGhpcy5fdFRpbWUgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkgfHwgIXRUaW1lICYmIHByZXZUaW1lKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydCB8fCBNYXRoLmFicyh0aW1lU2NhbGUpICE9PSBNYXRoLmFicyh0aGlzLl90cykpIGlmICghdGhpcy5fbG9jaykge1xuICAgICAgICAvLyByZW1lbWJlciwgYSBjaGlsZCdzIGNhbGxiYWNrIG1heSBhbHRlciB0aGlzIHRpbWVsaW5lJ3MgcGxheWhlYWQgb3IgdGltZVNjYWxlIHdoaWNoIGlzIHdoeSB3ZSBuZWVkIHRvIGFkZCBzb21lIG9mIHRoZXNlIGNoZWNrcy5cbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHREdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSB8fCAhdER1cikpIHtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgJiYgdG90YWxUaW1lID49IDAgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZCA9IGZ1bmN0aW9uIGFkZChjaGlsZCwgcG9zaXRpb24pIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIF9pc051bWJlcihwb3NpdGlvbikgfHwgKHBvc2l0aW9uID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24sIGNoaWxkKSk7XG5cbiAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcbiAgICAgIGlmIChfaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5hZGQob2JqLCBwb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc1N0cmluZyhjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGFiZWwoY2hpbGQsIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICBjaGlsZCA9IFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzICE9PSBjaGlsZCA/IF9hZGRUb1RpbWVsaW5lKHRoaXMsIGNoaWxkLCBwb3NpdGlvbikgOiB0aGlzOyAvL2Rvbid0IGFsbG93IGEgdGltZWxpbmUgdG8gYmUgYWRkZWQgdG8gaXRzZWxmIGFzIGEgY2hpbGQhXG4gIH07XG5cbiAgX3Byb3RvMi5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldENoaWxkcmVuKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICBpZiAobmVzdGVkID09PSB2b2lkIDApIHtcbiAgICAgIG5lc3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR3ZWVucyA9PT0gdm9pZCAwKSB7XG4gICAgICB0d2VlbnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aW1lbGluZXMgPT09IHZvaWQgMCkge1xuICAgICAgdGltZWxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZ25vcmVCZWZvcmVUaW1lID0gLV9iaWdOdW07XG4gICAgfVxuXG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuKSB7XG4gICAgICAgICAgdHdlZW5zICYmIGEucHVzaChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZWxpbmVzICYmIGEucHVzaChjaGlsZCk7XG4gICAgICAgICAgbmVzdGVkICYmIGEucHVzaC5hcHBseShhLCBjaGlsZC5nZXRDaGlsZHJlbih0cnVlLCB0d2VlbnMsIHRpbWVsaW5lcykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRCeUlkID0gZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5nZXRDaGlsZHJlbigxLCAxLCAxKSxcbiAgICAgICAgaSA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGFuaW1hdGlvbnNbaV0udmFycy5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gICAgaWYgKF9pc1N0cmluZyhjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZUxhYmVsKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5raWxsVHdlZW5zT2YoY2hpbGQpO1xuICAgIH1cblxuICAgIGNoaWxkLnBhcmVudCA9PT0gdGhpcyAmJiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgY2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcbiAgICAgIHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xuXG4gICAgaWYgKCF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuICAvLyB0YXJnZXRzKCkge1xuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcbiAgLy8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcbiAgLy8gXHRyZXR1cm4gcmVzdWx0LmZpbHRlcigodiwgaSkgPT4gcmVzdWx0LmluZGV4T2YodikgPT09IGkpO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBpbml0dGVkLFxuICAgICAgICB0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcblxuICAgICAgICBpZiAoIWluaXR0ZWQpIHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSk7XG4gICAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBpbml0dGVkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuXG4gICAgcmV0dXJuIGltbWVkaWF0ZVJlbmRlciA/IHR3ZWVuLnJlbmRlcigwKSA6IHR3ZWVuO1xuICB9O1xuXG4gIF9wcm90bzIudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbiB0d2VlbkZyb21Ubyhmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcbiAgICByZXR1cm4gdGhpcy50d2VlblRvKHRvUG9zaXRpb24sIF9zZXREZWZhdWx0cyh7XG4gICAgICBzdGFydEF0OiB7XG4gICAgICAgIHRpbWU6IF9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbilcbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZWNlbnQgPSBmdW5jdGlvbiByZWNlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY2VudDtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRMYWJlbCA9IGZ1bmN0aW9uIG5leHRMYWJlbChhZnRlclRpbWUpIHtcbiAgICBpZiAoYWZ0ZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuICB9O1xuXG4gIF9wcm90bzIucHJldmlvdXNMYWJlbCA9IGZ1bmN0aW9uIHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSkge1xuICAgIGlmIChiZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvMi5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbiBjdXJyZW50TGFiZWwodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8yLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICBwO1xuICAgIGFtb3VudCA9IF9yb3VuZFByZWNpc2UoYW1vdW50KTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG4gICAgICAgIGNoaWxkLl9lbmQgKz0gYW1vdW50O1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChhZGp1c3RMYWJlbHMpIHtcbiAgICAgIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICAgICAgaWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgICAgbGFiZWxzW3BdICs9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKHNvZnQpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgY2hpbGQuaW52YWxpZGF0ZShzb2Z0KTtcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzLCBzb2Z0KTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xuICAgIGlmIChpbmNsdWRlTGFiZWxzID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG4gICAgaW5jbHVkZUxhYmVscyAmJiAodGhpcy5sYWJlbHMgPSB7fSk7XG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNoaWxkID0gc2VsZi5fbGFzdCxcbiAgICAgICAgcHJldlN0YXJ0ID0gX2JpZ051bSxcbiAgICAgICAgcHJldixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBhcmVudDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VsZi50aW1lU2NhbGUoKHNlbGYuX3JlcGVhdCA8IDAgPyBzZWxmLmR1cmF0aW9uKCkgOiBzZWxmLnRvdGFsRHVyYXRpb24oKSkgLyAoc2VsZi5yZXZlcnNlZCgpID8gLXZhbHVlIDogdmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgIHBhcmVudCA9IHNlbGYucGFyZW50O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cbiAgICAgICAgY2hpbGQuX2RpcnR5ICYmIGNoaWxkLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblxuICAgICAgICBzdGFydCA9IGNoaWxkLl9zdGFydDtcblxuICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcbiAgICAgICAgICAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gICAgICAgICAgc2VsZi5fbG9jayA9IDE7IC8vcHJldmVudCBlbmRsZXNzIHJlY3Vyc2l2ZSBjYWxscyAtIHRoZXJlIGFyZSBtZXRob2RzIHRoYXQgZ2V0IHRyaWdnZXJlZCB0aGF0IGNoZWNrIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gd2hlbiB3ZSBhZGQoKS5cblxuICAgICAgICAgIF9hZGRUb1RpbWVsaW5lKHNlbGYsIGNoaWxkLCBzdGFydCAtIGNoaWxkLl9kZWxheSwgMSkuX2xvY2sgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCAmJiBjaGlsZC5fdHMpIHtcbiAgICAgICAgICAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuICAgICAgICAgIG1heCAtPSBzdGFydDtcblxuICAgICAgICAgIGlmICghcGFyZW50ICYmICFzZWxmLl9kcCB8fCBwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSB7XG4gICAgICAgICAgICBzZWxmLl9zdGFydCArPSBfcm91bmRQcmVjaXNlKHN0YXJ0IC8gc2VsZi5fdHMpO1xuICAgICAgICAgICAgc2VsZi5fdGltZSAtPSBzdGFydDtcbiAgICAgICAgICAgIHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuc2hpZnRDaGlsZHJlbigtc3RhcnQsIGZhbHNlLCAtMWU5OTkpO1xuICAgICAgICAgIHByZXZTdGFydCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5fZW5kID4gbWF4ICYmIGNoaWxkLl90cyAmJiAobWF4ID0gY2hpbGQuX2VuZCk7XG4gICAgICAgIGNoaWxkID0gcHJldjtcbiAgICAgIH1cblxuICAgICAgX3NldER1cmF0aW9uKHNlbGYsIHNlbGYgPT09IF9nbG9iYWxUaW1lbGluZSAmJiBzZWxmLl90aW1lID4gbWF4ID8gc2VsZi5fdGltZSA6IG1heCwgMSwgMSk7XG5cbiAgICAgIHNlbGYuX2RpcnR5ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5fdER1cjtcbiAgfTtcblxuICBUaW1lbGluZS51cGRhdGVSb290ID0gZnVuY3Rpb24gdXBkYXRlUm9vdCh0aW1lKSB7XG4gICAgaWYgKF9nbG9iYWxUaW1lbGluZS5fdHMpIHtcbiAgICAgIF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXG4gICAgICBfbGFzdFJlbmRlcmVkRnJhbWUgPSBfdGlja2VyLmZyYW1lO1xuICAgIH1cblxuICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuICAgICAgX25leHRHQ0ZyYW1lICs9IF9jb25maWcuYXV0b1NsZWVwIHx8IDEyMDtcbiAgICAgIHZhciBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuICAgICAgICB3aGlsZSAoY2hpbGQgJiYgIWNoaWxkLl90cykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCB8fCBfdGlja2VyLnNsZWVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaW1lbGluZTtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFRpbWVsaW5lLnByb3RvdHlwZSwge1xuICBfbG9jazogMCxcbiAgX2hhc1BhdXNlOiAwLFxuICBfZm9yY2luZzogMFxufSk7XG5cbnZhciBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAvL25vdGU6IHdlIGNhbGwgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0d2Vlbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YXJ0TnVtcyxcbiAgICAgIGNvbG9yLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBzdGFydE51bSxcbiAgICAgIGhhc1JhbmRvbSxcbiAgICAgIGE7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICB9XG5cbiAgaWYgKHN0cmluZ0ZpbHRlcikge1xuICAgIGEgPSBbc3RhcnQsIGVuZF07XG4gICAgc3RyaW5nRmlsdGVyKGEsIHRhcmdldCwgcHJvcCk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblxuICAgIHN0YXJ0ID0gYVswXTtcbiAgICBlbmQgPSBhWzFdO1xuICB9XG5cbiAgc3RhcnROdW1zID0gc3RhcnQubWF0Y2goX2NvbXBsZXhTdHJpbmdOdW1FeHApIHx8IFtdO1xuXG4gIHdoaWxlIChyZXN1bHQgPSBfY29tcGxleFN0cmluZ051bUV4cC5leGVjKGVuZCkpIHtcbiAgICBlbmROdW0gPSByZXN1bHRbMF07XG4gICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIikge1xuICAgICAgY29sb3IgPSAxO1xuICAgIH1cblxuICAgIGlmIChlbmROdW0gIT09IHN0YXJ0TnVtc1ttYXRjaEluZGV4KytdKSB7XG4gICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW21hdGNoSW5kZXggLSAxXSkgfHwgMDsgLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG4gICAgICBwdC5fcHQgPSB7XG4gICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgIGM6IGVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZE51bSkgLSBzdGFydE51bSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSwgb3B0aW9uYWwpIHtcbiAgX2lzRnVuY3Rpb24oZW5kKSAmJiAoZW5kID0gZW5kKGluZGV4IHx8IDAsIHRhcmdldCwgdGFyZ2V0cykpO1xuICB2YXIgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdLFxuICAgICAgcGFyc2VkU3RhcnQgPSBzdGFydCAhPT0gXCJnZXRcIiA/IHN0YXJ0IDogIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUgOiBmdW5jUGFyYW0gPyB0YXJnZXRbcHJvcC5pbmRleE9mKFwic2V0XCIpIHx8ICFfaXNGdW5jdGlvbih0YXJnZXRbXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXSkgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXShmdW5jUGFyYW0pIDogdGFyZ2V0W3Byb3BdKCksXG4gICAgICBzZXR0ZXIgPSAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IF9zZXR0ZXJQbGFpbiA6IGZ1bmNQYXJhbSA/IF9zZXR0ZXJGdW5jV2l0aFBhcmFtIDogX3NldHRlckZ1bmMsXG4gICAgICBwdDtcblxuICBpZiAoX2lzU3RyaW5nKGVuZCkpIHtcbiAgICBpZiAofmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgZW5kID0gX3JlcGxhY2VSYW5kb20oZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcbiAgICAgIHB0ID0gX3BhcnNlUmVsYXRpdmUocGFyc2VkU3RhcnQsIGVuZCkgKyAoZ2V0VW5pdChwYXJzZWRTdGFydCkgfHwgMCk7XG5cbiAgICAgIGlmIChwdCB8fCBwdCA9PT0gMCkge1xuICAgICAgICAvLyB0byBhdm9pZCBpc05hTiwgbGlrZSBpZiBzb21lb25lIHBhc3NlcyBpbiBhIHZhbHVlIGxpa2UgXCIhPSB3aGF0ZXZlclwiXG4gICAgICAgIGVuZCA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0aW9uYWwgfHwgcGFyc2VkU3RhcnQgIT09IGVuZCB8fCBfZm9yY2VBbGxQcm9wVHdlZW5zKSB7XG4gICAgaWYgKCFpc05hTihwYXJzZWRTdGFydCAqIGVuZCkgJiYgZW5kICE9PSBcIlwiKSB7XG4gICAgICAvLyBmdW4gZmFjdDogYW55IG51bWJlciBtdWx0aXBsaWVkIGJ5IFwiXCIgaXMgZXZhbHVhdGVkIGFzIHRoZSBudW1iZXIgMCFcbiAgICAgIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCArcGFyc2VkU3RhcnQgfHwgMCwgZW5kIC0gKHBhcnNlZFN0YXJ0IHx8IDApLCB0eXBlb2YgY3VycmVudFZhbHVlID09PSBcImJvb2xlYW5cIiA/IF9yZW5kZXJCb29sZWFuIDogX3JlbmRlclBsYWluLCAwLCBzZXR0ZXIpO1xuICAgICAgZnVuY1BhcmFtICYmIChwdC5mcCA9IGZ1bmNQYXJhbSk7XG4gICAgICBtb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdGhpcywgdGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzLl9wdCA9IHB0O1xuICAgIH1cblxuICAgICFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcbiAgICByZXR1cm4gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0aGlzLCB0YXJnZXQsIHByb3AsIHBhcnNlZFN0YXJ0LCBlbmQsIHNldHRlciwgc3RyaW5nRmlsdGVyIHx8IF9jb25maWcuc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pO1xuICB9XG59LFxuICAgIC8vY3JlYXRlcyBhIGNvcHkgb2YgdGhlIHZhcnMgb2JqZWN0IGFuZCBwcm9jZXNzZXMgYW55IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyAocHV0dGluZyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBjb3B5KSBhcyB3ZWxsIGFzIHN0cmluZ3Mgd2l0aCBcInJhbmRvbSgpXCIgaW4gdGhlbS4gSXQgZG9lcyBOT1QgcHJvY2VzcyByZWxhdGl2ZSB2YWx1ZXMuXG5fcHJvY2Vzc1ZhcnMgPSBmdW5jdGlvbiBfcHJvY2Vzc1ZhcnModmFycywgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pIHtcbiAgX2lzRnVuY3Rpb24odmFycykgJiYgKHZhcnMgPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICBpZiAoIV9pc09iamVjdCh2YXJzKSB8fCB2YXJzLnN0eWxlICYmIHZhcnMubm9kZVR5cGUgfHwgX2lzQXJyYXkodmFycykgfHwgX2lzVHlwZWRBcnJheSh2YXJzKSkge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFycykgPyBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFycztcbiAgfVxuXG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiB2YXJzKSB7XG4gICAgY29weVtwXSA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzW3BdLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2NoZWNrUGx1Z2luID0gZnVuY3Rpb24gX2NoZWNrUGx1Z2luKHByb3BlcnR5LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykge1xuICB2YXIgcGx1Z2luLCBwdCwgcHRMb29rdXAsIGk7XG5cbiAgaWYgKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3Byb3BlcnR5XSgpKS5pbml0KHRhcmdldCwgcGx1Z2luLnJhd1ZhcnMgPyB2YXJzW3Byb3BlcnR5XSA6IF9wcm9jZXNzVmFycyh2YXJzW3Byb3BlcnR5XSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgIGlmICh0d2VlbiAhPT0gX3F1aWNrVHdlZW4pIHtcbiAgICAgIHB0TG9va3VwID0gdHdlZW4uX3B0TG9va3VwW3R3ZWVuLl90YXJnZXRzLmluZGV4T2YodGFyZ2V0KV07IC8vbm90ZTogd2UgY2FuJ3QgdXNlIHR3ZWVuLl9wdExvb2t1cFtpbmRleF0gYmVjYXVzZSBmb3Igc3RhZ2dlcmVkIHR3ZWVucywgdGhlIGluZGV4IGZyb20gdGhlIGZ1bGxUYXJnZXRzIGFycmF5IHdvbid0IG1hdGNoIHdoYXQgaXQgaXMgaW4gZWFjaCBpbmRpdmlkdWFsIHR3ZWVuIHRoYXQgc3Bhd25zIGZyb20gdGhlIHN0YWdnZXIuXG5cbiAgICAgIGkgPSBwbHVnaW4uX3Byb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBwdExvb2t1cFtwbHVnaW4uX3Byb3BzW2ldXSA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59LFxuICAgIF9vdmVyd3JpdGluZ1R3ZWVuLFxuICAgIC8vc3RvcmUgYSByZWZlcmVuY2UgdGVtcG9yYXJpbHkgc28gd2UgY2FuIGF2b2lkIG92ZXJ3cml0aW5nIGl0c2VsZi5cbl9mb3JjZUFsbFByb3BUd2VlbnMsXG4gICAgX2luaXRUd2VlbiA9IGZ1bmN0aW9uIF9pbml0VHdlZW4odHdlZW4sIHRpbWUsIHRUaW1lKSB7XG4gIHZhciB2YXJzID0gdHdlZW4udmFycyxcbiAgICAgIGVhc2UgPSB2YXJzLmVhc2UsXG4gICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICBsYXp5ID0gdmFycy5sYXp5LFxuICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgcnVuQmFja3dhcmRzID0gdmFycy5ydW5CYWNrd2FyZHMsXG4gICAgICB5b3lvRWFzZSA9IHZhcnMueW95b0Vhc2UsXG4gICAgICBrZXlmcmFtZXMgPSB2YXJzLmtleWZyYW1lcyxcbiAgICAgIGF1dG9SZXZlcnQgPSB2YXJzLmF1dG9SZXZlcnQsXG4gICAgICBkdXIgPSB0d2Vlbi5fZHVyLFxuICAgICAgcHJldlN0YXJ0QXQgPSB0d2Vlbi5fc3RhcnRBdCxcbiAgICAgIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcbiAgICAgIHBhcmVudCA9IHR3ZWVuLnBhcmVudCxcbiAgICAgIGZ1bGxUYXJnZXRzID0gcGFyZW50ICYmIHBhcmVudC5kYXRhID09PSBcIm5lc3RlZFwiID8gcGFyZW50LnZhcnMudGFyZ2V0cyA6IHRhcmdldHMsXG4gICAgICBhdXRvT3ZlcndyaXRlID0gdHdlZW4uX292ZXJ3cml0ZSA9PT0gXCJhdXRvXCIgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgICB0bCA9IHR3ZWVuLnRpbWVsaW5lLFxuICAgICAgY2xlYW5WYXJzLFxuICAgICAgaSxcbiAgICAgIHAsXG4gICAgICBwdCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGhhc1ByaW9yaXR5LFxuICAgICAgZ3NEYXRhLFxuICAgICAgaGFybmVzcyxcbiAgICAgIHBsdWdpbixcbiAgICAgIHB0TG9va3VwLFxuICAgICAgaW5kZXgsXG4gICAgICBoYXJuZXNzVmFycyxcbiAgICAgIG92ZXJ3cml0dGVuO1xuICB0bCAmJiAoIWtleWZyYW1lcyB8fCAhZWFzZSkgJiYgKGVhc2UgPSBcIm5vbmVcIik7XG4gIHR3ZWVuLl9lYXNlID0gX3BhcnNlRWFzZShlYXNlLCBfZGVmYXVsdHMuZWFzZSk7XG4gIHR3ZWVuLl95RWFzZSA9IHlveW9FYXNlID8gX2ludmVydEVhc2UoX3BhcnNlRWFzZSh5b3lvRWFzZSA9PT0gdHJ1ZSA/IGVhc2UgOiB5b3lvRWFzZSwgX2RlZmF1bHRzLmVhc2UpKSA6IDA7XG5cbiAgaWYgKHlveW9FYXNlICYmIHR3ZWVuLl95b3lvICYmICF0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy90aGVyZSBtdXN0IGhhdmUgYmVlbiBhIHBhcmVudCB0aW1lbGluZSB3aXRoIHlveW86dHJ1ZSB0aGF0IGlzIGN1cnJlbnRseSBpbiBpdHMgeW95byBwaGFzZSwgc28gZmxpcCB0aGUgZWFzZXMuXG4gICAgeW95b0Vhc2UgPSB0d2Vlbi5feUVhc2U7XG4gICAgdHdlZW4uX3lFYXNlID0gdHdlZW4uX2Vhc2U7XG4gICAgdHdlZW4uX2Vhc2UgPSB5b3lvRWFzZTtcbiAgfVxuXG4gIHR3ZWVuLl9mcm9tID0gIXRsICYmICEhdmFycy5ydW5CYWNrd2FyZHM7IC8vbmVzdGVkIHRpbWVsaW5lcyBzaG91bGQgbmV2ZXIgcnVuIGJhY2t3YXJkcyAtIHRoZSBiYWNrd2FyZHMtbmVzcyBpcyBpbiB0aGUgY2hpbGQgdHdlZW5zLlxuXG4gIGlmICghdGwgfHwga2V5ZnJhbWVzICYmICF2YXJzLnN0YWdnZXIpIHtcbiAgICAvL2lmIHRoZXJlJ3MgYW4gaW50ZXJuYWwgdGltZWxpbmUsIHNraXAgYWxsIHRoZSBwYXJzaW5nIGJlY2F1c2Ugd2UgcGFzc2VkIHRoYXQgdGFzayBkb3duIHRoZSBjaGFpbi5cbiAgICBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMDtcbiAgICBoYXJuZXNzVmFycyA9IGhhcm5lc3MgJiYgdmFyc1toYXJuZXNzLnByb3BdOyAvL3NvbWVvbmUgbWF5IG5lZWQgdG8gc3BlY2lmeSBDU1Mtc3BlY2lmaWMgdmFsdWVzIEFORCBub24tQ1NTIHZhbHVlcywgbGlrZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gXCJ4XCIgcHJvcGVydHkgcGx1cyBpdCdzIGEgc3RhbmRhcmQgRE9NIGVsZW1lbnQuIFdlIGFsbG93IHBlb3BsZSB0byBkaXN0aW5ndWlzaCBieSB3cmFwcGluZyBwbHVnaW4tc3BlY2lmaWMgc3R1ZmYgaW4gYSBjc3M6e30gb2JqZWN0IGZvciBleGFtcGxlLlxuXG4gICAgY2xlYW5WYXJzID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3Jlc2VydmVkUHJvcHMpO1xuXG4gICAgaWYgKHByZXZTdGFydEF0KSB7XG4gICAgICBwcmV2U3RhcnRBdC5felRpbWUgPCAwICYmIHByZXZTdGFydEF0LnByb2dyZXNzKDEpOyAvLyBpbiBjYXNlIGl0J3MgYSBsYXp5IHN0YXJ0QXQgdGhhdCBoYXNuJ3QgcmVuZGVyZWQgeWV0LlxuXG4gICAgICB0aW1lIDwgMCAmJiBydW5CYWNrd2FyZHMgJiYgaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0ID8gcHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSA6IHByZXZTdGFydEF0LnJldmVydChydW5CYWNrd2FyZHMgJiYgZHVyID8gX3JldmVydENvbmZpZ05vS2lsbCA6IF9zdGFydEF0UmV2ZXJ0Q29uZmlnKTsgLy8gaWYgaXQncyBhIFwic3RhcnRBdFwiIChub3QgXCJmcm9tKClcIiBvciBydW5CYWNrd2FyZHM6IHRydWUpLCB3ZSBvbmx5IG5lZWQgdG8gZG8gYSBzaGFsbG93IHJldmVydCAoa2VlcCB0cmFuc2Zvcm1zIGNhY2hlZCBpbiBDU1NQbHVnaW4pXG4gICAgICAvLyBkb24ndCBqdXN0IF9yZW1vdmVGcm9tUGFyZW50KHByZXZTdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSkpIGJlY2F1c2UgdGhhdCdsbCBsZWF2ZSBpbmxpbmUgc3R5bGVzLiBXZSdyZSBjcmVhdGluZyBhIG5ldyBfc3RhcnRBdCBmb3IgXCJzdGFydEF0XCIgdHdlZW5zIHRoYXQgcmUtY2FwdHVyZSB0aGluZ3MgdG8gZW5zdXJlIHRoYXQgaWYgdGhlIHByZS10d2VlbiB2YWx1ZXMgY2hhbmdlZCBzaW5jZSB0aGUgdHdlZW4gd2FzIGNyZWF0ZWQsIHRoZXkncmUgcmVjb3JkZWQuXG5cbiAgICAgIHByZXZTdGFydEF0Ll9sYXp5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXG4gICAgICAgIGxhenk6ICFwcmV2U3RhcnRBdCAmJiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgc3RhcnRBdDogbnVsbCxcbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIG9uVXBkYXRlOiBvblVwZGF0ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhZ2dlcjogMFxuICAgICAgfSwgc3RhcnRBdCkpKTsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIGZyb20sIHRvKS5mcm9tVG8oZSwgdG8sIGZyb20pO1xuXG5cbiAgICAgIHR3ZWVuLl9zdGFydEF0Ll9kcCA9IDA7IC8vIGRvbid0IGFsbG93IGl0IHRvIGdldCBwdXQgYmFjayBpbnRvIHJvb3QgdGltZWxpbmUhIExpa2Ugd2hlbiByZXZlcnQoKSBpcyBjYWxsZWQgYW5kIHRvdGFsVGltZSgpIGdldHMgc2V0LlxuXG4gICAgICB0d2Vlbi5fc3RhcnRBdC5fc2F0ID0gdHdlZW47IC8vIHVzZWQgaW4gZ2xvYmFsVGltZSgpLiBfc2F0IHN0YW5kcyBmb3IgX3N0YXJ0QXRUd2VlblxuXG4gICAgICB0aW1lIDwgMCAmJiAoX3JldmVydGluZyB8fCAhaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0KSAmJiB0d2Vlbi5fc3RhcnRBdC5yZXZlcnQoX3JldmVydENvbmZpZ05vS2lsbCk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgdHdlZW4uXG5cbiAgICAgIGlmIChpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgaWYgKGR1ciAmJiB0aW1lIDw9IDAgJiYgdFRpbWUgPD0gMCkge1xuICAgICAgICAgIC8vIGNoZWNrIHRUaW1lIGhlcmUgYmVjYXVzZSBpbiB0aGUgY2FzZSBvZiBhIHlveW8gdHdlZW4gd2hvc2UgcGxheWhlYWQgZ2V0cyBwdXNoZWQgdG8gdGhlIGVuZCBsaWtlIHR3ZWVuLnByb2dyZXNzKDEpLCB3ZSBzaG91bGQgYWxsb3cgaXQgdGhyb3VnaCBzbyB0aGF0IHRoZSBvbkNvbXBsZXRlIGdldHMgZmlyZWQgcHJvcGVybHkuXG4gICAgICAgICAgdGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG4gICAgICAgICAgcmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChydW5CYWNrd2FyZHMgJiYgZHVyKSB7XG4gICAgICAvL2Zyb20oKSB0d2VlbnMgbXVzdCBiZSBoYW5kbGVkIHVuaXF1ZWx5OiB0aGVpciBiZWdpbm5pbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQgYnV0IHdlIGRvbid0IHdhbnQgb3ZlcndyaXRpbmcgdG8gb2NjdXIgeWV0ICh3aGVuIHRpbWUgaXMgc3RpbGwgMCkuIFdhaXQgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucyBiZWZvcmUgZG9pbmcgYWxsIHRoZSByb3V0aW5lcyBsaWtlIG92ZXJ3cml0aW5nLiBBdCB0aGF0IHRpbWUsIHdlIHNob3VsZCByZW5kZXIgYXQgdGhlIEVORCBvZiB0aGUgdHdlZW4gdG8gZW5zdXJlIHRoYXQgdGhpbmdzIGluaXRpYWxpemUgY29ycmVjdGx5IChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBnbyBiYWNrd2FyZHMpXG4gICAgICBpZiAoIXByZXZTdGFydEF0KSB7XG4gICAgICAgIHRpbWUgJiYgKGltbWVkaWF0ZVJlbmRlciA9IGZhbHNlKTsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblxuICAgICAgICBwID0gX3NldERlZmF1bHRzKHtcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGRhdGE6IFwiaXNGcm9tU3RhcnRcIixcbiAgICAgICAgICAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cbiAgICAgICAgICBsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgIXByZXZTdGFydEF0ICYmIF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICAgIGltbWVkaWF0ZVJlbmRlcjogaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICAgIC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcbiAgICAgICAgICBzdGFnZ2VyOiAwLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50IC8vZW5zdXJlcyB0aGF0IG5lc3RlZCB0d2VlbnMgdGhhdCBoYWQgYSBzdGFnZ2VyIGFyZSBoYW5kbGVkIHByb3Blcmx5LCBsaWtlIGdzYXAuZnJvbShcIi5jbGFzc1wiLCB7eTogZ3NhcC51dGlscy53cmFwKFstMTAwLDEwMF0pLCBzdGFnZ2VyOiAwLjV9KVxuXG4gICAgICAgIH0sIGNsZWFuVmFycyk7XG4gICAgICAgIGhhcm5lc3NWYXJzICYmIChwW2hhcm5lc3MucHJvcF0gPSBoYXJuZXNzVmFycyk7IC8vIGluIGNhc2Ugc29tZW9uZSBkb2VzIHNvbWV0aGluZyBsaWtlIC5mcm9tKC4uLiwge2Nzczp7fX0pXG5cbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgcCkpO1xuXG4gICAgICAgIHR3ZWVuLl9zdGFydEF0Ll9kcCA9IDA7IC8vIGRvbid0IGFsbG93IGl0IHRvIGdldCBwdXQgYmFjayBpbnRvIHJvb3QgdGltZWxpbmUhXG5cbiAgICAgICAgdHdlZW4uX3N0YXJ0QXQuX3NhdCA9IHR3ZWVuOyAvLyB1c2VkIGluIGdsb2JhbFRpbWUoKVxuXG4gICAgICAgIHRpbWUgPCAwICYmIChfcmV2ZXJ0aW5nID8gdHdlZW4uX3N0YXJ0QXQucmV2ZXJ0KF9yZXZlcnRDb25maWdOb0tpbGwpIDogdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSk7XG4gICAgICAgIHR3ZWVuLl96VGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKCFpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgICBfaW5pdFR3ZWVuKHR3ZWVuLl9zdGFydEF0LCBfdGlueU51bSwgX3RpbnlOdW0pOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cbiAgICAgICAgfSBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHR3ZWVuLl9wdCA9IHR3ZWVuLl9wdENhY2hlID0gMDtcbiAgICBsYXp5ID0gZHVyICYmIF9pc05vdEZhbHNlKGxhenkpIHx8IGxhenkgJiYgIWR1cjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgZ3NEYXRhID0gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRhcmdldHMpW2ldLl9nc2FwO1xuICAgICAgdHdlZW4uX3B0TG9va3VwW2ldID0gcHRMb29rdXAgPSB7fTtcbiAgICAgIF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gJiYgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cbiAgICAgIGluZGV4ID0gZnVsbFRhcmdldHMgPT09IHRhcmdldHMgPyBpIDogZnVsbFRhcmdldHMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICBpZiAoaGFybmVzcyAmJiAocGx1Z2luID0gbmV3IGhhcm5lc3MoKSkuaW5pdCh0YXJnZXQsIGhhcm5lc3NWYXJzIHx8IGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCBmdWxsVGFyZ2V0cykgIT09IGZhbHNlKSB7XG4gICAgICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcGx1Z2luLm5hbWUsIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgICAgICBwbHVnaW4uX3Byb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBwdExvb2t1cFtuYW1lXSA9IHB0O1xuICAgICAgICB9KTtcblxuICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFybmVzcyB8fCBoYXJuZXNzVmFycykge1xuICAgICAgICBmb3IgKHAgaW4gY2xlYW5WYXJzKSB7XG4gICAgICAgICAgaWYgKF9wbHVnaW5zW3BdICYmIChwbHVnaW4gPSBfY2hlY2tQbHVnaW4ocCwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgZnVsbFRhcmdldHMpKSkge1xuICAgICAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdExvb2t1cFtwXSA9IHB0ID0gX2FkZFByb3BUd2Vlbi5jYWxsKHR3ZWVuLCB0YXJnZXQsIHAsIFwiZ2V0XCIsIGNsZWFuVmFyc1twXSwgaW5kZXgsIGZ1bGxUYXJnZXRzLCAwLCB2YXJzLnN0cmluZ0ZpbHRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHR3ZWVuLl9vcCAmJiB0d2Vlbi5fb3BbaV0gJiYgdHdlZW4ua2lsbCh0YXJnZXQsIHR3ZWVuLl9vcFtpXSk7XG5cbiAgICAgIGlmIChhdXRvT3ZlcndyaXRlICYmIHR3ZWVuLl9wdCkge1xuICAgICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IHR3ZWVuO1xuXG4gICAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0LCBwdExvb2t1cCwgdHdlZW4uZ2xvYmFsVGltZSh0aW1lKSk7IC8vIG1ha2Ugc3VyZSB0aGUgb3ZlcndyaXRpbmcgZG9lc24ndCBvdmVyd3JpdGUgVEhJUyB0d2VlbiEhIVxuXG5cbiAgICAgICAgb3ZlcndyaXR0ZW4gPSAhdHdlZW4ucGFyZW50O1xuICAgICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHR3ZWVuLl9wdCAmJiBsYXp5ICYmIChfbGF6eUxvb2t1cFtnc0RhdGEuaWRdID0gMSk7XG4gICAgfVxuXG4gICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0d2Vlbik7XG4gICAgdHdlZW4uX29uSW5pdCAmJiB0d2Vlbi5fb25Jbml0KHR3ZWVuKTsgLy9wbHVnaW5zIGxpa2UgUm91bmRQcm9wcyBtdXN0IHdhaXQgdW50aWwgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIGFyZSBpbnN0YW50aWF0ZWQuIEluIHRoZSBwbHVnaW4ncyBpbml0KCkgZnVuY3Rpb24sIGl0IHNldHMgdGhlIF9vbkluaXQgb24gdGhlIHR3ZWVuIGluc3RhbmNlLiBNYXkgbm90IGJlIHByZXR0eS9pbnR1aXRpdmUsIGJ1dCBpdCdzIGZhc3QgYW5kIGtlZXBzIGZpbGUgc2l6ZSBkb3duLlxuICB9XG5cbiAgdHdlZW4uX29uVXBkYXRlID0gb25VcGRhdGU7XG4gIHR3ZWVuLl9pbml0dGVkID0gKCF0d2Vlbi5fb3AgfHwgdHdlZW4uX3B0KSAmJiAhb3ZlcndyaXR0ZW47IC8vIGlmIG92ZXJ3cml0dGVuUHJvcHMgcmVzdWx0ZWQgaW4gdGhlIGVudGlyZSB0d2VlbiBiZWluZyBraWxsZWQsIGRvIE5PVCBmbGFnIGl0IGFzIGluaXR0ZWQgb3IgZWxzZSBpdCBtYXkgcmVuZGVyIGZvciBvbmUgdGljay5cblxuICBrZXlmcmFtZXMgJiYgdGltZSA8PSAwICYmIHRsLnJlbmRlcihfYmlnTnVtLCB0cnVlLCB0cnVlKTsgLy8gaWYgdGhlcmUncyBhIDAlIGtleWZyYW1lLCBpdCdsbCByZW5kZXIgaW4gdGhlIFwiYmVmb3JlXCIgc3RhdGUgZm9yIGFueSBzdGFnZ2VyZWQvZGVsYXllZCBhbmltYXRpb25zIHRodXMgd2hlbiB0aGUgZm9sbG93aW5nIHR3ZWVuIGluaXRpYWxpemVzLCBpdCdsbCB1c2UgdGhlIFwiYmVmb3JlXCIgc3RhdGUgaW5zdGVhZCBvZiB0aGUgXCJhZnRlclwiIHN0YXRlIGFzIHRoZSBpbml0aWFsIHZhbHVlcy5cbn0sXG4gICAgX3VwZGF0ZVByb3BUd2VlbnMgPSBmdW5jdGlvbiBfdXBkYXRlUHJvcFR3ZWVucyh0d2VlbiwgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSwgc2tpcFJlY3Vyc2lvbikge1xuICB2YXIgcHRDYWNoZSA9ICh0d2Vlbi5fcHQgJiYgdHdlZW4uX3B0Q2FjaGUgfHwgKHR3ZWVuLl9wdENhY2hlID0ge30pKVtwcm9wZXJ0eV0sXG4gICAgICBwdCxcbiAgICAgIHJvb3RQVCxcbiAgICAgIGxvb2t1cCxcbiAgICAgIGk7XG5cbiAgaWYgKCFwdENhY2hlKSB7XG4gICAgcHRDYWNoZSA9IHR3ZWVuLl9wdENhY2hlW3Byb3BlcnR5XSA9IFtdO1xuICAgIGxvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cDtcbiAgICBpID0gdHdlZW4uX3RhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHQgPSBsb29rdXBbaV1bcHJvcGVydHldO1xuXG4gICAgICBpZiAocHQgJiYgcHQuZCAmJiBwdC5kLl9wdCkge1xuICAgICAgICAvLyBpdCdzIGEgcGx1Z2luLCBzbyBmaW5kIHRoZSBuZXN0ZWQgUHJvcFR3ZWVuXG4gICAgICAgIHB0ID0gcHQuZC5fcHQ7XG5cbiAgICAgICAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3BlcnR5ICYmIHB0LmZwICE9PSBwcm9wZXJ0eSkge1xuICAgICAgICAgIC8vIFwiZnBcIiBpcyBmdW5jdGlvblBhcmFtIGZvciB0aGluZ3MgbGlrZSBzZXR0aW5nIENTUyB2YXJpYWJsZXMgd2hpY2ggcmVxdWlyZSAuc2V0UHJvcGVydHkoXCItLXZhci1uYW1lXCIsIHZhbHVlKVxuICAgICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwdCkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIHRoYXQgcHJvcGVydHksIHNvIHdlIG11c3QgRk9SQ0Ugb25lIHRvIGJlIGNyZWF0ZWQgYW5kIGRpdGNoIG91dCBvZiB0aGlzXG4gICAgICAgIC8vIGlmIHRoZSB0d2VlbiBoYXMgb3RoZXIgcHJvcGVydGllcyB0aGF0IGFscmVhZHkgcmVuZGVyZWQgYXQgbmV3IHBvc2l0aW9ucywgd2UnZCBub3JtYWxseSBoYXZlIHRvIHJld2luZCB0byBwdXQgdGhlbSBiYWNrIGxpa2UgdHdlZW4ucmVuZGVyKDAsIHRydWUpIGJlZm9yZSBmb3JjaW5nIGFuIF9pbml0VHdlZW4oKSwgYnV0IHRoYXQgY2FuIGNyZWF0ZSBhbm90aGVyIGVkZ2UgY2FzZSBsaWtlIHR3ZWVuaW5nIGEgdGltZWxpbmUncyBwcm9ncmVzcyB3b3VsZCB0cmlnZ2VyIG9uVXBkYXRlcyB0byBmaXJlIHdoaWNoIGNvdWxkIG1vdmUgb3RoZXIgdGhpbmdzIGFyb3VuZC4gSXQncyBiZXR0ZXIgdG8ganVzdCBpbmZvcm0gdXNlcnMgdGhhdCAucmVzZXRUbygpIHNob3VsZCBPTkxZIGJlIHVzZWQgZm9yIHR3ZWVucyB0aGF0IGFscmVhZHkgaGF2ZSB0aGF0IHByb3BlcnR5LiBGb3IgZXhhbXBsZSwgeW91IGNhbid0IGdzYXAudG8oLi4ueyB5OiAwIH0pIGFuZCB0aGVuIHR3ZWVuLnJlc3RUbyhcInhcIiwgMjAwKSBmb3IgZXhhbXBsZS5cbiAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDE7IC8vIG90aGVyd2lzZSwgd2hlbiB3ZSBfYWRkUHJvcFR3ZWVuKCkgYW5kIGl0IGZpbmRzIG5vIGNoYW5nZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcywgaXQgc2tpcHMgY3JlYXRpbmcgYSBQcm9wVHdlZW4gKGZvciBlZmZpY2llbmN5Li4ud2h5IHR3ZWVuIHdoZW4gdGhlcmUncyBubyBkaWZmZXJlbmNlPykgYnV0IGluIHRoaXMgY2FzZSB3ZSBORUVEIHRoYXQgUHJvcFR3ZWVuIGNyZWF0ZWQgc28gd2UgY2FuIGVkaXQgaXQuXG5cbiAgICAgICAgdHdlZW4udmFyc1twcm9wZXJ0eV0gPSBcIis9MFwiO1xuXG4gICAgICAgIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpO1xuXG4gICAgICAgIF9mb3JjZUFsbFByb3BUd2VlbnMgPSAwO1xuICAgICAgICByZXR1cm4gc2tpcFJlY3Vyc2lvbiA/IF93YXJuKHByb3BlcnR5ICsgXCIgbm90IGVsaWdpYmxlIGZvciByZXNldFwiKSA6IDE7IC8vIGlmIHNvbWVvbmUgdHJpZXMgdG8gZG8gYSBxdWlja1RvKCkgb24gYSBzcGVjaWFsIHByb3BlcnR5IGxpa2UgYm9yZGVyUmFkaXVzIHdoaWNoIG11c3QgZ2V0IHNwbGl0IGludG8gNCBkaWZmZXJlbnQgcHJvcGVydGllcywgdGhhdCdzIG5vdCBlbGlnaWJsZSBmb3IgLnJlc2V0VG8oKS5cbiAgICAgIH1cblxuICAgICAgcHRDYWNoZS5wdXNoKHB0KTtcbiAgICB9XG4gIH1cblxuICBpID0gcHRDYWNoZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHJvb3RQVCA9IHB0Q2FjaGVbaV07XG4gICAgcHQgPSByb290UFQuX3B0IHx8IHJvb3RQVDsgLy8gY29tcGxleCB2YWx1ZXMgbWF5IGhhdmUgbmVzdGVkIFByb3BUd2VlbnMuIFdlIG9ubHkgYWNjb21tb2RhdGUgdGhlIEZJUlNUIHZhbHVlLlxuXG4gICAgcHQucyA9IChzdGFydCB8fCBzdGFydCA9PT0gMCkgJiYgIXN0YXJ0SXNSZWxhdGl2ZSA/IHN0YXJ0IDogcHQucyArIChzdGFydCB8fCAwKSArIHJhdGlvICogcHQuYztcbiAgICBwdC5jID0gdmFsdWUgLSBwdC5zO1xuICAgIHJvb3RQVC5lICYmIChyb290UFQuZSA9IF9yb3VuZCh2YWx1ZSkgKyBnZXRVbml0KHJvb3RQVC5lKSk7IC8vIG1haW5seSBmb3IgQ1NTUGx1Z2luIChlbmQgdmFsdWUpXG5cbiAgICByb290UFQuYiAmJiAocm9vdFBULmIgPSBwdC5zICsgZ2V0VW5pdChyb290UFQuYikpOyAvLyAoYmVnaW5uaW5nIHZhbHVlKVxuICB9XG59LFxuICAgIF9hZGRBbGlhc2VzVG9WYXJzID0gZnVuY3Rpb24gX2FkZEFsaWFzZXNUb1ZhcnModGFyZ2V0cywgdmFycykge1xuICB2YXIgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDAsXG4gICAgICBwcm9wZXJ0eUFsaWFzZXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyxcbiAgICAgIGNvcHksXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIGFsaWFzZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICByZXR1cm4gdmFycztcbiAgfVxuXG4gIGNvcHkgPSBfbWVyZ2Uoe30sIHZhcnMpO1xuXG4gIGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICBpZiAocCBpbiBjb3B5KSB7XG4gICAgICBhbGlhc2VzID0gcHJvcGVydHlBbGlhc2VzW3BdLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBhbGlhc2VzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb3B5W2FsaWFzZXNbaV1dID0gY29weVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgLy8gcGFyc2VzIG11bHRpcGxlIGZvcm1hdHMsIGxpa2Uge1wiMCVcIjoge3g6IDEwMH0sIHtcIjUwJVwiOiB7eDogLTIwfX0gYW5kIHsgeDoge1wiMCVcIjogMTAwLCBcIjUwJVwiOiAtMjB9IH0sIGFuZCBhbiBcImVhc2VcIiBjYW4gYmUgc2V0IG9uIGFueSBvYmplY3QuIFdlIHBvcHVsYXRlIGFuIFwiYWxsUHJvcHNcIiBvYmplY3Qgd2l0aCBhbiBBcnJheSBmb3IgZWFjaCBwcm9wZXJ0eSwgbGlrZSB7eDogW3t9LCB7fV0sIHk6W3t9LCB7fV19IHdpdGggZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eSB0d2Vlbi4gVGhlIG9iamVjdHMgaGF2ZSBhIFwidFwiICh0aW1lKSwgXCJ2XCIsICh2YWx1ZSksIGFuZCBcImVcIiAoZWFzZSkgcHJvcGVydHkuIFRoaXMgYWxsb3dzIHVzIHRvIHBpZWNlIHRvZ2V0aGVyIGEgdGltZWxpbmUgbGF0ZXIuXG5fcGFyc2VLZXlmcmFtZSA9IGZ1bmN0aW9uIF9wYXJzZUtleWZyYW1lKHByb3AsIG9iaiwgYWxsUHJvcHMsIGVhc2VFYWNoKSB7XG4gIHZhciBlYXNlID0gb2JqLmVhc2UgfHwgZWFzZUVhY2ggfHwgXCJwb3dlcjEuaW5PdXRcIixcbiAgICAgIHAsXG4gICAgICBhO1xuXG4gIGlmIChfaXNBcnJheShvYmopKSB7XG4gICAgYSA9IGFsbFByb3BzW3Byb3BdIHx8IChhbGxQcm9wc1twcm9wXSA9IFtdKTsgLy8gdCA9IHRpbWUgKG91dCBvZiAxMDApLCB2ID0gdmFsdWUsIGUgPSBlYXNlXG5cbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgIHJldHVybiBhLnB1c2goe1xuICAgICAgICB0OiBpIC8gKG9iai5sZW5ndGggLSAxKSAqIDEwMCxcbiAgICAgICAgdjogdmFsdWUsXG4gICAgICAgIGU6IGVhc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZvciAocCBpbiBvYmopIHtcbiAgICAgIGEgPSBhbGxQcm9wc1twXSB8fCAoYWxsUHJvcHNbcF0gPSBbXSk7XG4gICAgICBwID09PSBcImVhc2VcIiB8fCBhLnB1c2goe1xuICAgICAgICB0OiBwYXJzZUZsb2F0KHByb3ApLFxuICAgICAgICB2OiBvYmpbcF0sXG4gICAgICAgIGU6IGVhc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfcGFyc2VGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VGdW5jT3JTdHJpbmcodmFsdWUsIHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgOiBfaXNTdHJpbmcodmFsdWUpICYmIH52YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSA/IF9yZXBsYWNlUmFuZG9tKHZhbHVlKSA6IHZhbHVlO1xufSxcbiAgICBfc3RhZ2dlclR3ZWVuUHJvcHMgPSBfY2FsbGJhY2tOYW1lcyArIFwicmVwZWF0LHJlcGVhdERlbGF5LHlveW8scmVwZWF0UmVmcmVzaCx5b3lvRWFzZSxhdXRvUmV2ZXJ0XCIsXG4gICAgX3N0YWdnZXJQcm9wc1RvU2tpcCA9IHt9O1xuXG5fZm9yRWFjaE5hbWUoX3N0YWdnZXJUd2VlblByb3BzICsgXCIsaWQsc3RhZ2dlcixkZWxheSxkdXJhdGlvbixwYXVzZWQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX3N0YWdnZXJQcm9wc1RvU2tpcFtuYW1lXSA9IDE7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uMikge1xuICBfaW5oZXJpdHNMb29zZShUd2VlbiwgX0FuaW1hdGlvbjIpO1xuXG4gIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uLCBza2lwSW5oZXJpdCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBpZiAodHlwZW9mIHZhcnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHBvc2l0aW9uLmR1cmF0aW9uID0gdmFycztcbiAgICAgIHZhcnMgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfQW5pbWF0aW9uMi5jYWxsKHRoaXMsIHNraXBJbmhlcml0ID8gdmFycyA6IF9pbmhlcml0RGVmYXVsdHModmFycykpIHx8IHRoaXM7XG4gICAgdmFyIF90aGlzMyR2YXJzID0gX3RoaXMzLnZhcnMsXG4gICAgICAgIGR1cmF0aW9uID0gX3RoaXMzJHZhcnMuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX3RoaXMzJHZhcnMuZGVsYXksXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF90aGlzMyR2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgc3RhZ2dlciA9IF90aGlzMyR2YXJzLnN0YWdnZXIsXG4gICAgICAgIG92ZXJ3cml0ZSA9IF90aGlzMyR2YXJzLm92ZXJ3cml0ZSxcbiAgICAgICAga2V5ZnJhbWVzID0gX3RoaXMzJHZhcnMua2V5ZnJhbWVzLFxuICAgICAgICBkZWZhdWx0cyA9IF90aGlzMyR2YXJzLmRlZmF1bHRzLFxuICAgICAgICBzY3JvbGxUcmlnZ2VyID0gX3RoaXMzJHZhcnMuc2Nyb2xsVHJpZ2dlcixcbiAgICAgICAgeW95b0Vhc2UgPSBfdGhpczMkdmFycy55b3lvRWFzZSxcbiAgICAgICAgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgICBwYXJzZWRUYXJnZXRzID0gKF9pc0FycmF5KHRhcmdldHMpIHx8IF9pc1R5cGVkQXJyYXkodGFyZ2V0cykgPyBfaXNOdW1iZXIodGFyZ2V0c1swXSkgOiBcImxlbmd0aFwiIGluIHZhcnMpID8gW3RhcmdldHNdIDogdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgdGwsXG4gICAgICAgIGksXG4gICAgICAgIGNvcHksXG4gICAgICAgIGwsXG4gICAgICAgIHAsXG4gICAgICAgIGN1clRhcmdldCxcbiAgICAgICAgc3RhZ2dlckZ1bmMsXG4gICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZTtcbiAgICBfdGhpczMuX3RhcmdldHMgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aCA/IF9oYXJuZXNzKHBhcnNlZFRhcmdldHMpIDogX3dhcm4oXCJHU0FQIHRhcmdldCBcIiArIHRhcmdldHMgKyBcIiBub3QgZm91bmQuIGh0dHBzOi8vZ3NhcC5jb21cIiwgIV9jb25maWcubnVsbFRhcmdldFdhcm4pIHx8IFtdO1xuICAgIF90aGlzMy5fcHRMb29rdXAgPSBbXTsgLy9Qcm9wVHdlZW4gbG9va3VwLiBBbiBhcnJheSBjb250YWluaW5nIGFuIG9iamVjdCBmb3IgZWFjaCB0YXJnZXQsIGhhdmluZyBrZXlzIGZvciBlYWNoIHR3ZWVuaW5nIHByb3BlcnR5XG5cbiAgICBfdGhpczMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcblxuICAgIGlmIChrZXlmcmFtZXMgfHwgc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgIHZhcnMgPSBfdGhpczMudmFycztcbiAgICAgIHRsID0gX3RoaXMzLnRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgICAgICAgZGF0YTogXCJuZXN0ZWRcIixcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzIHx8IHt9LFxuICAgICAgICB0YXJnZXRzOiBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQudmFycy50YXJnZXRzIDogcGFyc2VkVGFyZ2V0c1xuICAgICAgfSk7IC8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIHRhcmdldHMgYmVjYXVzZSBmb3Igc3RhZ2dlcnMgYW5kIGtleWZyYW1lcywgd2UgZW5kIHVwIGNyZWF0aW5nIGFuIGluZGl2aWR1YWwgdHdlZW4gZm9yIGVhY2ggYnV0IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBuZWVkIHRvIGtub3cgdGhlIGluZGV4IGFuZCB0aGUgd2hvbGUgQXJyYXkgb2YgdGFyZ2V0cy5cblxuICAgICAgdGwua2lsbCgpO1xuICAgICAgdGwucGFyZW50ID0gdGwuX2RwID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuICAgICAgdGwuX3N0YXJ0ID0gMDtcblxuICAgICAgaWYgKHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICAgIGwgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcbiAgICAgICAgc3RhZ2dlckZ1bmMgPSBzdGFnZ2VyICYmIGRpc3RyaWJ1dGUoc3RhZ2dlcik7XG5cbiAgICAgICAgaWYgKF9pc09iamVjdChzdGFnZ2VyKSkge1xuICAgICAgICAgIC8vdXNlcnMgY2FuIHBhc3MgaW4gY2FsbGJhY2tzIGxpa2Ugb25TdGFydC9vbkNvbXBsZXRlIGluIHRoZSBzdGFnZ2VyIG9iamVjdC4gVGhlc2Ugc2hvdWxkIGZpcmUgd2l0aCBlYWNoIGluZGl2aWR1YWwgdHdlZW4uXG4gICAgICAgICAgZm9yIChwIGluIHN0YWdnZXIpIHtcbiAgICAgICAgICAgIGlmICh+X3N0YWdnZXJUd2VlblByb3BzLmluZGV4T2YocCkpIHtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlIHx8IChzdGFnZ2VyVmFyc1RvTWVyZ2UgPSB7fSk7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZVtwXSA9IHN0YWdnZXJbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvcHkgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfc3RhZ2dlclByb3BzVG9Ta2lwKTtcbiAgICAgICAgICBjb3B5LnN0YWdnZXIgPSAwO1xuICAgICAgICAgIHlveW9FYXNlICYmIChjb3B5LnlveW9FYXNlID0geW95b0Vhc2UpO1xuICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSAmJiBfbWVyZ2UoY29weSwgc3RhZ2dlclZhcnNUb01lcmdlKTtcbiAgICAgICAgICBjdXJUYXJnZXQgPSBwYXJzZWRUYXJnZXRzW2ldOyAvL2Rvbid0IGp1c3QgY29weSBkdXJhdGlvbiBvciBkZWxheSBiZWNhdXNlIGlmIHRoZXkncmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24sIHdlJ2QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBfaXNGdW5jT3JTdHJpbmcoKSB3b3VsZCBldmFsdWF0ZSBhcyB0cnVlIGluIHRoZSBjaGlsZCB0d2VlbnMsIGVudGVyaW5nIHRoaXMgbG9vcCwgZXRjLiBTbyB3ZSBwYXJzZSB0aGUgdmFsdWUgc3RyYWlnaHQgZnJvbSB2YXJzIGFuZCBkZWZhdWx0IHRvIDAuXG5cbiAgICAgICAgICBjb3B5LmR1cmF0aW9uID0gK19wYXJzZUZ1bmNPclN0cmluZyhkdXJhdGlvbiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpO1xuICAgICAgICAgIGNvcHkuZGVsYXkgPSAoK19wYXJzZUZ1bmNPclN0cmluZyhkZWxheSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIHx8IDApIC0gX3RoaXMzLl9kZWxheTtcblxuICAgICAgICAgIGlmICghc3RhZ2dlciAmJiBsID09PSAxICYmIGNvcHkuZGVsYXkpIHtcbiAgICAgICAgICAgIC8vIGlmIHNvbWVvbmUgZG9lcyBkZWxheTpcInJhbmRvbSgxLCA1KVwiLCByZXBlYXQ6LTEsIGZvciBleGFtcGxlLCB0aGUgZGVsYXkgc2hvdWxkbid0IGJlIGluc2lkZSB0aGUgcmVwZWF0LlxuICAgICAgICAgICAgX3RoaXMzLl9kZWxheSA9IGRlbGF5ID0gY29weS5kZWxheTtcbiAgICAgICAgICAgIF90aGlzMy5fc3RhcnQgKz0gZGVsYXk7XG4gICAgICAgICAgICBjb3B5LmRlbGF5ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC50byhjdXJUYXJnZXQsIGNvcHksIHN0YWdnZXJGdW5jID8gc3RhZ2dlckZ1bmMoaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSA6IDApO1xuICAgICAgICAgIHRsLl9lYXNlID0gX2Vhc2VNYXAubm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRsLmR1cmF0aW9uKCkgPyBkdXJhdGlvbiA9IGRlbGF5ID0gMCA6IF90aGlzMy50aW1lbGluZSA9IDA7IC8vIGlmIHRoZSB0aW1lbGluZSdzIGR1cmF0aW9uIGlzIDAsIHdlIGRvbid0IG5lZWQgYSB0aW1lbGluZSBpbnRlcm5hbGx5IVxuICAgICAgfSBlbHNlIGlmIChrZXlmcmFtZXMpIHtcbiAgICAgICAgX2luaGVyaXREZWZhdWx0cyhfc2V0RGVmYXVsdHModGwudmFycy5kZWZhdWx0cywge1xuICAgICAgICAgIGVhc2U6IFwibm9uZVwiXG4gICAgICAgIH0pKTtcblxuICAgICAgICB0bC5fZWFzZSA9IF9wYXJzZUVhc2Uoa2V5ZnJhbWVzLmVhc2UgfHwgdmFycy5lYXNlIHx8IFwibm9uZVwiKTtcbiAgICAgICAgdmFyIHRpbWUgPSAwLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGtmLFxuICAgICAgICAgICAgdjtcblxuICAgICAgICBpZiAoX2lzQXJyYXkoa2V5ZnJhbWVzKSkge1xuICAgICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRsLnRvKHBhcnNlZFRhcmdldHMsIGZyYW1lLCBcIj5cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGwuZHVyYXRpb24oKTsgLy8gdG8gZW5zdXJlIHRsLl9kdXIgaXMgY2FjaGVkIGJlY2F1c2Ugd2UgdGFwIGludG8gaXQgZm9yIHBlcmZvcm1hbmNlIHB1cnBvc2VzIGluIHRoZSByZW5kZXIoKSBtZXRob2QuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weSA9IHt9O1xuXG4gICAgICAgICAgZm9yIChwIGluIGtleWZyYW1lcykge1xuICAgICAgICAgICAgcCA9PT0gXCJlYXNlXCIgfHwgcCA9PT0gXCJlYXNlRWFjaFwiIHx8IF9wYXJzZUtleWZyYW1lKHAsIGtleWZyYW1lc1twXSwgY29weSwga2V5ZnJhbWVzLmVhc2VFYWNoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHAgaW4gY29weSkge1xuICAgICAgICAgICAgYSA9IGNvcHlbcF0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYS50IC0gYi50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aW1lID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAga2YgPSBhW2ldO1xuICAgICAgICAgICAgICB2ID0ge1xuICAgICAgICAgICAgICAgIGVhc2U6IGtmLmUsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IChrZi50IC0gKGkgPyBhW2kgLSAxXS50IDogMCkpIC8gMTAwICogZHVyYXRpb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdltwXSA9IGtmLnY7XG4gICAgICAgICAgICAgIHRsLnRvKHBhcnNlZFRhcmdldHMsIHYsIHRpbWUpO1xuICAgICAgICAgICAgICB0aW1lICs9IHYuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGwuZHVyYXRpb24oKSA8IGR1cmF0aW9uICYmIHRsLnRvKHt9LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gLSB0bC5kdXJhdGlvbigpXG4gICAgICAgICAgfSk7IC8vIGluIGNhc2Uga2V5ZnJhbWVzIGRpZG4ndCBnbyB0byAxMDAlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZHVyYXRpb24gfHwgX3RoaXMzLmR1cmF0aW9uKGR1cmF0aW9uID0gdGwuZHVyYXRpb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzMy50aW1lbGluZSA9IDA7IC8vc3BlZWQgb3B0aW1pemF0aW9uLCBmYXN0ZXIgbG9va3VwcyAobm8gZ29pbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbilcbiAgICB9XG5cbiAgICBpZiAob3ZlcndyaXRlID09PSB0cnVlICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzKSB7XG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcblxuICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZihwYXJzZWRUYXJnZXRzKTtcblxuICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgIH1cblxuICAgIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBwb3NpdGlvbik7XG5cbiAgICB2YXJzLnJldmVyc2VkICYmIF90aGlzMy5yZXZlcnNlKCk7XG4gICAgdmFycy5wYXVzZWQgJiYgX3RoaXMzLnBhdXNlZCh0cnVlKTtcblxuICAgIGlmIChpbW1lZGlhdGVSZW5kZXIgfHwgIWR1cmF0aW9uICYmICFrZXlmcmFtZXMgJiYgX3RoaXMzLl9zdGFydCA9PT0gX3JvdW5kUHJlY2lzZShwYXJlbnQuX3RpbWUpICYmIF9pc05vdEZhbHNlKGltbWVkaWF0ZVJlbmRlcikgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSkgJiYgcGFyZW50LmRhdGEgIT09IFwibmVzdGVkXCIpIHtcbiAgICAgIF90aGlzMy5fdFRpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXG4gICAgICBfdGhpczMucmVuZGVyKE1hdGgubWF4KDAsIC1kZWxheSkgfHwgMCk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXG4gICAgfVxuXG4gICAgc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIGlzTmVnYXRpdmUgPSB0b3RhbFRpbWUgPCAwLFxuICAgICAgICB0VGltZSA9IHRvdGFsVGltZSA+IHREdXIgLSBfdGlueU51bSAmJiAhaXNOZWdhdGl2ZSA/IHREdXIgOiB0b3RhbFRpbWUgPCBfdGlueU51bSA/IDAgOiB0b3RhbFRpbWUsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIHB0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgIGlzWW95byxcbiAgICAgICAgcmF0aW8sXG4gICAgICAgIHRpbWVsaW5lLFxuICAgICAgICB5b3lvRWFzZTtcblxuICAgIGlmICghZHVyKSB7XG4gICAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgIH0gZWxzZSBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8ICF0b3RhbFRpbWUgfHwgZm9yY2UgfHwgIXRoaXMuX2luaXR0ZWQgJiYgdGhpcy5fdFRpbWUgfHwgdGhpcy5fc3RhcnRBdCAmJiB0aGlzLl96VGltZSA8IDAgIT09IGlzTmVnYXRpdmUgfHwgdGhpcy5fbGF6eSkge1xuICAgICAgLy8gdGhpcyBzZW5zZXMgaWYgd2UncmUgY3Jvc3Npbmcgb3ZlciB0aGUgc3RhcnQgdGltZSwgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHJlY29yZCBfelRpbWUgYW5kIGZvcmNlIHRoZSByZW5kZXIsIGJ1dCB3ZSBkbyBpdCBpbiB0aGlzIGxlbmd0aHkgY29uZGl0aW9uYWwgd2F5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zICh1c3VhbGx5IHdlIGNhbiBza2lwIHRoZSBjYWxjdWxhdGlvbnMpOiB0aGlzLl9pbml0dGVkICYmICh0aGlzLl96VGltZSA8IDApICE9PSAodG90YWxUaW1lIDwgMClcbiAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgIHRpbWVsaW5lID0gdGhpcy50aW1lbGluZTtcblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0IDwgLTEgJiYgaXNOZWdhdGl2ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZJdGVyYXRpb24gPSBfcm91bmRQcmVjaXNlKHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7IC8vIGZ1bGwgZGVjaW1hbCB2ZXJzaW9uIG9mIGl0ZXJhdGlvbnMsIG5vdCB0aGUgcHJldmlvdXMgaXRlcmF0aW9uICh3ZSdyZSByZXVzaW5nIHByZXZJdGVyYXRpb24gdmFyaWFibGUgZm9yIGVmZmljaWVuY3kpXG5cbiAgICAgICAgICBpdGVyYXRpb24gPSB+fnByZXZJdGVyYXRpb247XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGltZSA+IGR1cikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc1lveW8gPSB0aGlzLl95b3lvICYmIGl0ZXJhdGlvbiAmIDE7XG5cbiAgICAgICAgaWYgKGlzWW95bykge1xuICAgICAgICAgIHlveW9FYXNlID0gdGhpcy5feUVhc2U7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICBpZiAodGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlICYmIHRoaXMuX2luaXR0ZWQgJiYgaXRlcmF0aW9uID09PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgLy9jb3VsZCBiZSBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IHBhcnQuIE5vIG5lZWQgdG8gcmVuZGVyIGFuZCBmaXJlIGNhbGxiYWNrcy5cbiAgICAgICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgICAgIHRpbWVsaW5lICYmIHRoaXMuX3lFYXNlICYmIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKTsgLy9yZXBlYXRSZWZyZXNoIGZ1bmN0aW9uYWxpdHlcblxuICAgICAgICAgIGlmICh0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICF0aGlzLl9sb2NrICYmIHRpbWUgIT09IGN5Y2xlRHVyYXRpb24gJiYgdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgICAgLy8gdGhpcy5fdGltZSB3aWxsID09PSBjeWNsZUR1cmF0aW9uIHdoZW4gd2UgcmVuZGVyIGF0IEVYQUNUTFkgdGhlIGVuZCBvZiBhbiBpdGVyYXRpb24uIFdpdGhvdXQgdGhpcyBjb25kaXRpb24sIGl0J2Qgb2Z0ZW4gZG8gdGhlIHJlcGVhdFJlZnJlc2ggcmVuZGVyIFRXSUNFIChhZ2FpbiBvbiB0aGUgdmVyeSBuZXh0IHRpY2spLlxuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kUHJlY2lzZShjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCBpc05lZ2F0aXZlID8gdG90YWxUaW1lIDogdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzLCB0VGltZSkpIHtcbiAgICAgICAgICB0aGlzLl90VGltZSA9IDA7IC8vIGluIGNvbnN0cnVjdG9yIGlmIGltbWVkaWF0ZVJlbmRlciBpcyB0cnVlLCB3ZSBzZXQgX3RUaW1lIHRvIC1fdGlueU51bSB0byBoYXZlIHRoZSBwbGF5aGVhZCBjcm9zcyB0aGUgc3RhcnRpbmcgcG9pbnQgYnV0IHdlIGNhbid0IGxlYXZlIF90VGltZSBhcyBhIG5lZ2F0aXZlIG51bWJlci5cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmICEoZm9yY2UgJiYgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSkge1xuICAgICAgICAgIC8vIHJhcmUgZWRnZSBjYXNlIC0gZHVyaW5nIGluaXRpYWxpemF0aW9uLCBhbiBvblVwZGF0ZSBpbiB0aGUgX3N0YXJ0QXQgKC5mcm9tVG8oKSkgbWlnaHQgZm9yY2UgdGhpcyB0d2VlbiB0byByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkaXRjaCB0aGlzIHJlbmRlcigpIGNhbGwgc28gdGhhdCBpdCBkb2Vzbid0IHJldmVydCB0aGUgdmFsdWVzLiBCdXQgd2UgYWxzbyBkb24ndCB3YW50IHRvIGR1bXAgaWYgd2UncmUgZG9pbmcgYSByZXBlYXRSZWZyZXNoIHJlbmRlciFcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXIgIT09IHRoaXMuX2R1cikge1xuICAgICAgICAgIC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgaWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcbiAgICAgICAgdGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgICAgdGhpcy5fbGF6eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXByZXZUaW1lICYmIHRUaW1lICYmICFzdXBwcmVzc0V2ZW50cyAmJiAhcHJldkl0ZXJhdGlvbikge1xuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lbGluZS5fZHVyICogdGltZWxpbmUuX2Vhc2UodGltZSAvIHRoaXMuX2R1ciksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIGlzTmVnYXRpdmUgJiYgX3Jld2luZFN0YXJ0QXQodGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBlYXQgJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmIHRoaXMudmFycy5vblJlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cbiAgICAgIGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcbiAgICAgICAgaXNOZWdhdGl2ZSAmJiAhdGhpcy5fb25VcGRhdGUgJiYgX3Jld2luZFN0YXJ0QXQodGhpcywgdG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHRoaXMuX3REdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgd2UncmUgcmVuZGVyaW5nIGF0IGV4YWN0bHkgYSB0aW1lIG9mIDAsIGFzIHRoZXJlIGNvdWxkIGJlIGF1dG9SZXZlcnQgdmFsdWVzIHRoYXQgc2hvdWxkIGdldCBzZXQgb24gdGhlIG5leHQgdGljayAoaWYgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydFRpbWUsIG5lZ2F0aXZlIHRvdGFsVGltZSkuIERvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgIShpc05lZ2F0aXZlICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8IGlzWW95bykpIHtcbiAgICAgICAgICAvLyBpZiBwcmV2VGltZSBhbmQgdFRpbWUgYXJlIHplcm8sIHdlIHNob3VsZG4ndCBmaXJlIHRoZSBvblJldmVyc2VDb21wbGV0ZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgeW91IGdzYXAudG8oLi4uIHtwYXVzZWQ6dHJ1ZX0pLnBsYXkoKTtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8zLnRhcmdldHMgPSBmdW5jdGlvbiB0YXJnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRzO1xuICB9O1xuXG4gIF9wcm90bzMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoc29mdCkge1xuICAgIC8vIFwic29mdFwiIGdpdmVzIHVzIGEgd2F5IHRvIGNsZWFyIG91dCBldmVyeXRoaW5nIEVYQ0VQVCB0aGUgcmVjb3JkZWQgcHJlLVwiZnJvbVwiIHBvcnRpb24gb2YgZnJvbSgpIHR3ZWVucy4gT3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgaWYgeW91IHR3ZWVuLnByb2dyZXNzKDEpLnJlbmRlcigwLCB0cnVlIHRydWUpLmludmFsaWRhdGUoKSwgdGhlIFwiZnJvbVwiIHZhbHVlcyB3b3VsZCBwZXJzaXN0IGFuZCB0aGVuIG9uIHRoZSBuZXh0IHJlbmRlciwgdGhlIGZyb20oKSB0d2VlbnMgd291bGQgaW5pdGlhbGl6ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgd291bGQgbWF0Y2ggdGhlIFwiZnJvbVwiIHZhbHVlcywgdGh1cyBhbmltYXRlIGZyb20gdGhlIHNhbWUgdmFsdWUgdG8gdGhlIHNhbWUgdmFsdWUgKG5vIGFuaW1hdGlvbikuIFdlIHRhcCBpbnRvIHRoaXMgaW4gU2Nyb2xsVHJpZ2dlcidzIHJlZnJlc2goKSB3aGVyZSB3ZSBtdXN0IHB1c2ggYSB0d2VlbiB0byBjb21wbGV0aW9uIGFuZCB0aGVuIGJhY2sgYWdhaW4gYnV0IGhvbm9yIGl0cyBpbml0IHN0YXRlIGluIGNhc2UgdGhlIHR3ZWVuIGlzIGRlcGVuZGVudCBvbiBhbm90aGVyIHR3ZWVuIGZ1cnRoZXIgdXAgb24gdGhlIHBhZ2UuXG4gICAgKCFzb2Z0IHx8ICF0aGlzLnZhcnMucnVuQmFja3dhcmRzKSAmJiAodGhpcy5fc3RhcnRBdCA9IDApO1xuICAgIHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9vblVwZGF0ZSA9IHRoaXMuX2xhenkgPSB0aGlzLnJhdGlvID0gMDtcbiAgICB0aGlzLl9wdExvb2t1cCA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5pbnZhbGlkYXRlKHNvZnQpO1xuICAgIHJldHVybiBfQW5pbWF0aW9uMi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMsIHNvZnQpO1xuICB9O1xuXG4gIF9wcm90bzMucmVzZXRUbyA9IGZ1bmN0aW9uIHJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCBza2lwUmVjdXJzaW9uKSB7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICB0aGlzLl90cyB8fCB0aGlzLnBsYXkoKTtcbiAgICB2YXIgdGltZSA9IE1hdGgubWluKHRoaXMuX2R1ciwgKHRoaXMuX2RwLl90aW1lIC0gdGhpcy5fc3RhcnQpICogdGhpcy5fdHMpLFxuICAgICAgICByYXRpbztcbiAgICB0aGlzLl9pbml0dGVkIHx8IF9pbml0VHdlZW4odGhpcywgdGltZSk7XG4gICAgcmF0aW8gPSB0aGlzLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpOyAvLyBkb24ndCBqdXN0IGdldCB0d2Vlbi5yYXRpbyBiZWNhdXNlIGl0IG1heSBub3QgaGF2ZSByZW5kZXJlZCB5ZXQuXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIHRvIGFsbG93IGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHZhbHVlcyB0byB1cGRhdGUsIGxpa2UgdHdlZW4ucmVzZXRUbyh7eDogMTAwLCB5OiAyMDB9KTsgQXQgdGhpcyBwb2ludCwgaXQgZG9lc24ndCBzZWVtIHdvcnRoIHRoZSBhZGRlZCBrYiBnaXZlbiB0aGUgZmFjdCB0aGF0IG1vc3QgdXNlcnMgd2lsbCBsaWtlbHkgb3B0IGZvciB0aGUgY29udmVuaWVudCBnc2FwLnF1aWNrVG8oKSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIG1ldGhvZC5cbiAgICAvLyBpZiAoX2lzT2JqZWN0KHByb3BlcnR5KSkgeyAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAgICAvLyBcdGZvciAocCBpbiBwcm9wZXJ0eSkge1xuICAgIC8vIFx0XHRpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcCwgcHJvcGVydHlbcF0sIHZhbHVlID8gdmFsdWVbcF0gOiBudWxsLCBzdGFydCwgcmF0aW8sIHRpbWUpKSB7XG4gICAgLy8gXHRcdFx0cmV0dXJuIHRoaXMucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpOyAvLyBpZiBhIFByb3BUd2VlbiB3YXNuJ3QgZm91bmQgZm9yIHRoZSBwcm9wZXJ0eSwgaXQnbGwgZ2V0IGZvcmNlZCB3aXRoIGEgcmUtaW5pdGlhbGl6YXRpb24gc28gd2UgbmVlZCB0byBqdW1wIG91dCBhbmQgc3RhcnQgb3ZlciBhZ2Fpbi5cbiAgICAvLyBcdFx0fVxuICAgIC8vIFx0fVxuICAgIC8vIH0gZWxzZSB7XG5cbiAgICBpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSwgc2tpcFJlY3Vyc2lvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCAxKTsgLy8gaWYgYSBQcm9wVHdlZW4gd2Fzbid0IGZvdW5kIGZvciB0aGUgcHJvcGVydHksIGl0J2xsIGdldCBmb3JjZWQgd2l0aCBhIHJlLWluaXRpYWxpemF0aW9uIHNvIHdlIG5lZWQgdG8ganVtcCBvdXQgYW5kIHN0YXJ0IG92ZXIgYWdhaW4uXG4gICAgfSAvL31cblxuXG4gICAgX2FsaWduUGxheWhlYWQodGhpcywgMCk7XG5cbiAgICB0aGlzLnBhcmVudCB8fCBfYWRkTGlua2VkTGlzdEl0ZW0odGhpcy5fZHAsIHRoaXMsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGhpcy5fZHAuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKDApO1xuICB9O1xuXG4gIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSBcImFsbFwiO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0cyAmJiAoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikpIHtcbiAgICAgIHRoaXMuX2xhenkgPSB0aGlzLl9wdCA9IDA7XG4gICAgICB0aGlzLnBhcmVudCA/IF9pbnRlcnJ1cHQodGhpcykgOiB0aGlzLnNjcm9sbFRyaWdnZXIgJiYgdGhpcy5zY3JvbGxUcmlnZ2VyLmtpbGwoISFfcmV2ZXJ0aW5nKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICB2YXIgdER1ciA9IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpO1xuICAgICAgdGhpcy50aW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgdmFycywgX292ZXJ3cml0aW5nVHdlZW4gJiYgX292ZXJ3cml0aW5nVHdlZW4udmFycy5vdmVyd3JpdGUgIT09IHRydWUpLl9maXJzdCB8fCBfaW50ZXJydXB0KHRoaXMpOyAvLyBpZiBub3RoaW5nIGlzIGxlZnQgdHdlZW5pbmcsIGludGVycnVwdC5cblxuICAgICAgdGhpcy5wYXJlbnQgJiYgdER1ciAhPT0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCkgJiYgX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX2R1ciAqIHRoaXMudGltZWxpbmUuX3REdXIgLyB0RHVyLCAwLCAxKTsgLy8gaWYgYSBuZXN0ZWQgdHdlZW4gaXMga2lsbGVkIHRoYXQgY2hhbmdlcyB0aGUgZHVyYXRpb24sIGl0IHNob3VsZCBhZmZlY3QgdGhpcyB0d2VlbidzIGR1cmF0aW9uLiBXZSBtdXN0IHVzZSB0aGUgcmF0aW8sIHRob3VnaCwgYmVjYXVzZSBzb21ldGltZXMgdGhlIGludGVybmFsIHRpbWVsaW5lIGlzIHN0cmV0Y2hlZCBsaWtlIGZvciBrZXlmcmFtZXMgd2hlcmUgdGhleSBkb24ndCBhbGwgYWRkIHVwIHRvIHdoYXRldmVyIHRoZSBwYXJlbnQgdHdlZW4ncyBkdXJhdGlvbiB3YXMgc2V0IHRvLlxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkVGFyZ2V0cyA9IHRoaXMuX3RhcmdldHMsXG4gICAgICAgIGtpbGxpbmdUYXJnZXRzID0gdGFyZ2V0cyA/IHRvQXJyYXkodGFyZ2V0cykgOiBwYXJzZWRUYXJnZXRzLFxuICAgICAgICBwcm9wVHdlZW5Mb29rdXAgPSB0aGlzLl9wdExvb2t1cCxcbiAgICAgICAgZmlyc3RQVCA9IHRoaXMuX3B0LFxuICAgICAgICBvdmVyd3JpdHRlblByb3BzLFxuICAgICAgICBjdXJMb29rdXAsXG4gICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcCxcbiAgICAgICAgcHQsXG4gICAgICAgIGk7XG5cbiAgICBpZiAoKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpICYmIF9hcnJheXNNYXRjaChwYXJzZWRUYXJnZXRzLCBraWxsaW5nVGFyZ2V0cykpIHtcbiAgICAgIHZhcnMgPT09IFwiYWxsXCIgJiYgKHRoaXMuX3B0ID0gMCk7XG4gICAgICByZXR1cm4gX2ludGVycnVwdCh0aGlzKTtcbiAgICB9XG5cbiAgICBvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3AgPSB0aGlzLl9vcCB8fCBbXTtcblxuICAgIGlmICh2YXJzICE9PSBcImFsbFwiKSB7XG4gICAgICAvL3NvIHBlb3BsZSBjYW4gcGFzcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzXG4gICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgIHAgPSB7fTtcblxuICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcFtuYW1lXSA9IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhcnMgPSBwO1xuICAgICAgfVxuXG4gICAgICB2YXJzID0gX2FkZEFsaWFzZXNUb1ZhcnMocGFyc2VkVGFyZ2V0cywgdmFycyk7XG4gICAgfVxuXG4gICAgaSA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKH5raWxsaW5nVGFyZ2V0cy5pbmRleE9mKHBhcnNlZFRhcmdldHNbaV0pKSB7XG4gICAgICAgIGN1ckxvb2t1cCA9IHByb3BUd2Vlbkxvb2t1cFtpXTtcblxuICAgICAgICBpZiAodmFycyA9PT0gXCJhbGxcIikge1xuICAgICAgICAgIG92ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzO1xuICAgICAgICAgIHByb3BzID0gY3VyTG9va3VwO1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdHRlblByb3BzW2ldID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fTtcbiAgICAgICAgICBwcm9wcyA9IHZhcnM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICBwdCA9IGN1ckxvb2t1cCAmJiBjdXJMb29rdXBbcF07XG5cbiAgICAgICAgICBpZiAocHQpIHtcbiAgICAgICAgICAgIGlmICghKFwia2lsbFwiIGluIHB0LmQpIHx8IHB0LmQua2lsbChwKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgY3VyTG9va3VwW3BdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJPdmVyd3JpdGVQcm9wcyAhPT0gXCJhbGxcIikge1xuICAgICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHNbcF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2luaXR0ZWQgJiYgIXRoaXMuX3B0ICYmIGZpcnN0UFQgJiYgX2ludGVycnVwdCh0aGlzKTsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBhcmUga2lsbGVkLCBraWxsIHRoZSB0d2Vlbi4gV2l0aG91dCB0aGlzIGxpbmUsIGlmIHRoZXJlJ3MgYSB0d2VlbiB3aXRoIG11bHRpcGxlIHRhcmdldHMgYW5kIHRoZW4geW91IGtpbGxUd2VlbnNPZigpIGVhY2ggdGFyZ2V0IGluZGl2aWR1YWxseSwgdGhlIHR3ZWVuIHdvdWxkIHRlY2huaWNhbGx5IHN0aWxsIHJlbWFpbiBhY3RpdmUgYW5kIGZpcmUgaXRzIG9uQ29tcGxldGUgZXZlbiB0aG91Z2ggdGhlcmUgYXJlbid0IGFueSBtb3JlIHByb3BlcnRpZXMgdHdlZW5pbmcuXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBUd2Vlbi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIGFyZ3VtZW50c1syXSk7XG4gIH07XG5cbiAgVHdlZW4uZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycykge1xuICAgIHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgVHdlZW4uZGVsYXllZENhbGwgPSBmdW5jdGlvbiBkZWxheWVkQ2FsbChkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKGNhbGxiYWNrLCAwLCB7XG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvblJldmVyc2VDb21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvbkNvbXBsZXRlUGFyYW1zOiBwYXJhbXMsXG4gICAgICBvblJldmVyc2VDb21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZTogc2NvcGVcbiAgICB9KTsgLy8gd2UgbXVzdCB1c2Ugb25SZXZlcnNlQ29tcGxldGUgdG9vIGZvciB0aGluZ3MgbGlrZSB0aW1lbGluZS5hZGQoKCkgPT4gey4uLn0pIHdoaWNoIHNob3VsZCBiZSB0cmlnZ2VyZWQgaW4gQk9USCBkaXJlY3Rpb25zIChmb3J3YXJkIGFuZCByZXZlcnNlKVxuICB9O1xuXG4gIFR3ZWVuLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBUd2Vlbi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycykge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcbiAgfTtcblxuICBUd2Vlbi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFR3ZWVuO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVHdlZW4ucHJvdG90eXBlLCB7XG4gIF90YXJnZXRzOiBbXSxcbiAgX2xhenk6IDAsXG4gIF9zdGFydEF0OiAwLFxuICBfb3A6IDAsXG4gIF9vbkluaXQ6IDBcbn0pOyAvL2FkZCB0aGUgcGVydGluZW50IHRpbWVsaW5lIG1ldGhvZHMgdG8gVHdlZW4gaW5zdGFuY2VzIHNvIHRoYXQgdXNlcnMgY2FuIGNoYWluIGNvbnZlbmllbnRseSBhbmQgY3JlYXRlIGEgdGltZWxpbmUgYXV0b21hdGljYWxseS4gKHJlbW92ZWQgZHVlIHRvIGNvbmNlcm5zIHRoYXQgaXQnZCB1bHRpbWF0ZWx5IGFkZCB0byBtb3JlIGNvbmZ1c2lvbiBlc3BlY2lhbGx5IGZvciBiZWdpbm5lcnMpXG4vLyBfZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxzZXQsY2FsbCxhZGQsYWRkTGFiZWwsYWRkUGF1c2VcIiwgbmFtZSA9PiB7XG4vLyBcdFR3ZWVuLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuLy8gXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSgpO1xuLy8gXHRcdHJldHVybiBfYWRkVG9UaW1lbGluZSh0bCwgdGhpcylbbmFtZV0uYXBwbHkodGwsIHRvQXJyYXkoYXJndW1lbnRzKSk7XG4vLyBcdH1cbi8vIH0pO1xuLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gTGV2ZXJhZ2UgdGhlIHRpbWVsaW5lIGNhbGxzLlxuXG5cbl9mb3JFYWNoTmFtZShcInN0YWdnZXJUbyxzdGFnZ2VyRnJvbSxzdGFnZ2VyRnJvbVRvXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFR3ZWVuW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSgpLFxuICAgICAgICBwYXJhbXMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcGFyYW1zLnNwbGljZShuYW1lID09PSBcInN0YWdnZXJGcm9tVG9cIiA/IDUgOiA0LCAwLCAwKTtcbiAgICByZXR1cm4gdGxbbmFtZV0uYXBwbHkodGwsIHBhcmFtcyk7XG4gIH07XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUFJPUFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxudmFyIF9zZXR0ZXJQbGFpbiA9IGZ1bmN0aW9uIF9zZXR0ZXJQbGFpbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyRnVuYyA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckZ1bmNXaXRoUGFyYW0gPSBmdW5jdGlvbiBfc2V0dGVyRnVuY1dpdGhQYXJhbSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XShkYXRhLmZwLCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfc2V0dGVyQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9nZXRTZXR0ZXIgPSBmdW5jdGlvbiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHRhcmdldFtwcm9wZXJ0eV0pID8gX3NldHRlckZ1bmMgOiBfaXNVbmRlZmluZWQodGFyZ2V0W3Byb3BlcnR5XSkgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZSA/IF9zZXR0ZXJBdHRyaWJ1dGUgOiBfc2V0dGVyUGxhaW47XG59LFxuICAgIF9yZW5kZXJQbGFpbiA9IGZ1bmN0aW9uIF9yZW5kZXJQbGFpbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMDApIC8gMTAwMDAwMCwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJCb29sZWFuID0gZnVuY3Rpb24gX3JlbmRlckJvb2xlYW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAhIShkYXRhLnMgKyBkYXRhLmMgKiByYXRpbyksIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDb21wbGV4U3RyaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgcyA9IFwiXCI7XG5cbiAgaWYgKCFyYXRpbyAmJiBkYXRhLmIpIHtcbiAgICAvL2IgPSBiZWdpbm5pbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuYjtcbiAgfSBlbHNlIGlmIChyYXRpbyA9PT0gMSAmJiBkYXRhLmUpIHtcbiAgICAvL2UgPSBlbmRpbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuZTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHMgPSBwdC5wICsgKHB0Lm0gPyBwdC5tKHB0LnMgKyBwdC5jICogcmF0aW8pIDogTWF0aC5yb3VuZCgocHQucyArIHB0LmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCkgKyBzOyAvL3dlIHVzZSB0aGUgXCJwXCIgcHJvcGVydHkgZm9yIHRoZSB0ZXh0IGluYmV0d2VlbiAobGlrZSBhIHN1ZmZpeCkuIEFuZCBpbiB0aGUgY29udGV4dCBvZiBhIGNvbXBsZXggc3RyaW5nLCB0aGUgbW9kaWZpZXIgKG0pIGlzIHR5cGljYWxseSBqdXN0IE1hdGgucm91bmQoKSwgbGlrZSBmb3IgUkdCIGNvbG9ycy5cblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICBzICs9IGRhdGEuYzsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIGNodW5rIG9mIG5vbi1udW1lcmljIHRleHQuXG4gIH1cblxuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcywgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3JlbmRlclByb3BUd2VlbnMocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxufSxcbiAgICBfYWRkUGx1Z2luTW9kaWZpZXIgPSBmdW5jdGlvbiBfYWRkUGx1Z2luTW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQucCA9PT0gcHJvcGVydHkgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xuICAgIHB0ID0gbmV4dDtcbiAgfVxufSxcbiAgICBfa2lsbFByb3BUd2VlbnNPZiA9IGZ1bmN0aW9uIF9raWxsUHJvcFR3ZWVuc09mKHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICBpZiAocHQucCA9PT0gcHJvcGVydHkgJiYgIXB0Lm9wIHx8IHB0Lm9wID09PSBwcm9wZXJ0eSkge1xuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICB9IGVsc2UgaWYgKCFwdC5kZXApIHtcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyA9IDE7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XG59LFxuICAgIF9zZXR0ZXJXaXRoTW9kaWZpZXIgPSBmdW5jdGlvbiBfc2V0dGVyV2l0aE1vZGlmaWVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIGRhdGEubVNldCh0YXJnZXQsIHByb3BlcnR5LCBkYXRhLm0uY2FsbChkYXRhLnR3ZWVuLCB2YWx1ZSwgZGF0YS5tdCksIGRhdGEpO1xufSxcbiAgICBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5ID0gZnVuY3Rpb24gX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eShwYXJlbnQpIHtcbiAgdmFyIHB0ID0gcGFyZW50Ll9wdCxcbiAgICAgIG5leHQsXG4gICAgICBwdDIsXG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3Q7IC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIGRvIHRoZWlyIHdvcmsgYWZ0ZXIgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIHdlcmUgY3JlYXRlZCAobGlrZSBSb3VuZFByb3BzUGx1Z2luIGFuZCBNb2RpZmllcnNQbHVnaW4pXG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0MiA9IGZpcnN0O1xuXG4gICAgd2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuICAgICAgcHQyID0gcHQyLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpIHtcbiAgICAgIHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0ID0gcHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9uZXh0ID0gcHQyKSB7XG4gICAgICBwdDIuX3ByZXYgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHB0O1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHBhcmVudC5fcHQgPSBmaXJzdDtcbn07IC8vUHJvcFR3ZWVuIGtleTogdCA9IHRhcmdldCwgcCA9IHByb3AsIHIgPSByZW5kZXJlciwgZCA9IGRhdGEsIHMgPSBzdGFydCwgYyA9IGNoYW5nZSwgb3AgPSBvdmVyd3JpdGVQcm9wZXJ0eSAoT05MWSBwb3B1bGF0ZWQgd2hlbiBpdCdzIGRpZmZlcmVudCB0aGFuIHApLCBwciA9IHByaW9yaXR5LCBfbmV4dC9fcHJldiBmb3IgdGhlIGxpbmtlZCBsaXN0IHNpYmxpbmdzLCBzZXQgPSBzZXR0ZXIsIG0gPSBtb2RpZmllciwgbVNldCA9IG1vZGlmaWVyU2V0dGVyICh0aGUgb3JpZ2luYWwgc2V0dGVyLCBiZWZvcmUgYSBtb2RpZmllciB3YXMgYWRkZWQpXG5cblxuZXhwb3J0IHZhciBQcm9wVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9wVHdlZW4obmV4dCwgdGFyZ2V0LCBwcm9wLCBzdGFydCwgY2hhbmdlLCByZW5kZXJlciwgZGF0YSwgc2V0dGVyLCBwcmlvcml0eSkge1xuICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICB0aGlzLnMgPSBzdGFydDtcbiAgICB0aGlzLmMgPSBjaGFuZ2U7XG4gICAgdGhpcy5wID0gcHJvcDtcbiAgICB0aGlzLnIgPSByZW5kZXJlciB8fCBfcmVuZGVyUGxhaW47XG4gICAgdGhpcy5kID0gZGF0YSB8fCB0aGlzO1xuICAgIHRoaXMuc2V0ID0gc2V0dGVyIHx8IF9zZXR0ZXJQbGFpbjtcbiAgICB0aGlzLnByID0gcHJpb3JpdHkgfHwgMDtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBuZXh0Ll9wcmV2ID0gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IFByb3BUd2Vlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5tb2RpZmllciA9IGZ1bmN0aW9uIG1vZGlmaWVyKGZ1bmMsIHR3ZWVuLCB0YXJnZXQpIHtcbiAgICB0aGlzLm1TZXQgPSB0aGlzLm1TZXQgfHwgdGhpcy5zZXQ7IC8vaW4gY2FzZSBpdCB3YXMgYWxyZWFkeSBzZXQgKGEgUHJvcFR3ZWVuIGNhbiBvbmx5IGhhdmUgb25lIG1vZGlmaWVyKVxuXG4gICAgdGhpcy5zZXQgPSBfc2V0dGVyV2l0aE1vZGlmaWVyO1xuICAgIHRoaXMubSA9IGZ1bmM7XG4gICAgdGhpcy5tdCA9IHRhcmdldDsgLy9tb2RpZmllciB0YXJnZXRcblxuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgfTtcblxuICByZXR1cm4gUHJvcFR3ZWVuO1xufSgpOyAvL0luaXRpYWxpemF0aW9uIHRhc2tzXG5cbl9mb3JFYWNoTmFtZShfY2FsbGJhY2tOYW1lcyArIFwicGFyZW50LGR1cmF0aW9uLGVhc2UsZGVsYXksb3ZlcndyaXRlLHJ1bkJhY2t3YXJkcyxzdGFydEF0LHlveW8saW1tZWRpYXRlUmVuZGVyLHJlcGVhdCxyZXBlYXREZWxheSxkYXRhLHBhdXNlZCxyZXZlcnNlZCxsYXp5LGNhbGxiYWNrU2NvcGUsc3RyaW5nRmlsdGVyLGlkLHlveW9FYXNlLHN0YWdnZXIsaW5oZXJpdCxyZXBlYXRSZWZyZXNoLGtleWZyYW1lcyxhdXRvUmV2ZXJ0LHNjcm9sbFRyaWdnZXJcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbn0pO1xuXG5fZ2xvYmFscy5Ud2Vlbk1heCA9IF9nbG9iYWxzLlR3ZWVuTGl0ZSA9IFR3ZWVuO1xuX2dsb2JhbHMuVGltZWxpbmVMaXRlID0gX2dsb2JhbHMuVGltZWxpbmVNYXggPSBUaW1lbGluZTtcbl9nbG9iYWxUaW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gIHNvcnRDaGlsZHJlbjogZmFsc2UsXG4gIGRlZmF1bHRzOiBfZGVmYXVsdHMsXG4gIGF1dG9SZW1vdmVDaGlsZHJlbjogdHJ1ZSxcbiAgaWQ6IFwicm9vdFwiLFxuICBzbW9vdGhDaGlsZFRpbWluZzogdHJ1ZVxufSk7XG5fY29uZmlnLnN0cmluZ0ZpbHRlciA9IF9jb2xvclN0cmluZ0ZpbHRlcjtcblxudmFyIF9tZWRpYSA9IFtdLFxuICAgIF9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9sYXN0TWVkaWFUaW1lID0gMCxcbiAgICBfY29udGV4dElEID0gMCxcbiAgICBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBfZGlzcGF0Y2godHlwZSkge1xuICByZXR1cm4gKF9saXN0ZW5lcnNbdHlwZV0gfHwgX2VtcHR5QXJyYXkpLm1hcChmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKCk7XG4gIH0pO1xufSxcbiAgICBfb25NZWRpYUNoYW5nZSA9IGZ1bmN0aW9uIF9vbk1lZGlhQ2hhbmdlKCkge1xuICB2YXIgdGltZSA9IERhdGUubm93KCksXG4gICAgICBtYXRjaGVzID0gW107XG5cbiAgaWYgKHRpbWUgLSBfbGFzdE1lZGlhVGltZSA+IDIpIHtcbiAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhSW5pdFwiKTtcblxuICAgIF9tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgcXVlcmllcyA9IGMucXVlcmllcyxcbiAgICAgICAgICBjb25kaXRpb25zID0gYy5jb25kaXRpb25zLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgYW55TWF0Y2gsXG4gICAgICAgICAgdG9nZ2xlZDtcblxuICAgICAgZm9yIChwIGluIHF1ZXJpZXMpIHtcbiAgICAgICAgbWF0Y2ggPSBfd2luLm1hdGNoTWVkaWEocXVlcmllc1twXSkubWF0Y2hlczsgLy8gRmlyZWZveCBkb2Vzbid0IHVwZGF0ZSB0aGUgXCJtYXRjaGVzXCIgcHJvcGVydHkgb2YgdGhlIE1lZGlhUXVlcnlMaXN0IG9iamVjdCBjb3JyZWN0bHkgLSBpdCBvbmx5IGRvZXMgc28gYXMgaXQgY2FsbHMgaXRzIGNoYW5nZSBoYW5kbGVyIC0gc28gd2UgbXVzdCByZS1jcmVhdGUgYSBtZWRpYSBxdWVyeSBoZXJlIHRvIGVuc3VyZSBpdCdzIGFjY3VyYXRlLlxuXG4gICAgICAgIG1hdGNoICYmIChhbnlNYXRjaCA9IDEpO1xuXG4gICAgICAgIGlmIChtYXRjaCAhPT0gY29uZGl0aW9uc1twXSkge1xuICAgICAgICAgIGNvbmRpdGlvbnNbcF0gPSBtYXRjaDtcbiAgICAgICAgICB0b2dnbGVkID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9nZ2xlZCkge1xuICAgICAgICBjLnJldmVydCgpO1xuICAgICAgICBhbnlNYXRjaCAmJiBtYXRjaGVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhUmV2ZXJ0XCIpO1xuXG4gICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy5vbk1hdGNoKGMsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHJldHVybiBjLmFkZChudWxsLCBmdW5jKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9sYXN0TWVkaWFUaW1lID0gdGltZTtcblxuICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFcIik7XG4gIH1cbn07XG5cbnZhciBDb250ZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29udGV4dChmdW5jLCBzY29wZSkge1xuICAgIHRoaXMuc2VsZWN0b3IgPSBzY29wZSAmJiBzZWxlY3RvcihzY29wZSk7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5fciA9IFtdOyAvLyByZXR1cm5lZC9jbGVhbnVwIGZ1bmN0aW9uc1xuXG4gICAgdGhpcy5pc1JldmVydGVkID0gZmFsc2U7XG4gICAgdGhpcy5pZCA9IF9jb250ZXh0SUQrKzsgLy8gdG8gd29yayBhcm91bmQgaXNzdWVzIHRoYXQgZnJhbWV3b3JrcyBsaWtlIFZ1ZSBjYXVzZSBieSBtYWtpbmcgdGhpbmdzIGludG8gUHJveGllcyB3aGljaCBtYWtlIGl0IGltcG9zc2libGUgdG8gZG8gc29tZXRoaW5nIGxpa2UgX21lZGlhLmluZGV4T2YodGhpcykgYmVjYXVzZSBcInRoaXNcIiB3b3VsZCBubyBsb25nZXIgcmVmZXIgdG8gdGhlIENvbnRleHQgaW5zdGFuY2UgaXRzZWxmIC0gaXQnZCByZWZlciB0byBhIFByb3h5ISBXZSBuZWVkZWQgYSB3YXkgdG8gaWRlbnRpZnkgdGhlIGNvbnRleHQgdW5pcXVlbHlcblxuICAgIGZ1bmMgJiYgdGhpcy5hZGQoZnVuYyk7XG4gIH1cblxuICB2YXIgX3Byb3RvNSA9IENvbnRleHQucHJvdG90eXBlO1xuXG4gIF9wcm90bzUuYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGZ1bmMsIHNjb3BlKSB7XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIGlmIHdlIG5lZWQgdGhlIGFiaWxpdHkgdG8gYWRkKCkgYW4gYW5pbWF0aW9uIHRvIGEgY29udGV4dCBhbmQgZm9yIHdoYXRldmVyIHJlYXNvbiBjYW5ub3QgY3JlYXRlIHRoYXQgYW5pbWF0aW9uIGluc2lkZSBvZiBhIGNvbnRleHQuYWRkKCgpID0+IHsuLi59KSBmdW5jdGlvbi5cbiAgICAvLyBpZiAobmFtZSAmJiBfaXNGdW5jdGlvbihuYW1lLnJldmVydCkpIHtcbiAgICAvLyBcdHRoaXMuZGF0YS5wdXNoKG5hbWUpO1xuICAgIC8vIFx0cmV0dXJuIChuYW1lLl9jdHggPSB0aGlzKTtcbiAgICAvLyB9XG4gICAgaWYgKF9pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICBzY29wZSA9IGZ1bmM7XG4gICAgICBmdW5jID0gbmFtZTtcbiAgICAgIG5hbWUgPSBfaXNGdW5jdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGYgPSBmdW5jdGlvbiBmKCkge1xuICAgICAgdmFyIHByZXYgPSBfY29udGV4dCxcbiAgICAgICAgICBwcmV2U2VsZWN0b3IgPSBzZWxmLnNlbGVjdG9yLFxuICAgICAgICAgIHJlc3VsdDtcbiAgICAgIHByZXYgJiYgcHJldiAhPT0gc2VsZiAmJiBwcmV2LmRhdGEucHVzaChzZWxmKTtcbiAgICAgIHNjb3BlICYmIChzZWxmLnNlbGVjdG9yID0gc2VsZWN0b3Ioc2NvcGUpKTtcbiAgICAgIF9jb250ZXh0ID0gc2VsZjtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIF9pc0Z1bmN0aW9uKHJlc3VsdCkgJiYgc2VsZi5fci5wdXNoKHJlc3VsdCk7XG4gICAgICBfY29udGV4dCA9IHByZXY7XG4gICAgICBzZWxmLnNlbGVjdG9yID0gcHJldlNlbGVjdG9yO1xuICAgICAgc2VsZi5pc1JldmVydGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBzZWxmLmxhc3QgPSBmO1xuICAgIHJldHVybiBuYW1lID09PSBfaXNGdW5jdGlvbiA/IGYoc2VsZiwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZWxmLmFkZChudWxsLCBmdW5jKTtcbiAgICB9KSA6IG5hbWUgPyBzZWxmW25hbWVdID0gZiA6IGY7XG4gIH07XG5cbiAgX3Byb3RvNS5pZ25vcmUgPSBmdW5jdGlvbiBpZ25vcmUoZnVuYykge1xuICAgIHZhciBwcmV2ID0gX2NvbnRleHQ7XG4gICAgX2NvbnRleHQgPSBudWxsO1xuICAgIGZ1bmModGhpcyk7XG4gICAgX2NvbnRleHQgPSBwcmV2O1xuICB9O1xuXG4gIF9wcm90bzUuZ2V0VHdlZW5zID0gZnVuY3Rpb24gZ2V0VHdlZW5zKCkge1xuICAgIHZhciBhID0gW107XG4gICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQ29udGV4dCA/IGEucHVzaC5hcHBseShhLCBlLmdldFR3ZWVucygpKSA6IGUgaW5zdGFuY2VvZiBUd2VlbiAmJiAhKGUucGFyZW50ICYmIGUucGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIpICYmIGEucHVzaChlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBfcHJvdG81LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5fci5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoID0gMDtcbiAgfTtcblxuICBfcHJvdG81LmtpbGwgPSBmdW5jdGlvbiBraWxsKHJldmVydCwgbWF0Y2hNZWRpYSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVydCkge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR3ZWVucyA9IF90aGlzNC5nZXRUd2VlbnMoKSxcbiAgICAgICAgICAgIGkgPSBfdGhpczQuZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICB0O1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAvLyBGbGlwIHBsdWdpbiB0d2VlbnMgYXJlIHZlcnkgZGlmZmVyZW50IGluIHRoYXQgdGhleSBzaG91bGQgYWN0dWFsbHkgYmUgcHVzaGVkIHRvIHRoZWlyIGVuZC4gVGhlIHBsdWdpbiByZXBsYWNlcyB0aGUgdGltZWxpbmUncyAucmV2ZXJ0KCkgbWV0aG9kIHRvIGRvIGV4YWN0bHkgdGhhdC4gQnV0IHdlIGFsc28gbmVlZCB0byByZW1vdmUgYW55IG9mIHRob3NlIG5lc3RlZCB0d2VlbnMgaW5zaWRlIHRoZSBmbGlwIHRpbWVsaW5lIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgaW5kaXZpZHVhbGx5IHJldmVydGVkLlxuICAgICAgICAgIHQgPSBfdGhpczQuZGF0YVtpXTtcblxuICAgICAgICAgIGlmICh0LmRhdGEgPT09IFwiaXNGbGlwXCIpIHtcbiAgICAgICAgICAgIHQucmV2ZXJ0KCk7XG4gICAgICAgICAgICB0LmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICAgICAgICByZXR1cm4gdHdlZW5zLnNwbGljZSh0d2VlbnMuaW5kZXhPZih0d2VlbiksIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHNhdmUgYXMgYW4gb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGNhY2hlIHRoZSBnbG9iYWxUaW1lIGZvciBlYWNoIHR3ZWVuIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIGR1cmluZyB0aGUgc29ydFxuXG5cbiAgICAgICAgdHdlZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnOiB0Ll9kdXIgfHwgdC5fZGVsYXkgfHwgdC5fc2F0ICYmICF0Ll9zYXQudmFycy5pbW1lZGlhdGVSZW5kZXIgPyB0Lmdsb2JhbFRpbWUoMCkgOiAtSW5maW5pdHksXG4gICAgICAgICAgICB0OiB0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBiLmcgLSBhLmcgfHwgLUluZmluaXR5O1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgcmV0dXJuIG8udC5yZXZlcnQocmV2ZXJ0KTtcbiAgICAgICAgfSk7IC8vIG5vdGU6IGFsbCBvZiB0aGUgX3N0YXJ0QXQgdHdlZW5zIHNob3VsZCBiZSByZXZlcnRlZCBpbiByZXZlcnNlIG9yZGVyIHRoYXQgdGhleSB3ZXJlIGNyZWF0ZWQsIGFuZCB0aGV5J2xsIGFsbCBoYXZlIHRoZSBzYW1lIGdsb2JhbFRpbWUgKC0xKSBzbyB0aGUgXCIgfHwgLTFcIiBpbiB0aGUgc29ydCBrZWVwcyB0aGUgb3JkZXIgcHJvcGVybHkuXG5cbiAgICAgICAgaSA9IF90aGlzNC5kYXRhLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGxvb3AgYmFja3dhcmRzIHNvIHRoYXQsIGZvciBleGFtcGxlLCBTcGxpdFRleHRzIHRoYXQgd2VyZSBjcmVhdGVkIGxhdGVyIG9uIHRoZSBzYW1lIGVsZW1lbnQgZ2V0IHJldmVydGVkIGZpcnN0XG4gICAgICAgICAgdCA9IF90aGlzNC5kYXRhW2ldO1xuXG4gICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgICAgICAgaWYgKHQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgICAgICAgICB0LnNjcm9sbFRyaWdnZXIgJiYgdC5zY3JvbGxUcmlnZ2VyLnJldmVydCgpO1xuICAgICAgICAgICAgICB0LmtpbGwoKTsgLy8gZG9uJ3QgcmV2ZXJ0KCkgdGhlIHRpbWVsaW5lIGJlY2F1c2UgdGhhdCdzIGR1cGxpY2F0aW5nIGVmZm9ydHMgc2luY2Ugd2UgYWxyZWFkeSByZXZlcnRlZCBhbGwgdGhlIHR3ZWVuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAhKHQgaW5zdGFuY2VvZiBUd2VlbikgJiYgdC5yZXZlcnQgJiYgdC5yZXZlcnQocmV2ZXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczQuX3IuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKHJldmVydCwgX3RoaXM0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXM0LmlzUmV2ZXJ0ZWQgPSB0cnVlO1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUua2lsbCAmJiBlLmtpbGwoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIGlmIChtYXRjaE1lZGlhKSB7XG4gICAgICB2YXIgaSA9IF9tZWRpYS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy8gcHJldmlvdXNseSwgd2UgY2hlY2tlZCBfbWVkaWEuaW5kZXhPZih0aGlzKSwgYnV0IHNvbWUgZnJhbWV3b3JrcyBsaWtlIFZ1ZSBlbmZvcmNlIFByb3h5IG9iamVjdHMgdGhhdCBtYWtlIGl0IGltcG9zc2libGUgdG8gZ2V0IHRoZSBwcm9wZXIgcmVzdWx0IHRoYXQgd2F5LCBzbyB3ZSBtdXN0IHVzZSBhIHVuaXF1ZSBJRCBudW1iZXIgaW5zdGVhZC5cbiAgICAgICAgX21lZGlhW2ldLmlkID09PSB0aGlzLmlkICYmIF9tZWRpYS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIGtpbGxXaXRoQ2xlYW51cCgpIHtcbiAgLy8gXHR0aGlzLmtpbGwoKTtcbiAgLy8gXHR0aGlzLl9yLmZvckVhY2goZiA9PiBmKGZhbHNlLCB0aGlzKSk7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90bzUucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGNvbmZpZykge1xuICAgIHRoaXMua2lsbChjb25maWcgfHwge30pO1xuICB9O1xuXG4gIHJldHVybiBDb250ZXh0O1xufSgpO1xuXG52YXIgTWF0Y2hNZWRpYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdGNoTWVkaWEoc2NvcGUpIHtcbiAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIF9jb250ZXh0ICYmIF9jb250ZXh0LmRhdGEucHVzaCh0aGlzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG82ID0gTWF0Y2hNZWRpYS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNi5hZGQgPSBmdW5jdGlvbiBhZGQoY29uZGl0aW9ucywgZnVuYywgc2NvcGUpIHtcbiAgICBfaXNPYmplY3QoY29uZGl0aW9ucykgfHwgKGNvbmRpdGlvbnMgPSB7XG4gICAgICBtYXRjaGVzOiBjb25kaXRpb25zXG4gICAgfSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCgwLCBzY29wZSB8fCB0aGlzLnNjb3BlKSxcbiAgICAgICAgY29uZCA9IGNvbnRleHQuY29uZGl0aW9ucyA9IHt9LFxuICAgICAgICBtcSxcbiAgICAgICAgcCxcbiAgICAgICAgYWN0aXZlO1xuICAgIF9jb250ZXh0ICYmICFjb250ZXh0LnNlbGVjdG9yICYmIChjb250ZXh0LnNlbGVjdG9yID0gX2NvbnRleHQuc2VsZWN0b3IpOyAvLyBpbiBjYXNlIGEgY29udGV4dCBpcyBjcmVhdGVkIGluc2lkZSBhIGNvbnRleHQuIExpa2UgYSBnc2FwLm1hdGNoTWVkaWEoKSB0aGF0J3MgaW5zaWRlIGEgc2NvcGVkIGdzYXAuY29udGV4dCgpXG5cbiAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgZnVuYyA9IGNvbnRleHQuYWRkKFwib25NYXRjaFwiLCBmdW5jKTtcbiAgICBjb250ZXh0LnF1ZXJpZXMgPSBjb25kaXRpb25zO1xuXG4gICAgZm9yIChwIGluIGNvbmRpdGlvbnMpIHtcbiAgICAgIGlmIChwID09PSBcImFsbFwiKSB7XG4gICAgICAgIGFjdGl2ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtcSA9IF93aW4ubWF0Y2hNZWRpYShjb25kaXRpb25zW3BdKTtcblxuICAgICAgICBpZiAobXEpIHtcbiAgICAgICAgICBfbWVkaWEuaW5kZXhPZihjb250ZXh0KSA8IDAgJiYgX21lZGlhLnB1c2goY29udGV4dCk7XG4gICAgICAgICAgKGNvbmRbcF0gPSBtcS5tYXRjaGVzKSAmJiAoYWN0aXZlID0gMSk7XG4gICAgICAgICAgbXEuYWRkTGlzdGVuZXIgPyBtcS5hZGRMaXN0ZW5lcihfb25NZWRpYUNoYW5nZSkgOiBtcS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIF9vbk1lZGlhQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFjdGl2ZSAmJiBmdW5jKGNvbnRleHQsIGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5hZGQobnVsbCwgZik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gcmVmcmVzaCgpIHtcbiAgLy8gXHRsZXQgdGltZSA9IF9sYXN0TWVkaWFUaW1lLFxuICAvLyBcdFx0bWVkaWEgPSBfbWVkaWE7XG4gIC8vIFx0X2xhc3RNZWRpYVRpbWUgPSAtMTtcbiAgLy8gXHRfbWVkaWEgPSB0aGlzLmNvbnRleHRzO1xuICAvLyBcdF9vbk1lZGlhQ2hhbmdlKCk7XG4gIC8vIFx0X2xhc3RNZWRpYVRpbWUgPSB0aW1lO1xuICAvLyBcdF9tZWRpYSA9IG1lZGlhO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG82LnJldmVydCA9IGZ1bmN0aW9uIHJldmVydChjb25maWcpIHtcbiAgICB0aGlzLmtpbGwoY29uZmlnIHx8IHt9KTtcbiAgfTtcblxuICBfcHJvdG82LmtpbGwgPSBmdW5jdGlvbiBraWxsKHJldmVydCkge1xuICAgIHRoaXMuY29udGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMua2lsbChyZXZlcnQsIHRydWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNYXRjaE1lZGlhO1xufSgpO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBHU0FQXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxudmFyIF9nc2FwID0ge1xuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlUGx1Z2luKGNvbmZpZyk7XG4gICAgfSk7XG4gIH0sXG4gIHRpbWVsaW5lOiBmdW5jdGlvbiB0aW1lbGluZSh2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lbGluZSh2YXJzKTtcbiAgfSxcbiAgZ2V0VHdlZW5zT2Y6IGZ1bmN0aW9uIGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpO1xuICB9LFxuICBnZXRQcm9wZXJ0eTogZnVuY3Rpb24gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgIF9pc1N0cmluZyh0YXJnZXQpICYmICh0YXJnZXQgPSB0b0FycmF5KHRhcmdldClbMF0pOyAvL2luIGNhc2Ugc2VsZWN0b3IgdGV4dCBvciBhbiBhcnJheSBpcyBwYXNzZWQgaW5cblxuICAgIHZhciBnZXR0ZXIgPSBfZ2V0Q2FjaGUodGFyZ2V0IHx8IHt9KS5nZXQsXG4gICAgICAgIGZvcm1hdCA9IHVuaXQgPyBfcGFzc1Rocm91Z2ggOiBfbnVtZXJpY0lmUG9zc2libGU7XG5cbiAgICB1bml0ID09PSBcIm5hdGl2ZVwiICYmICh1bml0ID0gXCJcIik7XG4gICAgcmV0dXJuICF0YXJnZXQgPyB0YXJnZXQgOiAhcHJvcGVydHkgPyBmdW5jdGlvbiAocHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiBfcGx1Z2luc1twcm9wZXJ0eV0uZ2V0IHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpO1xuICAgIH0gOiBmb3JtYXQoKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiBfcGx1Z2luc1twcm9wZXJ0eV0uZ2V0IHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpO1xuICB9LFxuICBxdWlja1NldHRlcjogZnVuY3Rpb24gcXVpY2tTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCkge1xuICAgIHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KTtcblxuICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIHNldHRlcnMgPSB0YXJnZXQubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBnc2FwLnF1aWNrU2V0dGVyKHQsIHByb3BlcnR5LCB1bml0KTtcbiAgICAgIH0pLFxuICAgICAgICAgIGwgPSBzZXR0ZXJzLmxlbmd0aDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSBsO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBzZXR0ZXJzW2ldKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXRbMF0gfHwge307XG5cbiAgICB2YXIgUGx1Z2luID0gX3BsdWdpbnNbcHJvcGVydHldLFxuICAgICAgICBjYWNoZSA9IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgICBwID0gY2FjaGUuaGFybmVzcyAmJiAoY2FjaGUuaGFybmVzcy5hbGlhc2VzIHx8IHt9KVtwcm9wZXJ0eV0gfHwgcHJvcGVydHksXG4gICAgICAgIC8vIGluIGNhc2UgaXQncyBhbiBhbGlhcywgbGlrZSBcInJvdGF0ZVwiIGZvciBcInJvdGF0aW9uXCIuXG4gICAgc2V0dGVyID0gUGx1Z2luID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgcCA9IG5ldyBQbHVnaW4oKTtcbiAgICAgIF9xdWlja1R3ZWVuLl9wdCA9IDA7XG4gICAgICBwLmluaXQodGFyZ2V0LCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIF9xdWlja1R3ZWVuLCAwLCBbdGFyZ2V0XSk7XG4gICAgICBwLnJlbmRlcigxLCBwKTtcbiAgICAgIF9xdWlja1R3ZWVuLl9wdCAmJiBfcmVuZGVyUHJvcFR3ZWVucygxLCBfcXVpY2tUd2Vlbik7XG4gICAgfSA6IGNhY2hlLnNldCh0YXJnZXQsIHApO1xuXG4gICAgcmV0dXJuIFBsdWdpbiA/IHNldHRlciA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldHRlcih0YXJnZXQsIHAsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgY2FjaGUsIDEpO1xuICAgIH07XG4gIH0sXG4gIHF1aWNrVG86IGZ1bmN0aW9uIHF1aWNrVG8odGFyZ2V0LCBwcm9wZXJ0eSwgdmFycykge1xuICAgIHZhciBfc2V0RGVmYXVsdHMyO1xuXG4gICAgdmFyIHR3ZWVuID0gZ3NhcC50byh0YXJnZXQsIF9zZXREZWZhdWx0cygoX3NldERlZmF1bHRzMiA9IHt9LCBfc2V0RGVmYXVsdHMyW3Byb3BlcnR5XSA9IFwiKz0wLjFcIiwgX3NldERlZmF1bHRzMi5wYXVzZWQgPSB0cnVlLCBfc2V0RGVmYXVsdHMyLnN0YWdnZXIgPSAwLCBfc2V0RGVmYXVsdHMyKSwgdmFycyB8fCB7fSkpLFxuICAgICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyh2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSkge1xuICAgICAgcmV0dXJuIHR3ZWVuLnJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKTtcbiAgICB9O1xuXG4gICAgZnVuYy50d2VlbiA9IHR3ZWVuO1xuICAgIHJldHVybiBmdW5jO1xuICB9LFxuICBpc1R3ZWVuaW5nOiBmdW5jdGlvbiBpc1R3ZWVuaW5nKHRhcmdldHMpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIHRydWUpLmxlbmd0aCA+IDA7XG4gIH0sXG4gIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cyh2YWx1ZSkge1xuICAgIHZhbHVlICYmIHZhbHVlLmVhc2UgJiYgKHZhbHVlLmVhc2UgPSBfcGFyc2VFYXNlKHZhbHVlLmVhc2UsIF9kZWZhdWx0cy5lYXNlKSk7XG4gICAgcmV0dXJuIF9tZXJnZURlZXAoX2RlZmF1bHRzLCB2YWx1ZSB8fCB7fSk7XG4gIH0sXG4gIGNvbmZpZzogZnVuY3Rpb24gY29uZmlnKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9tZXJnZURlZXAoX2NvbmZpZywgdmFsdWUgfHwge30pO1xuICB9LFxuICByZWdpc3RlckVmZmVjdDogZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QoX3JlZjMpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdCxcbiAgICAgICAgcGx1Z2lucyA9IF9yZWYzLnBsdWdpbnMsXG4gICAgICAgIGRlZmF1bHRzID0gX3JlZjMuZGVmYXVsdHMsXG4gICAgICAgIGV4dGVuZFRpbWVsaW5lID0gX3JlZjMuZXh0ZW5kVGltZWxpbmU7XG4gICAgKHBsdWdpbnMgfHwgXCJcIikuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbk5hbWUpIHtcbiAgICAgIHJldHVybiBwbHVnaW5OYW1lICYmICFfcGx1Z2luc1twbHVnaW5OYW1lXSAmJiAhX2dsb2JhbHNbcGx1Z2luTmFtZV0gJiYgX3dhcm4obmFtZSArIFwiIGVmZmVjdCByZXF1aXJlcyBcIiArIHBsdWdpbk5hbWUgKyBcIiBwbHVnaW4uXCIpO1xuICAgIH0pO1xuXG4gICAgX2VmZmVjdHNbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgdGwpIHtcbiAgICAgIHJldHVybiBlZmZlY3QodG9BcnJheSh0YXJnZXRzKSwgX3NldERlZmF1bHRzKHZhcnMgfHwge30sIGRlZmF1bHRzKSwgdGwpO1xuICAgIH07XG5cbiAgICBpZiAoZXh0ZW5kVGltZWxpbmUpIHtcbiAgICAgIFRpbWVsaW5lLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoX2VmZmVjdHNbbmFtZV0odGFyZ2V0cywgX2lzT2JqZWN0KHZhcnMpID8gdmFycyA6IChwb3NpdGlvbiA9IHZhcnMpICYmIHt9LCB0aGlzKSwgcG9zaXRpb24pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHJlZ2lzdGVyRWFzZTogZnVuY3Rpb24gcmVnaXN0ZXJFYXNlKG5hbWUsIGVhc2UpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9wYXJzZUVhc2UoZWFzZSk7XG4gIH0sXG4gIHBhcnNlRWFzZTogZnVuY3Rpb24gcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSA6IF9lYXNlTWFwO1xuICB9LFxuICBnZXRCeUlkOiBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRCeUlkKGlkKTtcbiAgfSxcbiAgZXhwb3J0Um9vdDogZnVuY3Rpb24gZXhwb3J0Um9vdCh2YXJzLCBpbmNsdWRlRGVsYXllZENhbGxzKSB7XG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IHt9O1xuICAgIH1cblxuICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSh2YXJzKSxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG5leHQ7XG4gICAgdGwuc21vb3RoQ2hpbGRUaW1pbmcgPSBfaXNOb3RGYWxzZSh2YXJzLnNtb290aENoaWxkVGltaW5nKTtcblxuICAgIF9nbG9iYWxUaW1lbGluZS5yZW1vdmUodGwpO1xuXG4gICAgdGwuX2RwID0gMDsgLy9vdGhlcndpc2UgaXQnbGwgZ2V0IHJlLWFjdGl2YXRlZCB3aGVuIGFkZGluZyBjaGlsZHJlbiBhbmQgYmUgcmUtaW50cm9kdWNlZCBpbnRvIF9nbG9iYWxUaW1lbGluZSdzIGxpbmtlZCBsaXN0ICh0aGVuIGFkZGVkIHRvIGl0c2VsZikuXG5cbiAgICB0bC5fdGltZSA9IHRsLl90VGltZSA9IF9nbG9iYWxUaW1lbGluZS5fdGltZTtcbiAgICBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgaWYgKGluY2x1ZGVEZWxheWVkQ2FsbHMgfHwgISghY2hpbGQuX2R1ciAmJiBjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuICYmIGNoaWxkLnZhcnMub25Db21wbGV0ZSA9PT0gY2hpbGQuX3RhcmdldHNbMF0pKSB7XG4gICAgICAgIF9hZGRUb1RpbWVsaW5lKHRsLCBjaGlsZCwgY2hpbGQuX3N0YXJ0IC0gY2hpbGQuX2RlbGF5KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBuZXh0O1xuICAgIH1cblxuICAgIF9hZGRUb1RpbWVsaW5lKF9nbG9iYWxUaW1lbGluZSwgdGwsIDApO1xuXG4gICAgcmV0dXJuIHRsO1xuICB9LFxuICBjb250ZXh0OiBmdW5jdGlvbiBjb250ZXh0KGZ1bmMsIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZ1bmMgPyBuZXcgQ29udGV4dChmdW5jLCBzY29wZSkgOiBfY29udGV4dDtcbiAgfSxcbiAgbWF0Y2hNZWRpYTogZnVuY3Rpb24gbWF0Y2hNZWRpYShzY29wZSkge1xuICAgIHJldHVybiBuZXcgTWF0Y2hNZWRpYShzY29wZSk7XG4gIH0sXG4gIG1hdGNoTWVkaWFSZWZyZXNoOiBmdW5jdGlvbiBtYXRjaE1lZGlhUmVmcmVzaCgpIHtcbiAgICByZXR1cm4gX21lZGlhLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHZhciBjb25kID0gYy5jb25kaXRpb25zLFxuICAgICAgICAgIGZvdW5kLFxuICAgICAgICAgIHA7XG5cbiAgICAgIGZvciAocCBpbiBjb25kKSB7XG4gICAgICAgIGlmIChjb25kW3BdKSB7XG4gICAgICAgICAgY29uZFtwXSA9IGZhbHNlO1xuICAgICAgICAgIGZvdW5kID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3VuZCAmJiBjLnJldmVydCgpO1xuICAgIH0pIHx8IF9vbk1lZGlhQ2hhbmdlKCk7XG4gIH0sXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0gfHwgKF9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG4gICAgfmEuaW5kZXhPZihjYWxsYmFjaykgfHwgYS5wdXNoKGNhbGxiYWNrKTtcbiAgfSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgICAgaSA9IGEgJiYgYS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICBpID49IDAgJiYgYS5zcGxpY2UoaSwgMSk7XG4gIH0sXG4gIHV0aWxzOiB7XG4gICAgd3JhcDogd3JhcCxcbiAgICB3cmFwWW95bzogd3JhcFlveW8sXG4gICAgZGlzdHJpYnV0ZTogZGlzdHJpYnV0ZSxcbiAgICByYW5kb206IHJhbmRvbSxcbiAgICBzbmFwOiBzbmFwLFxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIGdldFVuaXQ6IGdldFVuaXQsXG4gICAgY2xhbXA6IGNsYW1wLFxuICAgIHNwbGl0Q29sb3I6IHNwbGl0Q29sb3IsXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgbWFwUmFuZ2U6IG1hcFJhbmdlLFxuICAgIHBpcGU6IHBpcGUsXG4gICAgdW5pdGl6ZTogdW5pdGl6ZSxcbiAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgc2h1ZmZsZTogc2h1ZmZsZVxuICB9LFxuICBpbnN0YWxsOiBfaW5zdGFsbCxcbiAgZWZmZWN0czogX2VmZmVjdHMsXG4gIHRpY2tlcjogX3RpY2tlcixcbiAgdXBkYXRlUm9vdDogVGltZWxpbmUudXBkYXRlUm9vdCxcbiAgcGx1Z2luczogX3BsdWdpbnMsXG4gIGdsb2JhbFRpbWVsaW5lOiBfZ2xvYmFsVGltZWxpbmUsXG4gIGNvcmU6IHtcbiAgICBQcm9wVHdlZW46IFByb3BUd2VlbixcbiAgICBnbG9iYWxzOiBfYWRkR2xvYmFsLFxuICAgIFR3ZWVuOiBUd2VlbixcbiAgICBUaW1lbGluZTogVGltZWxpbmUsXG4gICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgZ2V0Q2FjaGU6IF9nZXRDYWNoZSxcbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW06IF9yZW1vdmVMaW5rZWRMaXN0SXRlbSxcbiAgICByZXZlcnRpbmc6IGZ1bmN0aW9uIHJldmVydGluZygpIHtcbiAgICAgIHJldHVybiBfcmV2ZXJ0aW5nO1xuICAgIH0sXG4gICAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dCh0b0FkZCkge1xuICAgICAgaWYgKHRvQWRkICYmIF9jb250ZXh0KSB7XG4gICAgICAgIF9jb250ZXh0LmRhdGEucHVzaCh0b0FkZCk7XG5cbiAgICAgICAgdG9BZGQuX2N0eCA9IF9jb250ZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2NvbnRleHQ7XG4gICAgfSxcbiAgICBzdXBwcmVzc092ZXJ3cml0ZXM6IGZ1bmN0aW9uIHN1cHByZXNzT3ZlcndyaXRlcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbl9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLGRlbGF5ZWRDYWxsLHNldCxraWxsVHdlZW5zT2ZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9nc2FwW25hbWVdID0gVHdlZW5bbmFtZV07XG59KTtcblxuX3RpY2tlci5hZGQoVGltZWxpbmUudXBkYXRlUm9vdCk7XG5cbl9xdWlja1R3ZWVuID0gX2dzYXAudG8oe30sIHtcbiAgZHVyYXRpb246IDBcbn0pOyAvLyAtLS0tIEVYVFJBIFBMVUdJTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIF9nZXRQbHVnaW5Qcm9wVHdlZW4gPSBmdW5jdGlvbiBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHBsdWdpbiwgcHJvcCkge1xuICB2YXIgcHQgPSBwbHVnaW4uX3B0O1xuXG4gIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wICYmIHB0Lm9wICE9PSBwcm9wICYmIHB0LmZwICE9PSBwcm9wKSB7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZE1vZGlmaWVycyA9IGZ1bmN0aW9uIF9hZGRNb2RpZmllcnModHdlZW4sIG1vZGlmaWVycykge1xuICB2YXIgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcCxcbiAgICAgIGksXG4gICAgICBwdDtcblxuICBmb3IgKHAgaW4gbW9kaWZpZXJzKSB7XG4gICAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHQgPSB0d2Vlbi5fcHRMb29rdXBbaV1bcF07XG5cbiAgICAgIGlmIChwdCAmJiAocHQgPSBwdC5kKSkge1xuICAgICAgICBpZiAocHQuX3B0KSB7XG4gICAgICAgICAgLy8gaXMgYSBwbHVnaW5cbiAgICAgICAgICBwdCA9IF9nZXRQbHVnaW5Qcm9wVHdlZW4ocHQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcHQgJiYgcHQubW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXJzW3BdLCB0d2VlbiwgdGFyZ2V0c1tpXSwgcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuICAgIF9idWlsZE1vZGlmaWVyUGx1Z2luID0gZnVuY3Rpb24gX2J1aWxkTW9kaWZpZXJQbHVnaW4obmFtZSwgbW9kaWZpZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGhlYWRsZXNzOiAxLFxuICAgIHJhd1ZhcnM6IDEsXG4gICAgLy9kb24ndCBwcmUtcHJvY2VzcyBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgb3IgXCJyYW5kb20oKVwiIHN0cmluZ3MuXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG4gICAgICB0d2Vlbi5fb25Jbml0ID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgIHZhciB0ZW1wLCBwO1xuXG4gICAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wW25hbWVdID0gMTtcbiAgICAgICAgICB9KTsgLy9pZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0byByb3VuZFByb3BzLCBsaWtlIFwieCx5XCIsIHdlIHJvdW5kIHRvIHdob2xlIG51bWJlcnMuXG5cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgICAgIHRlbXBbcF0gPSBtb2RpZmllcih2YXJzW3BdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXJzID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hZGRNb2RpZmllcnModHdlZW4sIHZhcnMpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59OyAvL3JlZ2lzdGVyIGNvcmUgcGx1Z2luc1xuXG5cbmV4cG9ydCB2YXIgZ3NhcCA9IF9nc2FwLnJlZ2lzdGVyUGx1Z2luKHtcbiAgbmFtZTogXCJhdHRyXCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICB2YXIgcCwgcHQsIHY7XG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIHYgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKHApIHx8IFwiXCI7XG4gICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHYgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICBwdC5vcCA9IHA7XG4gICAgICBwdC5iID0gdjsgLy8gcmVjb3JkIHRoZSBiZWdpbm5pbmcgdmFsdWUgc28gd2UgY2FuIHJldmVydCgpXG5cbiAgICAgIHRoaXMuX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBfcmV2ZXJ0aW5nID8gcHQuc2V0KHB0LnQsIHB0LnAsIHB0LmIsIHB0KSA6IHB0LnIocmF0aW8sIHB0LmQpOyAvLyBpZiByZXZlcnRpbmcsIGdvIGJhY2sgdG8gdGhlIG9yaWdpbmFsIChwdC5iKVxuXG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiBcImVuZEFycmF5XCIsXG4gIGhlYWRsZXNzOiAxLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldLCAwLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjE0LjJcIjtcbl9jb3JlUmVhZHkgPSAxO1xuX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG52YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcbiAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcbiAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcbiAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxuICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXG4gICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxuICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuZXhwb3J0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5cbmV4cG9ydCB7IF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX3JlcGxhY2VSYW5kb20sIF9jaGVja1BsdWdpbiwgX3BsdWdpbnMsIF90aWNrZXIsIF9jb25maWcsIF9yb3VuZE1vZGlmaWVyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUgfTsiXSwibmFtZXMiOlsiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfX3Byb3RvX18iLCJfY29uZmlnIiwiYXV0b1NsZWVwIiwiZm9yY2UzRCIsIm51bGxUYXJnZXRXYXJuIiwidW5pdHMiLCJsaW5lSGVpZ2h0IiwiX2RlZmF1bHRzIiwiZHVyYXRpb24iLCJvdmVyd3JpdGUiLCJkZWxheSIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfcmV2ZXJ0aW5nIiwiX2NvbnRleHQiLCJfYmlnTnVtIiwiX3RpbnlOdW0iLCJfMlBJIiwiTWF0aCIsIlBJIiwiX0hBTEZfUEkiLCJfZ3NJRCIsIl9zcXJ0Iiwic3FydCIsIl9jb3MiLCJjb3MiLCJfc2luIiwic2luIiwiX2lzU3RyaW5nIiwidmFsdWUiLCJfaXNGdW5jdGlvbiIsIl9pc051bWJlciIsIl9pc1VuZGVmaW5lZCIsIl9pc09iamVjdCIsIl9pc05vdEZhbHNlIiwiX3dpbmRvd0V4aXN0cyIsIl9pc0Z1bmNPclN0cmluZyIsIl9pc1R5cGVkQXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIl9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiX3JhbmRvbUV4cCIsIl9jb21tYURlbGltRXhwIiwiX3N0cmljdE51bUV4cCIsIl9udW1FeHAiLCJfbnVtV2l0aFVuaXRFeHAiLCJfY29tcGxleFN0cmluZ051bUV4cCIsIl9yZWxFeHAiLCJfZGVsaW1pdGVkVmFsdWVFeHAiLCJfdW5pdEV4cCIsIl9nbG9iYWxUaW1lbGluZSIsIl93aW4iLCJfY29yZUluaXR0ZWQiLCJfZG9jIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwic2NvcGUiLCJfbWVyZ2UiLCJnc2FwIiwiX21pc3NpbmdQbHVnaW4iLCJwcm9wZXJ0eSIsImNvbnNvbGUiLCJ3YXJuIiwiX3dhcm4iLCJtZXNzYWdlIiwic3VwcHJlc3MiLCJfYWRkR2xvYmFsIiwibmFtZSIsIm9iaiIsIl9lbXB0eUZ1bmMiLCJfc3RhcnRBdFJldmVydENvbmZpZyIsInN1cHByZXNzRXZlbnRzIiwiaXNTdGFydCIsImtpbGwiLCJfcmV2ZXJ0Q29uZmlnTm9LaWxsIiwiX3JldmVydENvbmZpZyIsIl9yZXNlcnZlZFByb3BzIiwiX2xhenlUd2VlbnMiLCJfbGF6eUxvb2t1cCIsIl9sYXN0UmVuZGVyZWRGcmFtZSIsIl9wbHVnaW5zIiwiX2VmZmVjdHMiLCJfbmV4dEdDRnJhbWUiLCJfaGFybmVzc1BsdWdpbnMiLCJfY2FsbGJhY2tOYW1lcyIsIl9oYXJuZXNzIiwidGFyZ2V0cyIsInRhcmdldCIsImhhcm5lc3NQbHVnaW4iLCJpIiwiX2dzYXAiLCJoYXJuZXNzIiwibGVuZ3RoIiwidGFyZ2V0VGVzdCIsIkdTQ2FjaGUiLCJzcGxpY2UiLCJfZ2V0Q2FjaGUiLCJ0b0FycmF5IiwiX2dldFByb3BlcnR5IiwidiIsImdldEF0dHJpYnV0ZSIsIl9mb3JFYWNoTmFtZSIsIm5hbWVzIiwiZnVuYyIsInNwbGl0IiwiZm9yRWFjaCIsIl9yb3VuZCIsInJvdW5kIiwiX3JvdW5kUHJlY2lzZSIsIl9wYXJzZVJlbGF0aXZlIiwic3RhcnQiLCJvcGVyYXRvciIsImNoYXJBdCIsImVuZCIsInBhcnNlRmxvYXQiLCJzdWJzdHIiLCJfYXJyYXlDb250YWluc0FueSIsInRvU2VhcmNoIiwidG9GaW5kIiwibCIsImluZGV4T2YiLCJfbGF6eVJlbmRlciIsImEiLCJzbGljZSIsInR3ZWVuIiwiX2xhenkiLCJyZW5kZXIiLCJfaXNSZXZlcnRXb3J0aHkiLCJhbmltYXRpb24iLCJfaW5pdHRlZCIsIl9zdGFydEF0IiwiYWRkIiwiX2xhenlTYWZlUmVuZGVyIiwidGltZSIsImZvcmNlIiwiX251bWVyaWNJZlBvc3NpYmxlIiwibiIsIm1hdGNoIiwidHJpbSIsIl9wYXNzVGhyb3VnaCIsInAiLCJfc2V0RGVmYXVsdHMiLCJkZWZhdWx0cyIsIl9zZXRLZXlmcmFtZURlZmF1bHRzIiwiZXhjbHVkZUR1cmF0aW9uIiwiYmFzZSIsInRvTWVyZ2UiLCJfbWVyZ2VEZWVwIiwiX2NvcHlFeGNsdWRpbmciLCJleGNsdWRpbmciLCJjb3B5IiwiX2luaGVyaXREZWZhdWx0cyIsInZhcnMiLCJwYXJlbnQiLCJrZXlmcmFtZXMiLCJpbmhlcml0IiwiX2RwIiwiX2FycmF5c01hdGNoIiwiYTEiLCJhMiIsIl9hZGRMaW5rZWRMaXN0SXRlbSIsImNoaWxkIiwiZmlyc3RQcm9wIiwibGFzdFByb3AiLCJzb3J0QnkiLCJwcmV2IiwidCIsIl9wcmV2IiwiX25leHQiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJuZXh0IiwiX3JlbW92ZUZyb21QYXJlbnQiLCJvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIiwiYXV0b1JlbW92ZUNoaWxkcmVuIiwicmVtb3ZlIiwiX2FjdCIsIl91bmNhY2hlIiwiX2VuZCIsIl9kdXIiLCJfc3RhcnQiLCJfZGlydHkiLCJfcmVjYWNoZUFuY2VzdG9ycyIsInRvdGFsRHVyYXRpb24iLCJfcmV3aW5kU3RhcnRBdCIsInRvdGFsVGltZSIsInJldmVydCIsImltbWVkaWF0ZVJlbmRlciIsImF1dG9SZXZlcnQiLCJfaGFzTm9QYXVzZWRBbmNlc3RvcnMiLCJfdHMiLCJfZWxhcHNlZEN5Y2xlRHVyYXRpb24iLCJfcmVwZWF0IiwiX2FuaW1hdGlvbkN5Y2xlIiwiX3RUaW1lIiwiX3JEZWxheSIsInRUaW1lIiwiY3ljbGVEdXJhdGlvbiIsIndob2xlIiwiZmxvb3IiLCJfcGFyZW50VG9DaGlsZFRvdGFsVGltZSIsInBhcmVudFRpbWUiLCJfdER1ciIsIl9zZXRFbmQiLCJhYnMiLCJfcnRzIiwiX2FsaWduUGxheWhlYWQiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl90aW1lIiwiX3Bvc3RBZGRDaGVja3MiLCJ0aW1lbGluZSIsInJhd1RpbWUiLCJfY2xhbXAiLCJfelRpbWUiLCJfYWRkVG9UaW1lbGluZSIsInBvc2l0aW9uIiwic2tpcENoZWNrcyIsIl9wYXJzZVBvc2l0aW9uIiwiX2RlbGF5IiwidGltZVNjYWxlIiwiX3NvcnQiLCJfaXNGcm9tT3JGcm9tU3RhcnQiLCJfcmVjZW50IiwiX3Njcm9sbFRyaWdnZXIiLCJ0cmlnZ2VyIiwiU2Nyb2xsVHJpZ2dlciIsIl9hdHRlbXB0SW5pdFR3ZWVuIiwiX2luaXRUd2VlbiIsIl9wdCIsImxhenkiLCJfdGlja2VyIiwiZnJhbWUiLCJwdXNoIiwiX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCIsIl9yZWYiLCJfbG9jayIsIl9yZWYyIiwiZGF0YSIsIl9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiIsInByZXZSYXRpbyIsInJhdGlvIiwicmVwZWF0RGVsYXkiLCJwdCIsIml0ZXJhdGlvbiIsInByZXZJdGVyYXRpb24iLCJfeW95byIsInJlcGVhdFJlZnJlc2giLCJpbnZhbGlkYXRlIiwiX2Zyb20iLCJyIiwiZCIsIl9vblVwZGF0ZSIsIl9jYWxsYmFjayIsIl9wcm9tIiwiX2ZpbmROZXh0UGF1c2VUd2VlbiIsInByZXZUaW1lIiwiX2ZpcnN0IiwiX2xhc3QiLCJfc2V0RHVyYXRpb24iLCJza2lwVW5jYWNoZSIsImxlYXZlUGxheWhlYWQiLCJyZXBlYXQiLCJkdXIiLCJ0b3RhbFByb2dyZXNzIiwiX29uVXBkYXRlVG90YWxEdXJhdGlvbiIsIlRpbWVsaW5lIiwiX3plcm9Qb3NpdGlvbiIsImVuZFRpbWUiLCJwZXJjZW50QW5pbWF0aW9uIiwibGFiZWxzIiwicmVjZW50IiwiY2xpcHBlZER1cmF0aW9uIiwib2Zmc2V0IiwiaXNQZXJjZW50IiwiaXNOYU4iLCJyZXBsYWNlIiwiX2NyZWF0ZVR3ZWVuVHlwZSIsInR5cGUiLCJwYXJhbXMiLCJpc0xlZ2FjeSIsInZhcnNJbmRleCIsImlyVmFycyIsInJ1bkJhY2t3YXJkcyIsInN0YXJ0QXQiLCJUd2VlbiIsIl9jb25kaXRpb25hbFJldHVybiIsIm1pbiIsIm1heCIsImdldFVuaXQiLCJleGVjIiwiY2xhbXAiLCJfc2xpY2UiLCJfaXNBcnJheUxpa2UiLCJub25FbXB0eSIsIm5vZGVUeXBlIiwiX2ZsYXR0ZW4iLCJhciIsImxlYXZlU3RyaW5ncyIsImFjY3VtdWxhdG9yIiwiX2FjY3VtdWxhdG9yIiwiYXBwbHkiLCJzZWxlY3RvciIsIl93YWtlIiwiY2FsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJlbCIsImN1cnJlbnQiLCJuYXRpdmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsInNodWZmbGUiLCJzb3J0IiwicmFuZG9tIiwiZGlzdHJpYnV0ZSIsImVhY2giLCJlYXNlIiwiX3BhcnNlRWFzZSIsImZyb20iLCJjYWNoZSIsImlzRGVjaW1hbCIsInJhdGlvcyIsImF4aXMiLCJyYXRpb1giLCJyYXRpb1kiLCJjZW50ZXIiLCJlZGdlcyIsImRpc3RhbmNlcyIsIm9yaWdpblgiLCJvcmlnaW5ZIiwieCIsInkiLCJqIiwid3JhcEF0IiwiZ3JpZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJhbW91bnQiLCJiIiwidSIsIl9pbnZlcnRFYXNlIiwiX3JvdW5kTW9kaWZpZXIiLCJwb3ciLCJyYXciLCJzbmFwIiwic25hcFRvIiwicmFkaXVzIiwiaXMyRCIsInZhbHVlcyIsImluY3JlbWVudCIsImNsb3Nlc3QiLCJkeCIsImR5Iiwicm91bmRpbmdJbmNyZW1lbnQiLCJyZXR1cm5GdW5jdGlvbiIsInBpcGUiLCJfbGVuIiwiYXJndW1lbnRzIiwiZnVuY3Rpb25zIiwiX2tleSIsInJlZHVjZSIsImYiLCJ1bml0aXplIiwidW5pdCIsIm5vcm1hbGl6ZSIsIm1hcFJhbmdlIiwiX3dyYXBBcnJheSIsIndyYXBwZXIiLCJpbmRleCIsIndyYXAiLCJyYW5nZSIsIndyYXBZb3lvIiwidG90YWwiLCJfcmVwbGFjZVJhbmRvbSIsInMiLCJhckluZGV4Iiwic3Vic3RyaW5nIiwiaW5NaW4iLCJpbk1heCIsIm91dE1pbiIsIm91dE1heCIsImluUmFuZ2UiLCJvdXRSYW5nZSIsImludGVycG9sYXRlIiwicHJvZ3Jlc3MiLCJtdXRhdGUiLCJpc1N0cmluZyIsIm1hc3RlciIsImludGVycG9sYXRvcnMiLCJpbCIsIl9hZGRQcm9wVHdlZW4iLCJfcmVuZGVyUHJvcFR3ZWVucyIsIl9nZXRMYWJlbEluRGlyZWN0aW9uIiwiZnJvbVRpbWUiLCJiYWNrd2FyZCIsImRpc3RhbmNlIiwibGFiZWwiLCJleGVjdXRlTGF6eUZpcnN0IiwiY2FsbGJhY2siLCJwcmV2Q29udGV4dCIsImNvbnRleHQiLCJfY3R4IiwicmVzdWx0IiwiY2FsbGJhY2tTY29wZSIsIl9pbnRlcnJ1cHQiLCJzY3JvbGxUcmlnZ2VyIiwiX3F1aWNrVHdlZW4iLCJfcmVnaXN0ZXJQbHVnaW5RdWV1ZSIsIl9jcmVhdGVQbHVnaW4iLCJjb25maWciLCJoZWFkbGVzcyIsImlzRnVuYyIsIlBsdWdpbiIsImluaXQiLCJfcHJvcHMiLCJpbnN0YW5jZURlZmF1bHRzIiwiX2tpbGxQcm9wVHdlZW5zT2YiLCJtb2RpZmllciIsIl9hZGRQbHVnaW5Nb2RpZmllciIsInJhd1ZhcnMiLCJzdGF0aWNzIiwiZ2V0IiwiZ2V0U2V0dGVyIiwiX2dldFNldHRlciIsImFsaWFzZXMiLCJyZWdpc3RlciIsInByb3AiLCJ0b1VwcGVyQ2FzZSIsIlByb3BUd2VlbiIsIl8yNTUiLCJfY29sb3JMb29rdXAiLCJhcXVhIiwibGltZSIsInNpbHZlciIsImJsYWNrIiwibWFyb29uIiwidGVhbCIsImJsdWUiLCJuYXZ5Iiwid2hpdGUiLCJvbGl2ZSIsInllbGxvdyIsIm9yYW5nZSIsImdyYXkiLCJwdXJwbGUiLCJncmVlbiIsInJlZCIsInBpbmsiLCJjeWFuIiwidHJhbnNwYXJlbnQiLCJfaHVlIiwiaCIsIm0xIiwibTIiLCJzcGxpdENvbG9yIiwidG9IU0wiLCJmb3JjZUFscGhhIiwiZyIsIndhc0hTTCIsInBhcnNlSW50IiwibWFwIiwiTnVtYmVyIiwiX2NvbG9yT3JkZXJEYXRhIiwiYyIsIl9jb2xvckV4cCIsIl9mb3JtYXRDb2xvcnMiLCJvcmRlck1hdGNoRGF0YSIsImNvbG9ycyIsInNoZWxsIiwiY29sb3IiLCJqb2luIiwic2hpZnQiLCJSZWdFeHAiLCJfaHNsRXhwIiwiX2NvbG9yU3RyaW5nRmlsdGVyIiwiY29tYmluZWQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwiX3RpY2tlckFjdGl2ZSIsIl9nZXRUaW1lIiwiRGF0ZSIsIm5vdyIsIl9sYWdUaHJlc2hvbGQiLCJfYWRqdXN0ZWRMYWciLCJfc3RhcnRUaW1lIiwiX2xhc3RVcGRhdGUiLCJfZ2FwIiwiX25leHRUaW1lIiwiX2xpc3RlbmVycyIsIl9pZCIsIl9yZXEiLCJfcmFmIiwiX3NlbGYiLCJfZGVsdGEiLCJfaSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsIm92ZXJsYXAiLCJkaXNwYXRjaCIsInRpY2siLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsIndpbmRvdyIsImRvY3VtZW50IiwiZ3NhcFZlcnNpb25zIiwidmVyc2lvbiIsIkdyZWVuU29ja0dsb2JhbHMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzbGVlcCIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImxhZ1Ntb290aGluZyIsInRocmVzaG9sZCIsImFkanVzdGVkTGFnIiwiSW5maW5pdHkiLCJfZnBzIiwib25jZSIsInByaW9yaXRpemUiLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwia2V5IiwidmFsIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwib3BlbiIsImNsb3NlIiwibmVzdGVkIiwiX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nIiwiX0NFIiwiX3Byb3BhZ2F0ZVlveW9FYXNlIiwiaXNZb3lvIiwieW95b0Vhc2UiLCJfZWFzZSIsIl95RWFzZSIsImRlZmF1bHRFYXNlIiwiX2luc2VydEVhc2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwibG93ZXJjYXNlTmFtZSIsInRvTG93ZXJDYXNlIiwiX2Vhc2VJbk91dEZyb21PdXQiLCJfY29uZmlnRWxhc3RpYyIsImFtcGxpdHVkZSIsInBlcmlvZCIsInAxIiwicDIiLCJwMyIsImFzaW4iLCJfY29uZmlnQmFjayIsIm92ZXJzaG9vdCIsInBvd2VyIiwiTGluZWFyIiwiZWFzZU5vbmUiLCJub25lIiwibjEiLCJuMiIsIm4zIiwiU3RlcHBlZEVhc2UiLCJzdGVwcyIsImltbWVkaWF0ZVN0YXJ0IiwiaWQiLCJzZXQiLCJBbmltYXRpb24iLCJ5b3lvIiwiX3Byb3RvIiwic3RhcnRUaW1lIiwiX3RvdGFsVGltZSIsIl9wdExvb2t1cCIsIl9wVGltZSIsIl9wcyIsInBhdXNlZCIsImluY2x1ZGVSZXBlYXRzIiwid3JhcFJlcGVhdHMiLCJwcmV2SXNSZXZlcnRpbmciLCJnbG9iYWxUaW1lIiwiX3NhdCIsInNlZWsiLCJyZXN0YXJ0IiwiaW5jbHVkZURlbGF5IiwicGxheSIsInJldmVyc2VkIiwicmV2ZXJzZSIsInBhdXNlIiwiYXRUaW1lIiwicmVzdW1lIiwiaXNBY3RpdmUiLCJldmVudENhbGxiYWNrIiwidGhlbiIsIm9uRnVsZmlsbGVkIiwicHJldlByb20iLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9yZXNvbHZlIiwiX3RoZW4iLCJfQW5pbWF0aW9uIiwiX3RoaXMiLCJzb3J0Q2hpbGRyZW4iLCJfcHJvdG8yIiwidG8iLCJmcm9tVG8iLCJmcm9tVmFycyIsInRvVmFycyIsImRlbGF5ZWRDYWxsIiwic3RhZ2dlclRvIiwic3RhZ2dlciIsIm9uQ29tcGxldGVBbGwiLCJvbkNvbXBsZXRlQWxsUGFyYW1zIiwib25Db21wbGV0ZSIsIm9uQ29tcGxldGVQYXJhbXMiLCJzdGFnZ2VyRnJvbSIsInN0YWdnZXJGcm9tVG8iLCJ0RHVyIiwiY3Jvc3NpbmdTdGFydCIsInByZXZQYXVzZWQiLCJwYXVzZVR3ZWVuIiwicHJldlN0YXJ0IiwicmV3aW5kaW5nIiwiZG9lc1dyYXAiLCJvblJlcGVhdCIsIl9oYXNQYXVzZSIsIl9mb3JjaW5nIiwib25VcGRhdGUiLCJhZGp1c3RlZFRpbWUiLCJfdGhpczIiLCJhZGRMYWJlbCIsImdldENoaWxkcmVuIiwidHdlZW5zIiwidGltZWxpbmVzIiwiaWdub3JlQmVmb3JlVGltZSIsImdldEJ5SWQiLCJhbmltYXRpb25zIiwicmVtb3ZlTGFiZWwiLCJraWxsVHdlZW5zT2YiLCJfdG90YWxUaW1lMiIsImFkZFBhdXNlIiwicmVtb3ZlUGF1c2UiLCJwcm9wcyIsIm9ubHlBY3RpdmUiLCJnZXRUd2VlbnNPZiIsIl9vdmVyd3JpdGluZ1R3ZWVuIiwicGFyc2VkVGFyZ2V0cyIsImlzR2xvYmFsVGltZSIsImNoaWxkcmVuIiwiX3RhcmdldHMiLCJ0d2VlblRvIiwidGwiLCJfdmFycyIsIl9vblN0YXJ0Iiwib25TdGFydCIsIm9uU3RhcnRQYXJhbXMiLCJpbml0dGVkIiwidHdlZW5Gcm9tVG8iLCJmcm9tUG9zaXRpb24iLCJ0b1Bvc2l0aW9uIiwibmV4dExhYmVsIiwiYWZ0ZXJUaW1lIiwicHJldmlvdXNMYWJlbCIsImJlZm9yZVRpbWUiLCJjdXJyZW50TGFiZWwiLCJzaGlmdENoaWxkcmVuIiwiYWRqdXN0TGFiZWxzIiwic29mdCIsImNsZWFyIiwiaW5jbHVkZUxhYmVscyIsInVwZGF0ZVJvb3QiLCJfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiIsInNldHRlciIsInN0cmluZ0ZpbHRlciIsImZ1bmNQYXJhbSIsIl9yZW5kZXJDb21wbGV4U3RyaW5nIiwibWF0Y2hJbmRleCIsInN0YXJ0TnVtcyIsImVuZE51bSIsImNodW5rIiwic3RhcnROdW0iLCJoYXNSYW5kb20iLCJlIiwibSIsImZwIiwib3B0aW9uYWwiLCJjdXJyZW50VmFsdWUiLCJwYXJzZWRTdGFydCIsIl9zZXR0ZXJQbGFpbiIsIl9zZXR0ZXJGdW5jV2l0aFBhcmFtIiwiX3NldHRlckZ1bmMiLCJfZm9yY2VBbGxQcm9wVHdlZW5zIiwiX3JlbmRlckJvb2xlYW4iLCJfcmVuZGVyUGxhaW4iLCJfcHJvY2Vzc1ZhcnMiLCJfcGFyc2VGdW5jT3JTdHJpbmciLCJzdHlsZSIsIl9jaGVja1BsdWdpbiIsInBsdWdpbiIsInB0TG9va3VwIiwicHJpb3JpdHkiLCJwcmV2U3RhcnRBdCIsImZ1bGxUYXJnZXRzIiwiYXV0b092ZXJ3cml0ZSIsIl9vdmVyd3JpdGUiLCJjbGVhblZhcnMiLCJoYXNQcmlvcml0eSIsImdzRGF0YSIsImhhcm5lc3NWYXJzIiwib3ZlcndyaXR0ZW4iLCJfcHRDYWNoZSIsIl9vcCIsIl9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkiLCJfb25Jbml0IiwiX3VwZGF0ZVByb3BUd2VlbnMiLCJzdGFydElzUmVsYXRpdmUiLCJza2lwUmVjdXJzaW9uIiwicHRDYWNoZSIsInJvb3RQVCIsImxvb2t1cCIsIl9hZGRBbGlhc2VzVG9WYXJzIiwicHJvcGVydHlBbGlhc2VzIiwiX3BhcnNlS2V5ZnJhbWUiLCJhbGxQcm9wcyIsImVhc2VFYWNoIiwiX3N0YWdnZXJUd2VlblByb3BzIiwiX3N0YWdnZXJQcm9wc1RvU2tpcCIsIl9BbmltYXRpb24yIiwic2tpcEluaGVyaXQiLCJfdGhpczMiLCJfdGhpczMkdmFycyIsImN1clRhcmdldCIsInN0YWdnZXJGdW5jIiwic3RhZ2dlclZhcnNUb01lcmdlIiwia2YiLCJfcHJvdG8zIiwiaXNOZWdhdGl2ZSIsInJlc2V0VG8iLCJraWxsaW5nVGFyZ2V0cyIsInByb3BUd2Vlbkxvb2t1cCIsImZpcnN0UFQiLCJvdmVyd3JpdHRlblByb3BzIiwiY3VyTG9va3VwIiwiY3VyT3ZlcndyaXRlUHJvcHMiLCJvblJldmVyc2VDb21wbGV0ZSIsIm9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zIiwiX3NldHRlckF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImhhc05vbkRlcGVuZGVudFJlbWFpbmluZyIsIm9wIiwiZGVwIiwiX3NldHRlcldpdGhNb2RpZmllciIsIm1TZXQiLCJtdCIsInB0MiIsImZpcnN0IiwibGFzdCIsInByIiwiY2hhbmdlIiwicmVuZGVyZXIiLCJfcHJvdG80IiwiVHdlZW5NYXgiLCJUd2VlbkxpdGUiLCJUaW1lbGluZUxpdGUiLCJUaW1lbGluZU1heCIsIl9tZWRpYSIsIl9lbXB0eUFycmF5IiwiX2xhc3RNZWRpYVRpbWUiLCJfY29udGV4dElEIiwiX2Rpc3BhdGNoIiwiX29uTWVkaWFDaGFuZ2UiLCJtYXRjaGVzIiwicXVlcmllcyIsImNvbmRpdGlvbnMiLCJhbnlNYXRjaCIsInRvZ2dsZWQiLCJtYXRjaE1lZGlhIiwib25NYXRjaCIsIkNvbnRleHQiLCJfciIsImlzUmV2ZXJ0ZWQiLCJfcHJvdG81IiwicHJldlNlbGVjdG9yIiwiaWdub3JlIiwiZ2V0VHdlZW5zIiwiX3RoaXM0IiwibyIsIk1hdGNoTWVkaWEiLCJjb250ZXh0cyIsIl9wcm90bzYiLCJjb25kIiwibXEiLCJhY3RpdmUiLCJhZGRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWdpc3RlclBsdWdpbiIsIl9sZW4yIiwiYXJncyIsIl9rZXkyIiwiZ2V0UHJvcGVydHkiLCJ1bmNhY2hlIiwiZ2V0dGVyIiwiZm9ybWF0IiwicXVpY2tTZXR0ZXIiLCJzZXR0ZXJzIiwicXVpY2tUbyIsIl9zZXREZWZhdWx0czIiLCJpc1R3ZWVuaW5nIiwicmVnaXN0ZXJFZmZlY3QiLCJfcmVmMyIsImVmZmVjdCIsInBsdWdpbnMiLCJleHRlbmRUaW1lbGluZSIsInBsdWdpbk5hbWUiLCJyZWdpc3RlckVhc2UiLCJwYXJzZUVhc2UiLCJleHBvcnRSb290IiwiaW5jbHVkZURlbGF5ZWRDYWxscyIsIm1hdGNoTWVkaWFSZWZyZXNoIiwiZm91bmQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXRpbHMiLCJpbnN0YWxsIiwiZWZmZWN0cyIsInRpY2tlciIsImdsb2JhbFRpbWVsaW5lIiwiY29yZSIsImdsb2JhbHMiLCJnZXRDYWNoZSIsInJldmVydGluZyIsInRvQWRkIiwic3VwcHJlc3NPdmVyd3JpdGVzIiwiX2dldFBsdWdpblByb3BUd2VlbiIsIl9hZGRNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJfYnVpbGRNb2RpZmllclBsdWdpbiIsInRlbXAiLCJQb3dlcjAiLCJQb3dlcjEiLCJQb3dlcjIiLCJQb3dlcjMiLCJQb3dlcjQiLCJRdWFkIiwiQ3ViaWMiLCJRdWFydCIsIlF1aW50IiwiU3Ryb25nIiwiRWxhc3RpYyIsIkJhY2siLCJCb3VuY2UiLCJTaW5lIiwiRXhwbyIsIkNpcmMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/gsap/gsap-core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back; },\n/* harmony export */   Bounce: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce; },\n/* harmony export */   CSSPlugin: function() { return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin; },\n/* harmony export */   Circ: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ; },\n/* harmony export */   Cubic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic; },\n/* harmony export */   Elastic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic; },\n/* harmony export */   Expo: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo; },\n/* harmony export */   Linear: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear; },\n/* harmony export */   Power0: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0; },\n/* harmony export */   Power1: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1; },\n/* harmony export */   Power2: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2; },\n/* harmony export */   Power3: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3; },\n/* harmony export */   Power4: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4; },\n/* harmony export */   Quad: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad; },\n/* harmony export */   Quart: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart; },\n/* harmony export */   Quint: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint; },\n/* harmony export */   Sine: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine; },\n/* harmony export */   SteppedEase: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase; },\n/* harmony export */   Strong: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong; },\n/* harmony export */   TimelineLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite; },\n/* harmony export */   TimelineMax: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax; },\n/* harmony export */   TweenLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite; },\n/* harmony export */   TweenMax: function() { return /* binding */ TweenMaxWithCSS; },\n/* harmony export */   \"default\": function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   gsap: function() { return /* binding */ gsapWithCSS; }\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"(app-pages-browser)/./node_modules/gsap/CSSPlugin.js\");\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap, // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nc2FwL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxTjtBQUMxSztBQUMzQyxJQUFJdUIsY0FBY3ZCLCtDQUFJQSxDQUFDd0IsY0FBYyxDQUFDRixvREFBU0EsS0FBS3RCLCtDQUFJQSxFQUNwRCwrQkFBK0I7QUFDbkN5QixrQkFBa0JGLFlBQVlHLElBQUksQ0FBQ0MsS0FBSztBQUNzTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcz8xOGU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdzYXAsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYywgVHdlZW5MaXRlLCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4IH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5pbXBvcnQgeyBDU1NQbHVnaW4gfSBmcm9tIFwiLi9DU1NQbHVnaW4uanNcIjtcbnZhciBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLFxuICAgIC8vIHRvIHByb3RlY3QgZnJvbSB0cmVlIHNoYWtpbmdcblR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5leHBvcnQgeyBnc2FwV2l0aENTUyBhcyBnc2FwLCBnc2FwV2l0aENTUyBhcyBkZWZhdWx0LCBDU1NQbHVnaW4sIFR3ZWVuTWF4V2l0aENTUyBhcyBUd2Vlbk1heCwgVHdlZW5MaXRlLCBUaW1lbGluZU1heCwgVGltZWxpbmVMaXRlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTsiXSwibmFtZXMiOlsiZ3NhcCIsIlBvd2VyMCIsIlBvd2VyMSIsIlBvd2VyMiIsIlBvd2VyMyIsIlBvd2VyNCIsIkxpbmVhciIsIlF1YWQiLCJDdWJpYyIsIlF1YXJ0IiwiUXVpbnQiLCJTdHJvbmciLCJFbGFzdGljIiwiQmFjayIsIlN0ZXBwZWRFYXNlIiwiQm91bmNlIiwiU2luZSIsIkV4cG8iLCJDaXJjIiwiVHdlZW5MaXRlIiwiVGltZWxpbmVMaXRlIiwiVGltZWxpbmVNYXgiLCJDU1NQbHVnaW4iLCJnc2FwV2l0aENTUyIsInJlZ2lzdGVyUGx1Z2luIiwiVHdlZW5NYXhXaXRoQ1NTIiwiY29yZSIsIlR3ZWVuIiwiZGVmYXVsdCIsIlR3ZWVuTWF4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/gsap/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js":
/*!****************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/Icon.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Icon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_hasA11yProp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/src/utils/hasA11yProp.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/hasA11yProp.js\");\n/* harmony import */ var _shared_src_utils_mergeClasses_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils/mergeClasses.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/mergeClasses.js\");\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\n\nconst Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c = (param, ref)=>{\n    let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, iconNode, ...rest } = param;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: (0,_shared_src_utils_mergeClasses_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n        ...!children && !(0,_shared_src_utils_hasA11yProp_js__WEBPACK_IMPORTED_MODULE_3__.hasA11yProp)(rest) && {\n            \"aria-hidden\": \"true\"\n        },\n        ...rest\n    }, [\n        ...iconNode.map((param)=>{\n            let [tag, attrs] = param;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n        }),\n        ...Array.isArray(children) ? children : [\n            children\n        ]\n    ]);\n});\n_c1 = Icon;\n //# sourceMappingURL=Icon.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Icon$forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVpRDtBQUNLO0FBQ1M7QUFDRTtBQUVsRSxNQUFNSyxxQkFBT0wsaURBQVVBLE1BQ3JCLFFBU0dNO1FBVEYsRUFDQ0MsUUFBUSxjQUFjLEVBQ3RCQyxPQUFPLEVBQUUsRUFDVEMsY0FBYyxDQUFDLEVBQ2ZDLG1CQUFtQixFQUNuQkMsWUFBWSxFQUFFLEVBQ2RDLFFBQVEsRUFDUkMsUUFBUSxFQUNSLEdBQUdDLE1BQ0o7eUJBQVViLG9EQUFhQSxDQUN0QixPQUNBO1FBQ0VLO1FBQ0EsR0FBR0osNkRBQWlCO1FBQ3BCYSxPQUFPUDtRQUNQUSxRQUFRUjtRQUNSUyxRQUFRVjtRQUNSRSxhQUFhQyxzQkFBc0JRLE9BQU9ULGVBQWUsS0FBS1MsT0FBT1YsUUFBUUM7UUFDN0VFLFdBQVdQLCtFQUFZQSxDQUFDLFVBQVVPO1FBQ2xDLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDVCw2RUFBV0EsQ0FBQ1csU0FBUztZQUFFLGVBQWU7UUFBTyxDQUFDO1FBQy9ELEdBQUdBLElBQUk7SUFDVCxHQUNBO1dBQ0tELFNBQVNNLEdBQUcsQ0FBQztnQkFBQyxDQUFDQyxLQUFLQyxNQUFNO2lDQUFLcEIsb0RBQWFBLENBQUNtQixLQUFLQzs7V0FDbERDLE1BQU1DLE9BQU8sQ0FBQ1gsWUFBWUEsV0FBVztZQUFDQTtTQUFTO0tBQ25EOzs7QUFJc0IsQ0FDM0IsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcz85MjMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU2NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgaGFzQTExeVByb3AgfSBmcm9tICcuL3NoYXJlZC9zcmMvdXRpbHMvaGFzQTExeVByb3AuanMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzL21lcmdlQ2xhc3Nlcy5qcyc7XG5cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBzaXplID0gMjQsXG4gICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgIGFic29sdXRlU3Ryb2tlV2lkdGgsXG4gICAgY2xhc3NOYW1lID0gXCJcIixcbiAgICBjaGlsZHJlbixcbiAgICBpY29uTm9kZSxcbiAgICAuLi5yZXN0XG4gIH0sIHJlZikgPT4gY3JlYXRlRWxlbWVudChcbiAgICBcInN2Z1wiLFxuICAgIHtcbiAgICAgIHJlZixcbiAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgd2lkdGg6IHNpemUsXG4gICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGggPyBOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQgLyBOdW1iZXIoc2l6ZSkgOiBzdHJva2VXaWR0aCxcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKFwibHVjaWRlXCIsIGNsYXNzTmFtZSksXG4gICAgICAuLi4hY2hpbGRyZW4gJiYgIWhhc0ExMXlQcm9wKHJlc3QpICYmIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgW1xuICAgICAgLi4uaWNvbk5vZGUubWFwKChbdGFnLCBhdHRyc10pID0+IGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykpLFxuICAgICAgLi4uQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl1cbiAgICBdXG4gIClcbik7XG5cbmV4cG9ydCB7IEljb24gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJmb3J3YXJkUmVmIiwiY3JlYXRlRWxlbWVudCIsImRlZmF1bHRBdHRyaWJ1dGVzIiwiaGFzQTExeVByb3AiLCJtZXJnZUNsYXNzZXMiLCJJY29uIiwicmVmIiwiY29sb3IiLCJzaXplIiwic3Ryb2tlV2lkdGgiLCJhYnNvbHV0ZVN0cm9rZVdpZHRoIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJpY29uTm9kZSIsInJlc3QiLCJ3aWR0aCIsImhlaWdodCIsInN0cm9rZSIsIk51bWJlciIsIm1hcCIsInRhZyIsImF0dHJzIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_src_utils_mergeClasses_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils/mergeClasses.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/mergeClasses.js\");\n/* harmony import */ var _shared_src_utils_toKebabCase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/src/utils/toKebabCase.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toKebabCase.js\");\n/* harmony import */ var _shared_src_utils_toPascalCase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/src/utils/toPascalCase.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toPascalCase.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\n\n\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { className, ...props } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            ref,\n            iconNode,\n            className: (0,_shared_src_utils_mergeClasses_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide-\".concat((0,_shared_src_utils_toKebabCase_js__WEBPACK_IMPORTED_MODULE_3__.toKebabCase)((0,_shared_src_utils_toPascalCase_js__WEBPACK_IMPORTED_MODULE_4__.toPascalCase)(iconName))), \"lucide-\".concat(iconName), className),\n            ...props\n        });\n    });\n    Component.displayName = (0,_shared_src_utils_toPascalCase_js__WEBPACK_IMPORTED_MODULE_4__.toPascalCase)(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFaUQ7QUFDZ0I7QUFDRjtBQUNFO0FBQ3JDO0FBRTdCLE1BQU1NLG1CQUFtQixDQUFDQyxVQUFVQztJQUNsQyxNQUFNQywwQkFBWVQsaURBQVVBLENBQzFCLFFBQTBCVTtZQUF6QixFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTzs2QkFBVVgsb0RBQWFBLENBQUNJLGdEQUFJQSxFQUFFO1lBQ3BESztZQUNBRjtZQUNBRyxXQUFXVCwrRUFBWUEsQ0FDckIsVUFBOEMsT0FBcENDLDZFQUFXQSxDQUFDQywrRUFBWUEsQ0FBQ0csYUFDbkMsVUFBbUIsT0FBVEEsV0FDVkk7WUFFRixHQUFHQyxLQUFLO1FBQ1Y7O0lBRUZILFVBQVVJLFdBQVcsR0FBR1QsK0VBQVlBLENBQUNHO0lBQ3JDLE9BQU9FO0FBQ1Q7QUFFdUMsQ0FDdkMsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcz80MGM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU2NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzL21lcmdlQ2xhc3Nlcy5qcyc7XG5pbXBvcnQgeyB0b0tlYmFiQ2FzZSB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy90b0tlYmFiQ2FzZS5qcyc7XG5pbXBvcnQgeyB0b1Bhc2NhbENhc2UgfSBmcm9tICcuL3NoYXJlZC9zcmMvdXRpbHMvdG9QYXNjYWxDYXNlLmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbmNvbnN0IGNyZWF0ZUx1Y2lkZUljb24gPSAoaWNvbk5hbWUsIGljb25Ob2RlKSA9PiB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWYoXG4gICAgKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgICAgcmVmLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcbiAgICAgICAgYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKHRvUGFzY2FsQ2FzZShpY29uTmFtZSkpfWAsXG4gICAgICAgIGBsdWNpZGUtJHtpY29uTmFtZX1gLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICksXG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gICk7XG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IHRvUGFzY2FsQ2FzZShpY29uTmFtZSk7XG4gIHJldHVybiBDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVMdWNpZGVJY29uIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUx1Y2lkZUljb24uanMubWFwXG4iXSwibmFtZXMiOlsiZm9yd2FyZFJlZiIsImNyZWF0ZUVsZW1lbnQiLCJtZXJnZUNsYXNzZXMiLCJ0b0tlYmFiQ2FzZSIsInRvUGFzY2FsQ2FzZSIsIkljb24iLCJjcmVhdGVMdWNpZGVJY29uIiwiaWNvbk5hbWUiLCJpY29uTm9kZSIsIkNvbXBvbmVudCIsInJlZiIsImNsYXNzTmFtZSIsInByb3BzIiwiZGlzcGxheU5hbWUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztDQUtDLEdBRUQsSUFBSUEsb0JBQW9CO0lBQ3RCQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLGVBQWU7SUFDZkMsZ0JBQWdCO0FBQ2xCO0FBRXdDLENBQ3hDLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzPzFkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTY0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0QXR0cmlidXRlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0QXR0cmlidXRlcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWZhdWx0QXR0cmlidXRlcyIsInhtbG5zIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/house.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/house.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ House; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8\",\n            key: \"5wwlr5\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\",\n            key: \"r6nss1\"\n        }\n    ]\n];\nconst House = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"house\", __iconNode);\n //# sourceMappingURL=house.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvaG91c2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFcUQ7QUFFdEQsTUFBTUMsYUFBYTtJQUNqQjtRQUFDO1FBQVE7WUFBRUMsR0FBRztZQUE4Q0MsS0FBSztRQUFTO0tBQUU7SUFDNUU7UUFDRTtRQUNBO1lBQ0VELEdBQUc7WUFDSEMsS0FBSztRQUNQO0tBQ0Q7Q0FDRjtBQUNELE1BQU1DLFFBQVFKLGdFQUFnQkEsQ0FBQyxTQUFTQztBQUVBLENBQ3hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2hvdXNlLmpzPzZlMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTY0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBfX2ljb25Ob2RlID0gW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMTUgMjF2LThhMSAxIDAgMCAwLTEtMWgtNGExIDEgMCAwIDAtMSAxdjhcIiwga2V5OiBcIjV3d2xyNVwiIH1dLFxuICBbXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNMyAxMGEyIDIgMCAwIDEgLjcwOS0xLjUyOGw3LTZhMiAyIDAgMCAxIDIuNTgyIDBsNyA2QTIgMiAwIDAgMSAyMSAxMHY5YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yelwiLFxuICAgICAga2V5OiBcInI2bnNzMVwiXG4gICAgfVxuICBdXG5dO1xuY29uc3QgSG91c2UgPSBjcmVhdGVMdWNpZGVJY29uKFwiaG91c2VcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIEhvdXNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvdXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUx1Y2lkZUljb24iLCJfX2ljb25Ob2RlIiwiZCIsImtleSIsIkhvdXNlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/house.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/life-buoy.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/life-buoy.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ LifeBuoy; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"10\",\n            key: \"1mglay\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m4.93 4.93 4.24 4.24\",\n            key: \"1ymg45\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m14.83 9.17 4.24-4.24\",\n            key: \"1cb5xl\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m14.83 14.83 4.24 4.24\",\n            key: \"q42g0n\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m9.17 14.83-4.24 4.24\",\n            key: \"bqpfvv\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"4\",\n            key: \"4exip2\"\n        }\n    ]\n];\nconst LifeBuoy = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"life-buoy\", __iconNode);\n //# sourceMappingURL=life-buoy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbGlmZS1idW95LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7OztDQUtDLEdBRXFEO0FBRXRELE1BQU1DLGFBQWE7SUFDakI7UUFBQztRQUFVO1lBQUVDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxHQUFHO1lBQU1DLEtBQUs7UUFBUztLQUFFO0lBQzFEO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQXdCRCxLQUFLO1FBQVM7S0FBRTtJQUN0RDtRQUFDO1FBQVE7WUFBRUMsR0FBRztZQUF5QkQsS0FBSztRQUFTO0tBQUU7SUFDdkQ7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBMEJELEtBQUs7UUFBUztLQUFFO0lBQ3hEO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQXlCRCxLQUFLO1FBQVM7S0FBRTtJQUN2RDtRQUFDO1FBQVU7WUFBRUgsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLEdBQUc7WUFBS0MsS0FBSztRQUFTO0tBQUU7Q0FDMUQ7QUFDRCxNQUFNRSxXQUFXUCxnRUFBZ0JBLENBQUMsYUFBYUM7QUFFSixDQUMzQyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9saWZlLWJ1b3kuanM/ZTc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NjQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IF9faWNvbk5vZGUgPSBbXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjEyXCIsIHI6IFwiMTBcIiwga2V5OiBcIjFtZ2xheVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtNC45MyA0LjkzIDQuMjQgNC4yNFwiLCBrZXk6IFwiMXltZzQ1XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0xNC44MyA5LjE3IDQuMjQtNC4yNFwiLCBrZXk6IFwiMWNiNXhsXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0xNC44MyAxNC44MyA0LjI0IDQuMjRcIiwga2V5OiBcInE0MmcwblwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtOS4xNyAxNC44My00LjI0IDQuMjRcIiwga2V5OiBcImJxcGZ2dlwiIH1dLFxuICBbXCJjaXJjbGVcIiwgeyBjeDogXCIxMlwiLCBjeTogXCIxMlwiLCByOiBcIjRcIiwga2V5OiBcIjRleGlwMlwiIH1dXG5dO1xuY29uc3QgTGlmZUJ1b3kgPSBjcmVhdGVMdWNpZGVJY29uKFwibGlmZS1idW95XCIsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgeyBfX2ljb25Ob2RlLCBMaWZlQnVveSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWZlLWJ1b3kuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIl9faWNvbk5vZGUiLCJjeCIsImN5IiwiciIsImtleSIsImQiLCJMaWZlQnVveSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/life-buoy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/zap.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/zap.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Zap; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z\",\n            key: \"1xq2db\"\n        }\n    ]\n];\nconst Zap = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"zap\", __iconNode);\n //# sourceMappingURL=zap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvemFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7OztDQUtDLEdBRXFEO0FBRXRELE1BQU1DLGFBQWE7SUFDakI7UUFDRTtRQUNBO1lBQ0VDLEdBQUc7WUFDSEMsS0FBSztRQUNQO0tBQ0Q7Q0FDRjtBQUNELE1BQU1DLE1BQU1KLGdFQUFnQkEsQ0FBQyxPQUFPQztBQUVFLENBQ3RDLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3phcC5qcz82YzdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU2NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgX19pY29uTm9kZSA9IFtcbiAgW1xuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTQgMTRhMSAxIDAgMCAxLS43OC0xLjYzbDkuOS0xMC4yYS41LjUgMCAwIDEgLjg2LjQ2bC0xLjkyIDYuMDJBMSAxIDAgMCAwIDEzIDEwaDdhMSAxIDAgMCAxIC43OCAxLjYzbC05LjkgMTAuMmEuNS41IDAgMCAxLS44Ni0uNDZsMS45Mi02LjAyQTEgMSAwIDAgMCAxMSAxNHpcIixcbiAgICAgIGtleTogXCIxeHEyZGJcIlxuICAgIH1cbiAgXVxuXTtcbmNvbnN0IFphcCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJ6YXBcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIFphcCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD16YXAuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiWmFwIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/zap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/hasA11yProp.js":
/*!****************************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils/hasA11yProp.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasA11yProp: function() { return /* binding */ hasA11yProp; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const hasA11yProp = (props)=>{\n    for(const prop in props){\n        if (prop.startsWith(\"aria-\") || prop === \"role\" || prop === \"title\") {\n            return true;\n        }\n    }\n    return false;\n};\n //# sourceMappingURL=hasA11yProp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy9oYXNBMTF5UHJvcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxNQUFNQSxjQUFjLENBQUNDO0lBQ25CLElBQUssTUFBTUMsUUFBUUQsTUFBTztRQUN4QixJQUFJQyxLQUFLQyxVQUFVLENBQUMsWUFBWUQsU0FBUyxVQUFVQSxTQUFTLFNBQVM7WUFDbkUsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFdUIsQ0FDdkIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy9oYXNBMTF5UHJvcC5qcz9lYmJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU2NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5jb25zdCBoYXNBMTF5UHJvcCA9IChwcm9wcykgPT4ge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICBpZiAocHJvcC5zdGFydHNXaXRoKFwiYXJpYS1cIikgfHwgcHJvcCA9PT0gXCJyb2xlXCIgfHwgcHJvcCA9PT0gXCJ0aXRsZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHsgaGFzQTExeVByb3AgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc0ExMXlQcm9wLmpzLm1hcFxuIl0sIm5hbWVzIjpbImhhc0ExMXlQcm9wIiwicHJvcHMiLCJwcm9wIiwic3RhcnRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/hasA11yProp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/mergeClasses.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils/mergeClasses.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeClasses: function() { return /* binding */ mergeClasses; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const mergeClasses = function() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return classes.filter((className, index, array)=>{\n        return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n    }).join(\" \").trim();\n};\n //# sourceMappingURL=mergeClasses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy9tZXJnZUNsYXNzZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztDQUtDLEdBRUQsTUFBTUEsZUFBZTtxQ0FBSUM7UUFBQUE7O1dBQVlBLFFBQVFDLE1BQU0sQ0FBQyxDQUFDQyxXQUFXQyxPQUFPQztRQUNyRSxPQUFPQyxRQUFRSCxjQUFjQSxVQUFVSSxJQUFJLE9BQU8sTUFBTUYsTUFBTUcsT0FBTyxDQUFDTCxlQUFlQztJQUN2RixHQUFHSyxJQUFJLENBQUMsS0FBS0YsSUFBSTs7QUFFTyxDQUN4Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9zaGFyZWQvc3JjL3V0aWxzL21lcmdlQ2xhc3Nlcy5qcz8yYWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU2NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5jb25zdCBtZXJnZUNsYXNzZXMgPSAoLi4uY2xhc3NlcykgPT4gY2xhc3Nlcy5maWx0ZXIoKGNsYXNzTmFtZSwgaW5kZXgsIGFycmF5KSA9PiB7XG4gIHJldHVybiBCb29sZWFuKGNsYXNzTmFtZSkgJiYgY2xhc3NOYW1lLnRyaW0oKSAhPT0gXCJcIiAmJiBhcnJheS5pbmRleE9mKGNsYXNzTmFtZSkgPT09IGluZGV4O1xufSkuam9pbihcIiBcIikudHJpbSgpO1xuXG5leHBvcnQgeyBtZXJnZUNsYXNzZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQ2xhc3Nlcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJtZXJnZUNsYXNzZXMiLCJjbGFzc2VzIiwiZmlsdGVyIiwiY2xhc3NOYW1lIiwiaW5kZXgiLCJhcnJheSIsIkJvb2xlYW4iLCJ0cmltIiwiaW5kZXhPZiIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/mergeClasses.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toCamelCase.js":
/*!****************************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils/toCamelCase.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toCamelCase: function() { return /* binding */ toCamelCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toCamelCase = (string)=>string.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2)=>p2 ? p2.toUpperCase() : p1.toLowerCase());\n //# sourceMappingURL=toCamelCase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy90b0NhbWVsQ2FzZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxNQUFNQSxjQUFjLENBQUNDLFNBQVdBLE9BQU9DLE9BQU8sQ0FDNUMseUJBQ0EsQ0FBQ0MsT0FBT0MsSUFBSUMsS0FBT0EsS0FBS0EsR0FBR0MsV0FBVyxLQUFLRixHQUFHRyxXQUFXO0FBR3BDLENBQ3ZCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMvdG9DYW1lbENhc2UuanM/Nzc4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NjQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgdG9DYW1lbENhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZShcbiAgL14oW0EtWl0pfFtcXHMtX10rKFxcdykvZyxcbiAgKG1hdGNoLCBwMSwgcDIpID0+IHAyID8gcDIudG9VcHBlckNhc2UoKSA6IHAxLnRvTG93ZXJDYXNlKClcbik7XG5cbmV4cG9ydCB7IHRvQ2FtZWxDYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0NhbWVsQ2FzZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ0b0NhbWVsQ2FzZSIsInN0cmluZyIsInJlcGxhY2UiLCJtYXRjaCIsInAxIiwicDIiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toCamelCase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toKebabCase.js":
/*!****************************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils/toKebabCase.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n //# sourceMappingURL=toKebabCase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy90b0tlYmFiQ2FzZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxNQUFNQSxjQUFjLENBQUNDLFNBQVdBLE9BQU9DLE9BQU8sQ0FBQyxzQkFBc0IsU0FBU0MsV0FBVztBQUVsRSxDQUN2Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9zaGFyZWQvc3JjL3V0aWxzL3RvS2ViYWJDYXNlLmpzP2EwMjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTY0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IHRvS2ViYWJDYXNlID0gKHN0cmluZykgPT4gc3RyaW5nLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcblxuZXhwb3J0IHsgdG9LZWJhYkNhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvS2ViYWJDYXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInRvS2ViYWJDYXNlIiwic3RyaW5nIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toKebabCase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toPascalCase.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils/toPascalCase.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPascalCase: function() { return /* binding */ toPascalCase; }\n/* harmony export */ });\n/* harmony import */ var _toCamelCase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toCamelCase.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toCamelCase.js\");\n/**\n * @license lucide-react v0.564.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst toPascalCase = (string)=>{\n    const camelCase = (0,_toCamelCase_js__WEBPACK_IMPORTED_MODULE_0__.toCamelCase)(string);\n    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n};\n //# sourceMappingURL=toPascalCase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy90b1Bhc2NhbENhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUU4QztBQUUvQyxNQUFNQyxlQUFlLENBQUNDO0lBQ3BCLE1BQU1DLFlBQVlILDREQUFXQSxDQUFDRTtJQUM5QixPQUFPQyxVQUFVQyxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLRixVQUFVRyxLQUFLLENBQUM7QUFDN0Q7QUFFd0IsQ0FDeEIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy90b1Bhc2NhbENhc2UuanM/ZGMxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NjQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgdG9DYW1lbENhc2UgfSBmcm9tICcuL3RvQ2FtZWxDYXNlLmpzJztcblxuY29uc3QgdG9QYXNjYWxDYXNlID0gKHN0cmluZykgPT4ge1xuICBjb25zdCBjYW1lbENhc2UgPSB0b0NhbWVsQ2FzZShzdHJpbmcpO1xuICByZXR1cm4gY2FtZWxDYXNlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxDYXNlLnNsaWNlKDEpO1xufTtcblxuZXhwb3J0IHsgdG9QYXNjYWxDYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1Bhc2NhbENhc2UuanMubWFwXG4iXSwibmFtZXMiOlsidG9DYW1lbENhc2UiLCJ0b1Bhc2NhbENhc2UiLCJzdHJpbmciLCJjYW1lbENhc2UiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils/toPascalCase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/link.js":
/*!********************************************!*\
  !*** ./node_modules/next/dist/api/link.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n //# sourceMappingURL=link.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ1YsQ0FFL0IsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanM/MTMwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(()=>{\n    \"use strict\";\n    var e = {\n        686: (e, r, t)=>{\n            var n = t(808);\n            var i = Object.create(null);\n            var a = typeof document === \"undefined\";\n            var o = Array.prototype.forEach;\n            function debounce(e, r) {\n                var t = 0;\n                return function() {\n                    var n = this;\n                    var i = arguments;\n                    var a = function functionCall() {\n                        return e.apply(n, i);\n                    };\n                    clearTimeout(t);\n                    t = setTimeout(a, r);\n                };\n            }\n            function noop() {}\n            function getCurrentScriptUrl(e) {\n                var r = i[e];\n                if (!r) {\n                    if (document.currentScript) {\n                        r = document.currentScript.src;\n                    } else {\n                        var t = document.getElementsByTagName(\"script\");\n                        var a = t[t.length - 1];\n                        if (a) {\n                            r = a.src;\n                        }\n                    }\n                    i[e] = r;\n                }\n                return function(e) {\n                    if (!r) {\n                        return null;\n                    }\n                    var t = r.split(/([^\\\\/]+)\\.js$/);\n                    var i = t && t[1];\n                    if (!i) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    if (!e) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    return e.split(\",\").map(function(e) {\n                        var t = new RegExp(\"\".concat(i, \"\\\\.js$\"), \"g\");\n                        return n(r.replace(t, \"\".concat(e.replace(/{fileName}/g, i), \".css\")));\n                    });\n                };\n            }\n            function updateCss(e, r) {\n                if (!r) {\n                    if (!e.href) {\n                        return;\n                    }\n                    r = e.href.split(\"?\")[0];\n                }\n                if (!isUrlRequest(r)) {\n                    return;\n                }\n                if (e.isLoaded === false) {\n                    return;\n                }\n                if (!r || !(r.indexOf(\".css\") > -1)) {\n                    return;\n                }\n                e.visited = true;\n                var t = e.cloneNode();\n                t.isLoaded = false;\n                t.addEventListener(\"load\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.addEventListener(\"error\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.href = \"\".concat(r, \"?\").concat(Date.now());\n                if (e.nextSibling) {\n                    e.parentNode.insertBefore(t, e.nextSibling);\n                } else {\n                    e.parentNode.appendChild(t);\n                }\n            }\n            function getReloadUrl(e, r) {\n                var t;\n                e = n(e, {\n                    stripWWW: false\n                });\n                r.some(function(n) {\n                    if (e.indexOf(r) > -1) {\n                        t = n;\n                    }\n                });\n                return t;\n            }\n            function reloadStyle(e) {\n                if (!e) {\n                    return false;\n                }\n                var r = document.querySelectorAll(\"link\");\n                var t = false;\n                o.call(r, function(r) {\n                    if (!r.href) {\n                        return;\n                    }\n                    var n = getReloadUrl(r.href, e);\n                    if (!isUrlRequest(n)) {\n                        return;\n                    }\n                    if (r.visited === true) {\n                        return;\n                    }\n                    if (n) {\n                        updateCss(r, n);\n                        t = true;\n                    }\n                });\n                return t;\n            }\n            function reloadAll() {\n                var e = document.querySelectorAll(\"link\");\n                o.call(e, function(e) {\n                    if (e.visited === true) {\n                        return;\n                    }\n                    updateCss(e);\n                });\n            }\n            function isUrlRequest(e) {\n                if (!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)) {\n                    return false;\n                }\n                return true;\n            }\n            e.exports = function(e, r) {\n                if (a) {\n                    console.log(\"no window.document found, will not HMR CSS\");\n                    return noop;\n                }\n                var t = getCurrentScriptUrl(e);\n                function update() {\n                    var e = t(r.filename);\n                    var n = reloadStyle(e);\n                    if (r.locals) {\n                        console.log(\"[HMR] Detected local css modules. Reload all css\");\n                        reloadAll();\n                        return;\n                    }\n                    if (n) {\n                        console.log(\"[HMR] css reload %s\", e.join(\" \"));\n                    } else {\n                        console.log(\"[HMR] Reload all css\");\n                        reloadAll();\n                    }\n                }\n                return debounce(update, 50);\n            };\n        },\n        808: (e)=>{\n            function normalizeUrl(e) {\n                return e.reduce(function(e, r) {\n                    switch(r){\n                        case \"..\":\n                            e.pop();\n                            break;\n                        case \".\":\n                            break;\n                        default:\n                            e.push(r);\n                    }\n                    return e;\n                }, []).join(\"/\");\n            }\n            e.exports = function(e) {\n                e = e.trim();\n                if (/^data:/i.test(e)) {\n                    return e;\n                }\n                var r = e.indexOf(\"//\") !== -1 ? e.split(\"//\")[0] + \"//\" : \"\";\n                var t = e.replace(new RegExp(r, \"i\"), \"\").split(\"/\");\n                var n = t[0].toLowerCase().replace(/\\.$/, \"\");\n                t[0] = \"\";\n                var i = normalizeUrl(t);\n                return r + n + i;\n            };\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var n = r[t];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = r[t] = {\n            exports: {}\n        };\n        var a = true;\n        try {\n            e[t](i, i.exports, __nccwpck_require__);\n            a = false;\n        } finally{\n            if (a) delete r[t];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(686);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBSztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLENBQUNBLEdBQUVDLEdBQUVDO1lBQUssSUFBSUMsSUFBRUQsRUFBRTtZQUFLLElBQUlFLElBQUVDLE9BQU9DLE1BQU0sQ0FBQztZQUFNLElBQUlDLElBQUUsT0FBT0MsYUFBVztZQUFZLElBQUlDLElBQUVDLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBTztZQUFDLFNBQVNDLFNBQVNiLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFJQyxJQUFFO2dCQUFFLE9BQU87b0JBQVcsSUFBSUMsSUFBRSxJQUFJO29CQUFDLElBQUlDLElBQUVVO29CQUFVLElBQUlQLElBQUUsU0FBU1E7d0JBQWUsT0FBT2YsRUFBRWdCLEtBQUssQ0FBQ2IsR0FBRUM7b0JBQUU7b0JBQUVhLGFBQWFmO29CQUFHQSxJQUFFZ0IsV0FBV1gsR0FBRU47Z0JBQUU7WUFBQztZQUFDLFNBQVNrQixRQUFPO1lBQUMsU0FBU0Msb0JBQW9CcEIsQ0FBQztnQkFBRSxJQUFJQyxJQUFFRyxDQUFDLENBQUNKLEVBQUU7Z0JBQUMsSUFBRyxDQUFDQyxHQUFFO29CQUFDLElBQUdPLFNBQVNhLGFBQWEsRUFBQzt3QkFBQ3BCLElBQUVPLFNBQVNhLGFBQWEsQ0FBQ0MsR0FBRztvQkFBQSxPQUFLO3dCQUFDLElBQUlwQixJQUFFTSxTQUFTZSxvQkFBb0IsQ0FBQzt3QkFBVSxJQUFJaEIsSUFBRUwsQ0FBQyxDQUFDQSxFQUFFc0IsTUFBTSxHQUFDLEVBQUU7d0JBQUMsSUFBR2pCLEdBQUU7NEJBQUNOLElBQUVNLEVBQUVlLEdBQUc7d0JBQUE7b0JBQUM7b0JBQUNsQixDQUFDLENBQUNKLEVBQUUsR0FBQ0M7Z0JBQUM7Z0JBQUMsT0FBTyxTQUFTRCxDQUFDO29CQUFFLElBQUcsQ0FBQ0MsR0FBRTt3QkFBQyxPQUFPO29CQUFJO29CQUFDLElBQUlDLElBQUVELEVBQUV3QixLQUFLLENBQUM7b0JBQWtCLElBQUlyQixJQUFFRixLQUFHQSxDQUFDLENBQUMsRUFBRTtvQkFBQyxJQUFHLENBQUNFLEdBQUU7d0JBQUMsT0FBTTs0QkFBQ0gsRUFBRXlCLE9BQU8sQ0FBQyxPQUFNO3lCQUFRO29CQUFBO29CQUFDLElBQUcsQ0FBQzFCLEdBQUU7d0JBQUMsT0FBTTs0QkFBQ0MsRUFBRXlCLE9BQU8sQ0FBQyxPQUFNO3lCQUFRO29CQUFBO29CQUFDLE9BQU8xQixFQUFFeUIsS0FBSyxDQUFDLEtBQUtFLEdBQUcsQ0FBRSxTQUFTM0IsQ0FBQzt3QkFBRSxJQUFJRSxJQUFFLElBQUkwQixPQUFPLEdBQUdDLE1BQU0sQ0FBQ3pCLEdBQUUsV0FBVTt3QkFBSyxPQUFPRCxFQUFFRixFQUFFeUIsT0FBTyxDQUFDeEIsR0FBRSxHQUFHMkIsTUFBTSxDQUFDN0IsRUFBRTBCLE9BQU8sQ0FBQyxlQUFjdEIsSUFBRztvQkFBUztnQkFBRztZQUFDO1lBQUMsU0FBUzBCLFVBQVU5QixDQUFDLEVBQUNDLENBQUM7Z0JBQUUsSUFBRyxDQUFDQSxHQUFFO29CQUFDLElBQUcsQ0FBQ0QsRUFBRStCLElBQUksRUFBQzt3QkFBQztvQkFBTTtvQkFBQzlCLElBQUVELEVBQUUrQixJQUFJLENBQUNOLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFBQTtnQkFBQyxJQUFHLENBQUNPLGFBQWEvQixJQUFHO29CQUFDO2dCQUFNO2dCQUFDLElBQUdELEVBQUVpQyxRQUFRLEtBQUcsT0FBTTtvQkFBQztnQkFBTTtnQkFBQyxJQUFHLENBQUNoQyxLQUFHLENBQUVBLENBQUFBLEVBQUVpQyxPQUFPLENBQUMsVUFBUSxDQUFDLElBQUc7b0JBQUM7Z0JBQU07Z0JBQUNsQyxFQUFFbUMsT0FBTyxHQUFDO2dCQUFLLElBQUlqQyxJQUFFRixFQUFFb0MsU0FBUztnQkFBR2xDLEVBQUUrQixRQUFRLEdBQUM7Z0JBQU0vQixFQUFFbUMsZ0JBQWdCLENBQUMsUUFBUTtvQkFBVyxJQUFHbkMsRUFBRStCLFFBQVEsRUFBQzt3QkFBQztvQkFBTTtvQkFBQy9CLEVBQUUrQixRQUFRLEdBQUM7b0JBQUtqQyxFQUFFc0MsVUFBVSxDQUFDQyxXQUFXLENBQUN2QztnQkFBRTtnQkFBSUUsRUFBRW1DLGdCQUFnQixDQUFDLFNBQVM7b0JBQVcsSUFBR25DLEVBQUUrQixRQUFRLEVBQUM7d0JBQUM7b0JBQU07b0JBQUMvQixFQUFFK0IsUUFBUSxHQUFDO29CQUFLakMsRUFBRXNDLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDdkM7Z0JBQUU7Z0JBQUlFLEVBQUU2QixJQUFJLEdBQUMsR0FBR0YsTUFBTSxDQUFDNUIsR0FBRSxLQUFLNEIsTUFBTSxDQUFDVyxLQUFLQyxHQUFHO2dCQUFJLElBQUd6QyxFQUFFMEMsV0FBVyxFQUFDO29CQUFDMUMsRUFBRXNDLFVBQVUsQ0FBQ0ssWUFBWSxDQUFDekMsR0FBRUYsRUFBRTBDLFdBQVc7Z0JBQUMsT0FBSztvQkFBQzFDLEVBQUVzQyxVQUFVLENBQUNNLFdBQVcsQ0FBQzFDO2dCQUFFO1lBQUM7WUFBQyxTQUFTMkMsYUFBYTdDLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFJQztnQkFBRUYsSUFBRUcsRUFBRUgsR0FBRTtvQkFBQzhDLFVBQVM7Z0JBQUs7Z0JBQUc3QyxFQUFFOEMsSUFBSSxDQUFFLFNBQVM1QyxDQUFDO29CQUFFLElBQUdILEVBQUVrQyxPQUFPLENBQUNqQyxLQUFHLENBQUMsR0FBRTt3QkFBQ0MsSUFBRUM7b0JBQUM7Z0JBQUM7Z0JBQUksT0FBT0Q7WUFBQztZQUFDLFNBQVM4QyxZQUFZaEQsQ0FBQztnQkFBRSxJQUFHLENBQUNBLEdBQUU7b0JBQUMsT0FBTztnQkFBSztnQkFBQyxJQUFJQyxJQUFFTyxTQUFTeUMsZ0JBQWdCLENBQUM7Z0JBQVEsSUFBSS9DLElBQUU7Z0JBQU1PLEVBQUV5QyxJQUFJLENBQUNqRCxHQUFHLFNBQVNBLENBQUM7b0JBQUUsSUFBRyxDQUFDQSxFQUFFOEIsSUFBSSxFQUFDO3dCQUFDO29CQUFNO29CQUFDLElBQUk1QixJQUFFMEMsYUFBYTVDLEVBQUU4QixJQUFJLEVBQUMvQjtvQkFBRyxJQUFHLENBQUNnQyxhQUFhN0IsSUFBRzt3QkFBQztvQkFBTTtvQkFBQyxJQUFHRixFQUFFa0MsT0FBTyxLQUFHLE1BQUs7d0JBQUM7b0JBQU07b0JBQUMsSUFBR2hDLEdBQUU7d0JBQUMyQixVQUFVN0IsR0FBRUU7d0JBQUdELElBQUU7b0JBQUk7Z0JBQUM7Z0JBQUksT0FBT0E7WUFBQztZQUFDLFNBQVNpRDtnQkFBWSxJQUFJbkQsSUFBRVEsU0FBU3lDLGdCQUFnQixDQUFDO2dCQUFReEMsRUFBRXlDLElBQUksQ0FBQ2xELEdBQUcsU0FBU0EsQ0FBQztvQkFBRSxJQUFHQSxFQUFFbUMsT0FBTyxLQUFHLE1BQUs7d0JBQUM7b0JBQU07b0JBQUNMLFVBQVU5QjtnQkFBRTtZQUFHO1lBQUMsU0FBU2dDLGFBQWFoQyxDQUFDO2dCQUFFLElBQUcsQ0FBQyw0QkFBNEJvRCxJQUFJLENBQUNwRCxJQUFHO29CQUFDLE9BQU87Z0JBQUs7Z0JBQUMsT0FBTztZQUFJO1lBQUNBLEVBQUVxRCxPQUFPLEdBQUMsU0FBU3JELENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFHTSxHQUFFO29CQUFDK0MsUUFBUUMsR0FBRyxDQUFDO29CQUE4QyxPQUFPcEM7Z0JBQUk7Z0JBQUMsSUFBSWpCLElBQUVrQixvQkFBb0JwQjtnQkFBRyxTQUFTd0Q7b0JBQVMsSUFBSXhELElBQUVFLEVBQUVELEVBQUV3RCxRQUFRO29CQUFFLElBQUl0RCxJQUFFNkMsWUFBWWhEO29CQUFHLElBQUdDLEVBQUV5RCxNQUFNLEVBQUM7d0JBQUNKLFFBQVFDLEdBQUcsQ0FBQzt3QkFBb0RKO3dCQUFZO29CQUFNO29CQUFDLElBQUdoRCxHQUFFO3dCQUFDbUQsUUFBUUMsR0FBRyxDQUFDLHVCQUFzQnZELEVBQUUyRCxJQUFJLENBQUM7b0JBQUssT0FBSzt3QkFBQ0wsUUFBUUMsR0FBRyxDQUFDO3dCQUF3Qko7b0JBQVc7Z0JBQUM7Z0JBQUMsT0FBT3RDLFNBQVMyQyxRQUFPO1lBQUc7UUFBQztRQUFFLEtBQUl4RCxDQUFBQTtZQUFJLFNBQVM0RCxhQUFhNUQsQ0FBQztnQkFBRSxPQUFPQSxFQUFFNkQsTUFBTSxDQUFFLFNBQVM3RCxDQUFDLEVBQUNDLENBQUM7b0JBQUUsT0FBT0E7d0JBQUcsS0FBSTs0QkFBS0QsRUFBRThELEdBQUc7NEJBQUc7d0JBQU0sS0FBSTs0QkFBSTt3QkFBTTs0QkFBUTlELEVBQUUrRCxJQUFJLENBQUM5RDtvQkFBRTtvQkFBQyxPQUFPRDtnQkFBQyxHQUFHLEVBQUUsRUFBRTJELElBQUksQ0FBQztZQUFJO1lBQUMzRCxFQUFFcUQsT0FBTyxHQUFDLFNBQVNyRCxDQUFDO2dCQUFFQSxJQUFFQSxFQUFFZ0UsSUFBSTtnQkFBRyxJQUFHLFVBQVVaLElBQUksQ0FBQ3BELElBQUc7b0JBQUMsT0FBT0E7Z0JBQUM7Z0JBQUMsSUFBSUMsSUFBRUQsRUFBRWtDLE9BQU8sQ0FBQyxVQUFRLENBQUMsSUFBRWxDLEVBQUV5QixLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsR0FBQyxPQUFLO2dCQUFHLElBQUl2QixJQUFFRixFQUFFMEIsT0FBTyxDQUFDLElBQUlFLE9BQU8zQixHQUFFLE1BQUssSUFBSXdCLEtBQUssQ0FBQztnQkFBSyxJQUFJdEIsSUFBRUQsQ0FBQyxDQUFDLEVBQUUsQ0FBQytELFdBQVcsR0FBR3ZDLE9BQU8sQ0FBQyxPQUFNO2dCQUFJeEIsQ0FBQyxDQUFDLEVBQUUsR0FBQztnQkFBRyxJQUFJRSxJQUFFd0QsYUFBYTFEO2dCQUFHLE9BQU9ELElBQUVFLElBQUVDO1lBQUM7UUFBQztJQUFDO0lBQUUsSUFBSUgsSUFBRSxDQUFDO0lBQUUsU0FBU2lFLG9CQUFvQmhFLENBQUM7UUFBRSxJQUFJQyxJQUFFRixDQUFDLENBQUNDLEVBQUU7UUFBQyxJQUFHQyxNQUFJZ0UsV0FBVTtZQUFDLE9BQU9oRSxFQUFFa0QsT0FBTztRQUFBO1FBQUMsSUFBSWpELElBQUVILENBQUMsQ0FBQ0MsRUFBRSxHQUFDO1lBQUNtRCxTQUFRLENBQUM7UUFBQztRQUFFLElBQUk5QyxJQUFFO1FBQUssSUFBRztZQUFDUCxDQUFDLENBQUNFLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRWlELE9BQU8sRUFBQ2E7WUFBcUIzRCxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT04sQ0FBQyxDQUFDQyxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFaUQsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPYSx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJbkUsSUFBRWdFLG9CQUFvQjtJQUFLSSxPQUFPakIsT0FBTyxHQUFDbkQ7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz81ZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs2ODY6KGUscix0KT0+e3ZhciBuPXQoODA4KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDgwODplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNjg2KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsInIiLCJ0IiwibiIsImkiLCJPYmplY3QiLCJjcmVhdGUiLCJhIiwiZG9jdW1lbnQiLCJvIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiZGVib3VuY2UiLCJhcmd1bWVudHMiLCJmdW5jdGlvbkNhbGwiLCJhcHBseSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJub29wIiwiZ2V0Q3VycmVudFNjcmlwdFVybCIsImN1cnJlbnRTY3JpcHQiLCJzcmMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxlbmd0aCIsInNwbGl0IiwicmVwbGFjZSIsIm1hcCIsIlJlZ0V4cCIsImNvbmNhdCIsInVwZGF0ZUNzcyIsImhyZWYiLCJpc1VybFJlcXVlc3QiLCJpc0xvYWRlZCIsImluZGV4T2YiLCJ2aXNpdGVkIiwiY2xvbmVOb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkRhdGUiLCJub3ciLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiZ2V0UmVsb2FkVXJsIiwic3RyaXBXV1ciLCJzb21lIiwicmVsb2FkU3R5bGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2FsbCIsInJlbG9hZEFsbCIsInRlc3QiLCJleHBvcnRzIiwiY29uc29sZSIsImxvZyIsInVwZGF0ZSIsImZpbGVuYW1lIiwibG9jYWxzIiwiam9pbiIsIm5vcm1hbGl6ZVVybCIsInJlZHVjZSIsInBvcCIsInB1c2giLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"1fec32de8432\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzlkMGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxZmVjMzJkZTg0MzJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/Navbar.js":
/*!**********************************!*\
  !*** ./app/components/Navbar.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Navbar; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var _barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Home,LifeBuoy,Map,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/house.js\");\n/* harmony import */ var _barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=Home,LifeBuoy,Map,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/zap.js\");\n/* harmony import */ var _barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Home,LifeBuoy,Map,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/life-buoy.js\");\n/* harmony import */ var _StaggeredMenu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StaggeredMenu */ \"(app-pages-browser)/./app/components/StaggeredMenu.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst socialItems = [\n    {\n        label: \"Twitter\",\n        link: \"https://twitter.com\"\n    },\n    {\n        label: \"GitHub\",\n        link: \"https://github.com\"\n    },\n    {\n        label: \"LinkedIn\",\n        link: \"https://linkedin.com\"\n    }\n];\n\nfunction Navbar() {\n    _s();\n    const [isScrolled, setIsScrolled] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const handleScroll = ()=>{\n            setIsScrolled(window.scrollY > 10);\n        };\n        window.addEventListener(\"scroll\", handleScroll);\n        return ()=>window.removeEventListener(\"scroll\", handleScroll);\n    }, []);\n    const navItems = [\n        {\n            label: \"Home\",\n            href: \"/\",\n            icon: _barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n        },\n        {\n            label: \"Book\",\n            href: \"/booking\",\n            icon: _barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\n        },\n        {\n            label: \"About\",\n            href: \"/about\",\n            icon: _barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"]\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"fixed top-6 left-0 right-0 z-50 flex justify-center px-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"hidden md:flex items-center gap-1 rounded-full border border-slate-200 bg-white/80 p-2 shadow-2xl shadow-slate-200/50 backdrop-blur-xl\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                        href: \"/\",\n                        className: \"mr-2 flex items-center gap-3 px-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"grid h-8 w-8 place-items-center rounded-full bg-emerald-500 text-white\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    className: \"h-4 w-4 fill-current\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                    lineNumber: 47,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                lineNumber: 46,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-heading text-sm font-bold tracking-tight text-slate-900 hidden sm:block\",\n                                children: \"TG-MOTORS\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                lineNumber: 49,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                        lineNumber: 45,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center\",\n                        children: navItems.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                href: item.href,\n                                className: \"group relative flex items-center gap-2 rounded-full px-4 py-2 text-sm font-medium text-slate-500 transition-colors hover:bg-slate-100 hover:text-slate-900\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(item.icon, {\n                                        className: \"h-4 w-4 transition-transform group-hover:scale-110\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                        lineNumber: 61,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"hidden md:block\",\n                                        children: item.label\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                        lineNumber: 62,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, item.href, true, {\n                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                lineNumber: 56,\n                                columnNumber: 13\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                        lineNumber: 54,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"ml-2 pl-2 border-l border-slate-200\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                            href: \"/booking\",\n                            className: \"flex items-center gap-2 rounded-full bg-emerald-500 px-5 py-2 text-sm font-bold text-white transition hover:bg-emerald-400 hover:shadow-[0_0_20px_-5px_rgba(16,185,129,0.4)]\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    children: \"Book Now\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                    lineNumber: 72,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    className: \"h-4 w-4 fill-current\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                    lineNumber: 73,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                            lineNumber: 68,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                        lineNumber: 67,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                lineNumber: 44,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"md:hidden\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_StaggeredMenu__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    isFixed: true,\n                    items: navItems.map((item)=>({\n                            label: item.label,\n                            link: item.href\n                        })),\n                    socialItems: socialItems,\n                    menuButtonColor: \"#0f172a\",\n                    openMenuButtonColor: \"#0f172a\",\n                    colors: [\n                        \"#10b981\",\n                        \"#34d399\",\n                        \"#059669\"\n                    ],\n                    customLogo: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center gap-3\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"grid h-8 w-8 place-items-center rounded-full bg-emerald-500 text-white\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Home_LifeBuoy_Map_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    className: \"h-4 w-4 fill-current\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                    lineNumber: 89,\n                                    columnNumber: 17\n                                }, void 0)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                lineNumber: 88,\n                                columnNumber: 15\n                            }, void 0),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-heading text-sm font-bold tracking-tight text-slate-900\",\n                                children: \"TG-MOTORS\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                                lineNumber: 91,\n                                columnNumber: 15\n                            }, void 0)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                        lineNumber: 87,\n                        columnNumber: 13\n                    }, void 0),\n                    headerClassName: \"!fixed !top-6 !left-6 !right-6 !w-auto !p-2 rounded-full border border-slate-200 transition-all duration-300 z-[60] \".concat(isScrolled ? \"!bg-white/30 shadow-2xl shadow-slate-200/50 backdrop-blur-xl\" : \"!bg-white shadow-sm\")\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                    lineNumber: 79,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n                lineNumber: 78,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Navbar.js\",\n        lineNumber: 42,\n        columnNumber: 5\n    }, this);\n}\n_s(Navbar, \"UCaI8lpZVGvPrsRoIFYRt2wv0+o=\");\n_c = Navbar;\nvar _c;\n$RefreshReg$(_c, \"Navbar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL05hdmJhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUU2QjtBQUMyQjtBQUVaO0FBSTVDLE1BQU1NLGNBQWM7SUFDbEI7UUFBRUMsT0FBTztRQUFXQyxNQUFNO0lBQXNCO0lBQ2hEO1FBQUVELE9BQU87UUFBVUMsTUFBTTtJQUFxQjtJQUM5QztRQUFFRCxPQUFPO1FBQVlDLE1BQU07SUFBdUI7Q0FDbkQ7QUFPMkM7QUFFN0IsU0FBU0c7O0lBQ3RCLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHSiwrQ0FBUUEsQ0FBQztJQUU3Q0MsZ0RBQVNBLENBQUM7UUFDUixNQUFNSSxlQUFlO1lBQ25CRCxjQUFjRSxPQUFPQyxPQUFPLEdBQUc7UUFDakM7UUFFQUQsT0FBT0UsZ0JBQWdCLENBQUMsVUFBVUg7UUFDbEMsT0FBTyxJQUFNQyxPQUFPRyxtQkFBbUIsQ0FBQyxVQUFVSjtJQUNwRCxHQUFHLEVBQUU7SUFDTCxNQUFNSyxXQUFXO1FBQ2Y7WUFBRVosT0FBTztZQUFRYSxNQUFNO1lBQUtDLE1BQU1wQixpR0FBSUE7UUFBQztRQUN2QztZQUFFTSxPQUFPO1lBQVFhLE1BQU07WUFBWUMsTUFBTWpCLGlHQUFHQTtRQUFDO1FBQzdDO1lBQUVHLE9BQU87WUFBU2EsTUFBTTtZQUFVQyxNQUFNbEIsaUdBQVFBO1FBQUM7S0FFbEQ7SUFFRCxxQkFDRSw4REFBQ21CO1FBQU9DLFdBQVU7OzBCQUVoQiw4REFBQ0M7Z0JBQUlELFdBQVU7O2tDQUNiLDhEQUFDdkIsaURBQUlBO3dCQUFDb0IsTUFBSzt3QkFBSUcsV0FBVTs7MENBQ3ZCLDhEQUFDRTtnQ0FBSUYsV0FBVTswQ0FDYiw0RUFBQ25CLGlHQUFHQTtvQ0FBQ21CLFdBQVU7Ozs7Ozs7Ozs7OzBDQUVqQiw4REFBQ0c7Z0NBQUtILFdBQVU7MENBQStFOzs7Ozs7Ozs7Ozs7a0NBS2pHLDhEQUFDRTt3QkFBSUYsV0FBVTtrQ0FDWkosU0FBU1EsR0FBRyxDQUFDLENBQUNDLHFCQUNiLDhEQUFDNUIsaURBQUlBO2dDQUVIb0IsTUFBTVEsS0FBS1IsSUFBSTtnQ0FDZkcsV0FBVTs7a0RBRVYsOERBQUNLLEtBQUtQLElBQUk7d0NBQUNFLFdBQVU7Ozs7OztrREFDckIsOERBQUNHO3dDQUFLSCxXQUFVO2tEQUFtQkssS0FBS3JCLEtBQUs7Ozs7Ozs7K0JBTHhDcUIsS0FBS1IsSUFBSTs7Ozs7Ozs7OztrQ0FVcEIsOERBQUNLO3dCQUFJRixXQUFVO2tDQUNYLDRFQUFDdkIsaURBQUlBOzRCQUNMb0IsTUFBSzs0QkFDTEcsV0FBVTs7OENBRVYsOERBQUNHOzhDQUFLOzs7Ozs7OENBQ04sOERBQUN0QixpR0FBR0E7b0NBQUNtQixXQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFLckIsOERBQUNFO2dCQUFJRixXQUFVOzBCQUNiLDRFQUFDbEIsc0RBQWFBO29CQUNad0IsT0FBTztvQkFDUEMsT0FBT1gsU0FBU1EsR0FBRyxDQUFDQyxDQUFBQSxPQUFTOzRCQUFFckIsT0FBT3FCLEtBQUtyQixLQUFLOzRCQUFFQyxNQUFNb0IsS0FBS1IsSUFBSTt3QkFBQztvQkFDbEVkLGFBQWFBO29CQUNieUIsaUJBQWdCO29CQUNoQkMscUJBQW9CO29CQUNwQkMsUUFBUTt3QkFBQzt3QkFBVzt3QkFBVztxQkFBVTtvQkFDekNDLDBCQUNFLDhEQUFDVDt3QkFBSUYsV0FBVTs7MENBQ2IsOERBQUNFO2dDQUFJRixXQUFVOzBDQUNiLDRFQUFDbkIsaUdBQUdBO29DQUFDbUIsV0FBVTs7Ozs7Ozs7Ozs7MENBRWpCLDhEQUFDRztnQ0FBS0gsV0FBVTswQ0FBK0Q7Ozs7Ozs7Ozs7OztvQkFLbkZZLGlCQUFpQix1SEFJaEIsT0FIQ3ZCLGFBQ0ksaUVBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWhCO0dBbEZ3QkQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvTmF2YmFyLmpzPzIxY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuaW1wb3J0IHsgSG9tZSwgTWFwLCBMaWZlQnVveSwgWmFwIH0gZnJvbSBcImx1Y2lkZS1yZWFjdFwiO1xuXG5pbXBvcnQgU3RhZ2dlcmVkTWVudSBmcm9tICcuL1N0YWdnZXJlZE1lbnUnO1xuXG5cblxuY29uc3Qgc29jaWFsSXRlbXMgPSBbXG4gIHsgbGFiZWw6ICdUd2l0dGVyJywgbGluazogJ2h0dHBzOi8vdHdpdHRlci5jb20nIH0sXG4gIHsgbGFiZWw6ICdHaXRIdWInLCBsaW5rOiAnaHR0cHM6Ly9naXRodWIuY29tJyB9LFxuICB7IGxhYmVsOiAnTGlua2VkSW4nLCBsaW5rOiAnaHR0cHM6Ly9saW5rZWRpbi5jb20nIH1cbl07XG5cblxuXG5cblxuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOYXZiYXIoKSB7XG4gIGNvbnN0IFtpc1Njcm9sbGVkLCBzZXRJc1Njcm9sbGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9ICgpID0+IHtcbiAgICAgIHNldElzU2Nyb2xsZWQod2luZG93LnNjcm9sbFkgPiAxMCk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgfSwgW10pO1xuICBjb25zdCBuYXZJdGVtcyA9IFtcbiAgICB7IGxhYmVsOiBcIkhvbWVcIiwgaHJlZjogXCIvXCIsIGljb246IEhvbWUgfSxcbiAgICB7IGxhYmVsOiBcIkJvb2tcIiwgaHJlZjogXCIvYm9va2luZ1wiLCBpY29uOiBaYXAgfSxcbiAgICB7IGxhYmVsOiBcIkFib3V0XCIsIGhyZWY6IFwiL2Fib3V0XCIsIGljb246IExpZmVCdW95IH0sXG4gIFxuICBdO1xuXG4gIHJldHVybiAoXG4gICAgPGhlYWRlciBjbGFzc05hbWU9XCJmaXhlZCB0b3AtNiBsZWZ0LTAgcmlnaHQtMCB6LTUwIGZsZXgganVzdGlmeS1jZW50ZXIgcHgtNlwiPlxuICAgICAgXG4gICAgICA8bmF2IGNsYXNzTmFtZT1cImhpZGRlbiBtZDpmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMSByb3VuZGVkLWZ1bGwgYm9yZGVyIGJvcmRlci1zbGF0ZS0yMDAgYmctd2hpdGUvODAgcC0yIHNoYWRvdy0yeGwgc2hhZG93LXNsYXRlLTIwMC81MCBiYWNrZHJvcC1ibHVyLXhsXCI+XG4gICAgICAgIDxMaW5rIGhyZWY9XCIvXCIgY2xhc3NOYW1lPVwibXItMiBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMyBweC00XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGgtOCB3LTggcGxhY2UtaXRlbXMtY2VudGVyIHJvdW5kZWQtZnVsbCBiZy1lbWVyYWxkLTUwMCB0ZXh0LXdoaXRlXCI+XG4gICAgICAgICAgICA8WmFwIGNsYXNzTmFtZT1cImgtNCB3LTQgZmlsbC1jdXJyZW50XCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LWhlYWRpbmcgdGV4dC1zbSBmb250LWJvbGQgdHJhY2tpbmctdGlnaHQgdGV4dC1zbGF0ZS05MDAgaGlkZGVuIHNtOmJsb2NrXCI+XG4gICAgICAgICAgICBURy1NT1RPUlNcbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvTGluaz5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAge25hdkl0ZW1zLm1hcCgoaXRlbSkgPT4gKFxuICAgICAgICAgICAgPExpbmtcbiAgICAgICAgICAgICAga2V5PXtpdGVtLmhyZWZ9XG4gICAgICAgICAgICAgIGhyZWY9e2l0ZW0uaHJlZn1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ3JvdXAgcmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgcm91bmRlZC1mdWxsIHB4LTQgcHktMiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtc2xhdGUtNTAwIHRyYW5zaXRpb24tY29sb3JzIGhvdmVyOmJnLXNsYXRlLTEwMCBob3Zlcjp0ZXh0LXNsYXRlLTkwMFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxpdGVtLmljb24gY2xhc3NOYW1lPVwiaC00IHctNCB0cmFuc2l0aW9uLXRyYW5zZm9ybSBncm91cC1ob3ZlcjpzY2FsZS0xMTBcIiAvPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJoaWRkZW4gbWQ6YmxvY2tcIj57aXRlbS5sYWJlbH08L3NwYW4+XG4gICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWwtMiBwbC0yIGJvcmRlci1sIGJvcmRlci1zbGF0ZS0yMDBcIj5cbiAgICAgICAgICAgIDxMaW5rXG4gICAgICAgICAgICBocmVmPVwiL2Jvb2tpbmdcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgcm91bmRlZC1mdWxsIGJnLWVtZXJhbGQtNTAwIHB4LTUgcHktMiB0ZXh0LXNtIGZvbnQtYm9sZCB0ZXh0LXdoaXRlIHRyYW5zaXRpb24gaG92ZXI6YmctZW1lcmFsZC00MDAgaG92ZXI6c2hhZG93LVswXzBfMjBweF8tNXB4X3JnYmEoMTYsMTg1LDEyOSwwLjQpXVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8c3Bhbj5Cb29rIE5vdzwvc3Bhbj5cbiAgICAgICAgICAgIDxaYXAgY2xhc3NOYW1lPVwiaC00IHctNCBmaWxsLWN1cnJlbnRcIiAvPlxuICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmF2PlxuICAgICAgey8qIE1vYmlsZSBNZW51ICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZDpoaWRkZW5cIj5cbiAgICAgICAgPFN0YWdnZXJlZE1lbnVcbiAgICAgICAgICBpc0ZpeGVkXG4gICAgICAgICAgaXRlbXM9e25hdkl0ZW1zLm1hcChpdGVtID0+ICh7IGxhYmVsOiBpdGVtLmxhYmVsLCBsaW5rOiBpdGVtLmhyZWYgfSkpfVxuICAgICAgICAgIHNvY2lhbEl0ZW1zPXtzb2NpYWxJdGVtc31cbiAgICAgICAgICBtZW51QnV0dG9uQ29sb3I9XCIjMGYxNzJhXCJcbiAgICAgICAgICBvcGVuTWVudUJ1dHRvbkNvbG9yPVwiIzBmMTcyYVwiXG4gICAgICAgICAgY29sb3JzPXtbJyMxMGI5ODEnLCAnIzM0ZDM5OScsICcjMDU5NjY5J119XG4gICAgICAgICAgY3VzdG9tTG9nbz17XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBoLTggdy04IHBsYWNlLWl0ZW1zLWNlbnRlciByb3VuZGVkLWZ1bGwgYmctZW1lcmFsZC01MDAgdGV4dC13aGl0ZVwiPlxuICAgICAgICAgICAgICAgIDxaYXAgY2xhc3NOYW1lPVwiaC00IHctNCBmaWxsLWN1cnJlbnRcIiAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1oZWFkaW5nIHRleHQtc20gZm9udC1ib2xkIHRyYWNraW5nLXRpZ2h0IHRleHQtc2xhdGUtOTAwXCI+XG4gICAgICAgICAgICAgICAgVEctTU9UT1JTXG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIH1cbiAgICAgICAgICBoZWFkZXJDbGFzc05hbWU9e2AhZml4ZWQgIXRvcC02ICFsZWZ0LTYgIXJpZ2h0LTYgIXctYXV0byAhcC0yIHJvdW5kZWQtZnVsbCBib3JkZXIgYm9yZGVyLXNsYXRlLTIwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgei1bNjBdICR7XG4gICAgICAgICAgICBpc1Njcm9sbGVkIFxuICAgICAgICAgICAgICA/IFwiIWJnLXdoaXRlLzMwIHNoYWRvdy0yeGwgc2hhZG93LXNsYXRlLTIwMC81MCBiYWNrZHJvcC1ibHVyLXhsXCIgXG4gICAgICAgICAgICAgIDogXCIhYmctd2hpdGUgc2hhZG93LXNtXCJcbiAgICAgICAgICB9YH1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvaGVhZGVyPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkxpbmsiLCJIb21lIiwiTWFwIiwiTGlmZUJ1b3kiLCJaYXAiLCJTdGFnZ2VyZWRNZW51Iiwic29jaWFsSXRlbXMiLCJsYWJlbCIsImxpbmsiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIk5hdmJhciIsImlzU2Nyb2xsZWQiLCJzZXRJc1Njcm9sbGVkIiwiaGFuZGxlU2Nyb2xsIiwid2luZG93Iiwic2Nyb2xsWSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibmF2SXRlbXMiLCJocmVmIiwiaWNvbiIsImhlYWRlciIsImNsYXNzTmFtZSIsIm5hdiIsImRpdiIsInNwYW4iLCJtYXAiLCJpdGVtIiwiaXNGaXhlZCIsIml0ZW1zIiwibWVudUJ1dHRvbkNvbG9yIiwib3Blbk1lbnVCdXR0b25Db2xvciIsImNvbG9ycyIsImN1c3RvbUxvZ28iLCJoZWFkZXJDbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/Navbar.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/Particles.js":
/*!*************************************!*\
  !*** ./app/components/Particles.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Camera.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Geometry.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Mesh.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst defaultColors = [\n    \"#ffffff\",\n    \"#ffffff\",\n    \"#ffffff\"\n];\nconst hexToRgb = (hex)=>{\n    hex = hex.replace(/^#/, \"\");\n    if (hex.length === 3) {\n        hex = hex.split(\"\").map((c)=>c + c).join(\"\");\n    }\n    const int = parseInt(hex, 16);\n    const r = (int >> 16 & 255) / 255;\n    const g = (int >> 8 & 255) / 255;\n    const b = (int & 255) / 255;\n    return [\n        r,\n        g,\n        b\n    ];\n};\nconst vertex = \"\\n  attribute vec3 position;\\n  attribute vec4 random;\\n  attribute vec3 color;\\n  \\n  uniform mat4 modelMatrix;\\n  uniform mat4 viewMatrix;\\n  uniform mat4 projectionMatrix;\\n  uniform float uTime;\\n  uniform float uSpread;\\n  uniform float uBaseSize;\\n  uniform float uSizeRandomness;\\n  \\n  varying vec4 vRandom;\\n  varying vec3 vColor;\\n  \\n  void main() {\\n    vRandom = random;\\n    vColor = color;\\n    \\n    vec3 pos = position * uSpread;\\n    pos.z *= 10.0;\\n    \\n    vec4 mPos = modelMatrix * vec4(pos, 1.0);\\n    float t = uTime;\\n    mPos.x += sin(t * random.z + 6.28 * random.w) * mix(0.1, 1.5, random.x);\\n    mPos.y += sin(t * random.y + 6.28 * random.x) * mix(0.1, 1.5, random.w);\\n    mPos.z += sin(t * random.w + 6.28 * random.y) * mix(0.1, 1.5, random.z);\\n    \\n    vec4 mvPos = viewMatrix * mPos;\\n\\n    if (uSizeRandomness == 0.0) {\\n      gl_PointSize = uBaseSize;\\n    } else {\\n      gl_PointSize = (uBaseSize * (1.0 + uSizeRandomness * (random.x - 0.5))) / length(mvPos.xyz);\\n    }\\n\\n    gl_Position = projectionMatrix * mvPos;\\n  }\\n\";\nconst fragment = \"\\n  precision highp float;\\n  \\n  uniform float uTime;\\n  uniform float uAlphaParticles;\\n  varying vec4 vRandom;\\n  varying vec3 vColor;\\n  \\n  void main() {\\n    vec2 uv = gl_PointCoord.xy;\\n    float d = length(uv - vec2(0.5));\\n    \\n    if(uAlphaParticles < 0.5) {\\n      if(d > 0.5) {\\n        discard;\\n      }\\n      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), 1.0);\\n    } else {\\n      float circle = smoothstep(0.5, 0.4, d) * 0.8;\\n      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), circle);\\n    }\\n  }\\n\";\nconst Particles = (param)=>{\n    let { particleCount = 200, particleSpread = 10, speed = 0.1, particleColors, moveParticlesOnHover = false, particleHoverFactor = 1, alphaParticles = false, particleBaseSize = 100, sizeRandomness = 1, cameraDistance = 20, disableRotation = false, pixelRatio = 1, className } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mouseRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const container = containerRef.current;\n        if (!container) return;\n        const renderer = new ogl__WEBPACK_IMPORTED_MODULE_2__.Renderer({\n            dpr: pixelRatio,\n            depth: false,\n            alpha: true\n        });\n        const gl = renderer.gl;\n        container.appendChild(gl.canvas);\n        gl.clearColor(0, 0, 0, 0);\n        const camera = new ogl__WEBPACK_IMPORTED_MODULE_3__.Camera(gl, {\n            fov: 15\n        });\n        camera.position.set(0, 0, cameraDistance);\n        const resize = ()=>{\n            const width = container.clientWidth;\n            const height = container.clientHeight;\n            renderer.setSize(width, height);\n            camera.perspective({\n                aspect: gl.canvas.width / gl.canvas.height\n            });\n        };\n        window.addEventListener(\"resize\", resize, false);\n        resize();\n        const handleMouseMove = (e)=>{\n            const rect = container.getBoundingClientRect();\n            const x = (e.clientX - rect.left) / rect.width * 2 - 1;\n            const y = -((e.clientY - rect.top) / rect.height * 2 - 1);\n            mouseRef.current = {\n                x,\n                y\n            };\n        };\n        if (moveParticlesOnHover) {\n            container.addEventListener(\"mousemove\", handleMouseMove);\n        }\n        const count = particleCount;\n        const positions = new Float32Array(count * 3);\n        const randoms = new Float32Array(count * 4);\n        const colors = new Float32Array(count * 3);\n        const palette = particleColors && particleColors.length > 0 ? particleColors : defaultColors;\n        for(let i = 0; i < count; i++){\n            let x, y, z, len;\n            do {\n                x = Math.random() * 2 - 1;\n                y = Math.random() * 2 - 1;\n                z = Math.random() * 2 - 1;\n                len = x * x + y * y + z * z;\n            }while (len > 1 || len === 0);\n            const r = Math.cbrt(Math.random());\n            positions.set([\n                x * r,\n                y * r,\n                z * r\n            ], i * 3);\n            randoms.set([\n                Math.random(),\n                Math.random(),\n                Math.random(),\n                Math.random()\n            ], i * 4);\n            const col = hexToRgb(palette[Math.floor(Math.random() * palette.length)]);\n            colors.set(col, i * 3);\n        }\n        const geometry = new ogl__WEBPACK_IMPORTED_MODULE_4__.Geometry(gl, {\n            position: {\n                size: 3,\n                data: positions\n            },\n            random: {\n                size: 4,\n                data: randoms\n            },\n            color: {\n                size: 3,\n                data: colors\n            }\n        });\n        const program = new ogl__WEBPACK_IMPORTED_MODULE_5__.Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                uTime: {\n                    value: 0\n                },\n                uSpread: {\n                    value: particleSpread\n                },\n                uBaseSize: {\n                    value: particleBaseSize * pixelRatio\n                },\n                uSizeRandomness: {\n                    value: sizeRandomness\n                },\n                uAlphaParticles: {\n                    value: alphaParticles ? 1 : 0\n                }\n            },\n            transparent: true,\n            depthTest: false\n        });\n        const particles = new ogl__WEBPACK_IMPORTED_MODULE_6__.Mesh(gl, {\n            mode: gl.POINTS,\n            geometry,\n            program\n        });\n        let animationFrameId;\n        let lastTime = performance.now();\n        let elapsed = 0;\n        const update = (t)=>{\n            animationFrameId = requestAnimationFrame(update);\n            const delta = t - lastTime;\n            lastTime = t;\n            elapsed += delta * speed;\n            program.uniforms.uTime.value = elapsed * 0.001;\n            if (moveParticlesOnHover) {\n                particles.position.x = -mouseRef.current.x * particleHoverFactor;\n                particles.position.y = -mouseRef.current.y * particleHoverFactor;\n            } else {\n                particles.position.x = 0;\n                particles.position.y = 0;\n            }\n            if (!disableRotation) {\n                particles.rotation.x = Math.sin(elapsed * 0.0002) * 0.1;\n                particles.rotation.y = Math.cos(elapsed * 0.0005) * 0.15;\n                particles.rotation.z += 0.01 * speed;\n            }\n            renderer.render({\n                scene: particles,\n                camera\n            });\n        };\n        animationFrameId = requestAnimationFrame(update);\n        return ()=>{\n            window.removeEventListener(\"resize\", resize);\n            if (moveParticlesOnHover) {\n                container.removeEventListener(\"mousemove\", handleMouseMove);\n            }\n            cancelAnimationFrame(animationFrameId);\n            if (container.contains(gl.canvas)) {\n                container.removeChild(gl.canvas);\n            }\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        particleCount,\n        particleSpread,\n        speed,\n        moveParticlesOnHover,\n        particleHoverFactor,\n        alphaParticles,\n        particleBaseSize,\n        sizeRandomness,\n        cameraDistance,\n        disableRotation,\n        pixelRatio\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"relative w-full h-full \".concat(className)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\Particles.js\",\n        lineNumber: 240,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Particles, \"+nF1yJvQLVO//ZYCcNavPZmnV1A=\");\n_c = Particles;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Particles);\nvar _c;\n$RefreshReg$(_c, \"Particles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1BhcnRpY2xlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUMwQztBQUNzQjtBQUVoRSxNQUFNTyxnQkFBZ0I7SUFBQztJQUFXO0lBQVc7Q0FBVTtBQUV2RCxNQUFNQyxXQUFXQyxDQUFBQTtJQUNmQSxNQUFNQSxJQUFJQyxPQUFPLENBQUMsTUFBTTtJQUN4QixJQUFJRCxJQUFJRSxNQUFNLEtBQUssR0FBRztRQUNwQkYsTUFBTUEsSUFDSEcsS0FBSyxDQUFDLElBQ05DLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsSUFBSUEsR0FDYkMsSUFBSSxDQUFDO0lBQ1Y7SUFDQSxNQUFNQyxNQUFNQyxTQUFTUixLQUFLO0lBQzFCLE1BQU1TLElBQUksQ0FBQyxPQUFRLEtBQU0sR0FBRSxJQUFLO0lBQ2hDLE1BQU1DLElBQUksQ0FBQyxPQUFRLElBQUssR0FBRSxJQUFLO0lBQy9CLE1BQU1DLElBQUksQ0FBQ0osTUFBTSxHQUFFLElBQUs7SUFDeEIsT0FBTztRQUFDRTtRQUFHQztRQUFHQztLQUFFO0FBQ2xCO0FBRUEsTUFBTUMsU0FBcUI7QUF5QzNCLE1BQU1DLFdBQXVCO0FBd0I3QixNQUFNQyxZQUFZO1FBQUMsRUFDakJDLGdCQUFnQixHQUFHLEVBQ25CQyxpQkFBaUIsRUFBRSxFQUNuQkMsUUFBUSxHQUFHLEVBQ1hDLGNBQWMsRUFDZEMsdUJBQXVCLEtBQUssRUFDNUJDLHNCQUFzQixDQUFDLEVBQ3ZCQyxpQkFBaUIsS0FBSyxFQUN0QkMsbUJBQW1CLEdBQUcsRUFDdEJDLGlCQUFpQixDQUFDLEVBQ2xCQyxpQkFBaUIsRUFBRSxFQUNuQkMsa0JBQWtCLEtBQUssRUFDdkJDLGFBQWEsQ0FBQyxFQUNkQyxTQUFTLEVBQ1Y7O0lBQ0MsTUFBTUMsZUFBZXBDLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU1xQyxXQUFXckMsNkNBQU1BLENBQUM7UUFBRXNDLEdBQUc7UUFBR0MsR0FBRztJQUFFO0lBRXJDeEMs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QUFVaEQsUUFBUSxDQUFDZCxDQUFDLEdBQUc7Z0JBQ3ZCOEQsVUFBVWhELFFBQVEsQ0FBQ2IsQ0FBQyxHQUFHO1lBQ3pCO1lBRUEsSUFBSSxDQUFDTixpQkFBaUI7Z0JBQ3BCbUUsVUFBVVksUUFBUSxDQUFDMUUsQ0FBQyxHQUFHMkMsS0FBS2dDLEdBQUcsQ0FBQ04sVUFBVSxVQUFVO2dCQUNwRFAsVUFBVVksUUFBUSxDQUFDekUsQ0FBQyxHQUFHMEMsS0FBS2lDLEdBQUcsQ0FBQ1AsVUFBVSxVQUFVO2dCQUNwRFAsVUFBVVksUUFBUSxDQUFDakMsQ0FBQyxJQUFJLE9BQU90RDtZQUNqQztZQUVBaUIsU0FBU3lFLE1BQU0sQ0FBQztnQkFBRUMsT0FBT2hCO2dCQUFXbEQ7WUFBTztRQUM3QztRQUVBcUQsbUJBQW1CTyxzQkFBc0JGO1FBRXpDLE9BQU87WUFDTDlDLE9BQU91RCxtQkFBbUIsQ0FBQyxVQUFVL0Q7WUFDckMsSUFBSTNCLHNCQUFzQjtnQkFDeEJhLFVBQVU2RSxtQkFBbUIsQ0FBQyxhQUFhckQ7WUFDN0M7WUFDQXNELHFCQUFxQmY7WUFDckIsSUFBSS9ELFVBQVUrRSxRQUFRLENBQUN6RSxHQUFHRSxNQUFNLEdBQUc7Z0JBQ2pDUixVQUFVZ0YsV0FBVyxDQUFDMUUsR0FBR0UsTUFBTTtZQUNqQztRQUNGO0lBQ0EsdURBQXVEO0lBQ3pELEdBQUc7UUFDRHpCO1FBQ0FDO1FBQ0FDO1FBQ0FFO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO0tBQ0Q7SUFFRCxxQkFBTyw4REFBQ3VGO1FBQUlDLEtBQUt0RjtRQUFjRCxXQUFXLDBCQUFvQyxPQUFWQTs7Ozs7O0FBQ3RFO0dBMUpNYjtLQUFBQTtBQTRKTiwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9QYXJ0aWNsZXMuanM/NDZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUmVuZGVyZXIsIENhbWVyYSwgR2VvbWV0cnksIFByb2dyYW0sIE1lc2ggfSBmcm9tICdvZ2wnO1xyXG5cclxuY29uc3QgZGVmYXVsdENvbG9ycyA9IFsnI2ZmZmZmZicsICcjZmZmZmZmJywgJyNmZmZmZmYnXTtcclxuXHJcbmNvbnN0IGhleFRvUmdiID0gaGV4ID0+IHtcclxuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCAnJyk7XHJcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcclxuICAgIGhleCA9IGhleFxyXG4gICAgICAuc3BsaXQoJycpXHJcbiAgICAgIC5tYXAoYyA9PiBjICsgYylcclxuICAgICAgLmpvaW4oJycpO1xyXG4gIH1cclxuICBjb25zdCBpbnQgPSBwYXJzZUludChoZXgsIDE2KTtcclxuICBjb25zdCByID0gKChpbnQgPj4gMTYpICYgMjU1KSAvIDI1NTtcclxuICBjb25zdCBnID0gKChpbnQgPj4gOCkgJiAyNTUpIC8gMjU1O1xyXG4gIGNvbnN0IGIgPSAoaW50ICYgMjU1KSAvIDI1NTtcclxuICByZXR1cm4gW3IsIGcsIGJdO1xyXG59O1xyXG5cclxuY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqLyBgXHJcbiAgYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XHJcbiAgYXR0cmlidXRlIHZlYzQgcmFuZG9tO1xyXG4gIGF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xyXG4gIFxyXG4gIHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcclxuICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcclxuICB1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcclxuICB1bmlmb3JtIGZsb2F0IHVUaW1lO1xyXG4gIHVuaWZvcm0gZmxvYXQgdVNwcmVhZDtcclxuICB1bmlmb3JtIGZsb2F0IHVCYXNlU2l6ZTtcclxuICB1bmlmb3JtIGZsb2F0IHVTaXplUmFuZG9tbmVzcztcclxuICBcclxuICB2YXJ5aW5nIHZlYzQgdlJhbmRvbTtcclxuICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xyXG4gIFxyXG4gIHZvaWQgbWFpbigpIHtcclxuICAgIHZSYW5kb20gPSByYW5kb207XHJcbiAgICB2Q29sb3IgPSBjb2xvcjtcclxuICAgIFxyXG4gICAgdmVjMyBwb3MgPSBwb3NpdGlvbiAqIHVTcHJlYWQ7XHJcbiAgICBwb3MueiAqPSAxMC4wO1xyXG4gICAgXHJcbiAgICB2ZWM0IG1Qb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zLCAxLjApO1xyXG4gICAgZmxvYXQgdCA9IHVUaW1lO1xyXG4gICAgbVBvcy54ICs9IHNpbih0ICogcmFuZG9tLnogKyA2LjI4ICogcmFuZG9tLncpICogbWl4KDAuMSwgMS41LCByYW5kb20ueCk7XHJcbiAgICBtUG9zLnkgKz0gc2luKHQgKiByYW5kb20ueSArIDYuMjggKiByYW5kb20ueCkgKiBtaXgoMC4xLCAxLjUsIHJhbmRvbS53KTtcclxuICAgIG1Qb3MueiArPSBzaW4odCAqIHJhbmRvbS53ICsgNi4yOCAqIHJhbmRvbS55KSAqIG1peCgwLjEsIDEuNSwgcmFuZG9tLnopO1xyXG4gICAgXHJcbiAgICB2ZWM0IG12UG9zID0gdmlld01hdHJpeCAqIG1Qb3M7XHJcblxyXG4gICAgaWYgKHVTaXplUmFuZG9tbmVzcyA9PSAwLjApIHtcclxuICAgICAgZ2xfUG9pbnRTaXplID0gdUJhc2VTaXplO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZ2xfUG9pbnRTaXplID0gKHVCYXNlU2l6ZSAqICgxLjAgKyB1U2l6ZVJhbmRvbW5lc3MgKiAocmFuZG9tLnggLSAwLjUpKSkgLyBsZW5ndGgobXZQb3MueHl6KTtcclxuICAgIH1cclxuXHJcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvcztcclxuICB9XHJcbmA7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi8gYFxyXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuICBcclxuICB1bmlmb3JtIGZsb2F0IHVUaW1lO1xyXG4gIHVuaWZvcm0gZmxvYXQgdUFscGhhUGFydGljbGVzO1xyXG4gIHZhcnlpbmcgdmVjNCB2UmFuZG9tO1xyXG4gIHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcbiAgXHJcbiAgdm9pZCBtYWluKCkge1xyXG4gICAgdmVjMiB1diA9IGdsX1BvaW50Q29vcmQueHk7XHJcbiAgICBmbG9hdCBkID0gbGVuZ3RoKHV2IC0gdmVjMigwLjUpKTtcclxuICAgIFxyXG4gICAgaWYodUFscGhhUGFydGljbGVzIDwgMC41KSB7XHJcbiAgICAgIGlmKGQgPiAwLjUpIHtcclxuICAgICAgICBkaXNjYXJkO1xyXG4gICAgICB9XHJcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodkNvbG9yICsgMC4yICogc2luKHV2Lnl4eCArIHVUaW1lICsgdlJhbmRvbS55ICogNi4yOCksIDEuMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmbG9hdCBjaXJjbGUgPSBzbW9vdGhzdGVwKDAuNSwgMC40LCBkKSAqIDAuODtcclxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IgKyAwLjIgKiBzaW4odXYueXh4ICsgdVRpbWUgKyB2UmFuZG9tLnkgKiA2LjI4KSwgY2lyY2xlKTtcclxuICAgIH1cclxuICB9XHJcbmA7XHJcblxyXG5jb25zdCBQYXJ0aWNsZXMgPSAoe1xyXG4gIHBhcnRpY2xlQ291bnQgPSAyMDAsXHJcbiAgcGFydGljbGVTcHJlYWQgPSAxMCxcclxuICBzcGVlZCA9IDAuMSxcclxuICBwYXJ0aWNsZUNvbG9ycyxcclxuICBtb3ZlUGFydGljbGVzT25Ib3ZlciA9IGZhbHNlLFxyXG4gIHBhcnRpY2xlSG92ZXJGYWN0b3IgPSAxLFxyXG4gIGFscGhhUGFydGljbGVzID0gZmFsc2UsXHJcbiAgcGFydGljbGVCYXNlU2l6ZSA9IDEwMCxcclxuICBzaXplUmFuZG9tbmVzcyA9IDEsXHJcbiAgY2FtZXJhRGlzdGFuY2UgPSAyMCxcclxuICBkaXNhYmxlUm90YXRpb24gPSBmYWxzZSxcclxuICBwaXhlbFJhdGlvID0gMSxcclxuICBjbGFzc05hbWVcclxufSkgPT4ge1xyXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCBtb3VzZVJlZiA9IHVzZVJlZih7IHg6IDAsIHk6IDAgfSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcclxuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xyXG4gICAgICBkcHI6IHBpeGVsUmF0aW8sXHJcbiAgICAgIGRlcHRoOiBmYWxzZSxcclxuICAgICAgYWxwaGE6IHRydWVcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChnbC5jYW52YXMpO1xyXG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcclxuXHJcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgQ2FtZXJhKGdsLCB7IGZvdjogMTUgfSk7XHJcbiAgICBjYW1lcmEucG9zaXRpb24uc2V0KDAsIDAsIGNhbWVyYURpc3RhbmNlKTtcclxuXHJcbiAgICBjb25zdCByZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xyXG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICBjYW1lcmEucGVyc3BlY3RpdmUoeyBhc3BlY3Q6IGdsLmNhbnZhcy53aWR0aCAvIGdsLmNhbnZhcy5oZWlnaHQgfSk7XHJcbiAgICB9O1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSwgZmFsc2UpO1xyXG4gICAgcmVzaXplKCk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gZSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIGNvbnN0IHggPSAoKGUuY2xpZW50WCAtIHJlY3QubGVmdCkgLyByZWN0LndpZHRoKSAqIDIgLSAxO1xyXG4gICAgICBjb25zdCB5ID0gLSgoKGUuY2xpZW50WSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0KSAqIDIgLSAxKTtcclxuICAgICAgbW91c2VSZWYuY3VycmVudCA9IHsgeCwgeSB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAobW92ZVBhcnRpY2xlc09uSG92ZXIpIHtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY291bnQgPSBwYXJ0aWNsZUNvdW50O1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIDMpO1xyXG4gICAgY29uc3QgcmFuZG9tcyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiA0KTtcclxuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAzKTtcclxuICAgIGNvbnN0IHBhbGV0dGUgPSBwYXJ0aWNsZUNvbG9ycyAmJiBwYXJ0aWNsZUNvbG9ycy5sZW5ndGggPiAwID8gcGFydGljbGVDb2xvcnMgOiBkZWZhdWx0Q29sb3JzO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBsZXQgeCwgeSwgeiwgbGVuO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgeCA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcclxuICAgICAgICB5ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xyXG4gICAgICAgIHogPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XHJcbiAgICAgICAgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xyXG4gICAgICB9IHdoaWxlIChsZW4gPiAxIHx8IGxlbiA9PT0gMCk7XHJcbiAgICAgIGNvbnN0IHIgPSBNYXRoLmNicnQoTWF0aC5yYW5kb20oKSk7XHJcbiAgICAgIHBvc2l0aW9ucy5zZXQoW3ggKiByLCB5ICogciwgeiAqIHJdLCBpICogMyk7XHJcbiAgICAgIHJhbmRvbXMuc2V0KFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSwgaSAqIDQpO1xyXG4gICAgICBjb25zdCBjb2wgPSBoZXhUb1JnYihwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV0pO1xyXG4gICAgICBjb2xvcnMuc2V0KGNvbCwgaSAqIDMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KGdsLCB7XHJcbiAgICAgIHBvc2l0aW9uOiB7IHNpemU6IDMsIGRhdGE6IHBvc2l0aW9ucyB9LFxyXG4gICAgICByYW5kb206IHsgc2l6ZTogNCwgZGF0YTogcmFuZG9tcyB9LFxyXG4gICAgICBjb2xvcjogeyBzaXplOiAzLCBkYXRhOiBjb2xvcnMgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB7XHJcbiAgICAgIHZlcnRleCxcclxuICAgICAgZnJhZ21lbnQsXHJcbiAgICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgdVRpbWU6IHsgdmFsdWU6IDAgfSxcclxuICAgICAgICB1U3ByZWFkOiB7IHZhbHVlOiBwYXJ0aWNsZVNwcmVhZCB9LFxyXG4gICAgICAgIHVCYXNlU2l6ZTogeyB2YWx1ZTogcGFydGljbGVCYXNlU2l6ZSAqIHBpeGVsUmF0aW8gfSxcclxuICAgICAgICB1U2l6ZVJhbmRvbW5lc3M6IHsgdmFsdWU6IHNpemVSYW5kb21uZXNzIH0sXHJcbiAgICAgICAgdUFscGhhUGFydGljbGVzOiB7IHZhbHVlOiBhbHBoYVBhcnRpY2xlcyA/IDEgOiAwIH1cclxuICAgICAgfSxcclxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICAgIGRlcHRoVGVzdDogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHBhcnRpY2xlcyA9IG5ldyBNZXNoKGdsLCB7IG1vZGU6IGdsLlBPSU5UUywgZ2VvbWV0cnksIHByb2dyYW0gfSk7XHJcblxyXG4gICAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ7XHJcbiAgICBsZXQgbGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIGxldCBlbGFwc2VkID0gMDtcclxuXHJcbiAgICBjb25zdCB1cGRhdGUgPSB0ID0+IHtcclxuICAgICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xyXG4gICAgICBjb25zdCBkZWx0YSA9IHQgLSBsYXN0VGltZTtcclxuICAgICAgbGFzdFRpbWUgPSB0O1xyXG4gICAgICBlbGFwc2VkICs9IGRlbHRhICogc3BlZWQ7XHJcblxyXG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLnVUaW1lLnZhbHVlID0gZWxhcHNlZCAqIDAuMDAxO1xyXG5cclxuICAgICAgaWYgKG1vdmVQYXJ0aWNsZXNPbkhvdmVyKSB7XHJcbiAgICAgICAgcGFydGljbGVzLnBvc2l0aW9uLnggPSAtbW91c2VSZWYuY3VycmVudC54ICogcGFydGljbGVIb3ZlckZhY3RvcjtcclxuICAgICAgICBwYXJ0aWNsZXMucG9zaXRpb24ueSA9IC1tb3VzZVJlZi5jdXJyZW50LnkgKiBwYXJ0aWNsZUhvdmVyRmFjdG9yO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnRpY2xlcy5wb3NpdGlvbi54ID0gMDtcclxuICAgICAgICBwYXJ0aWNsZXMucG9zaXRpb24ueSA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZGlzYWJsZVJvdGF0aW9uKSB7XHJcbiAgICAgICAgcGFydGljbGVzLnJvdGF0aW9uLnggPSBNYXRoLnNpbihlbGFwc2VkICogMC4wMDAyKSAqIDAuMTtcclxuICAgICAgICBwYXJ0aWNsZXMucm90YXRpb24ueSA9IE1hdGguY29zKGVsYXBzZWQgKiAwLjAwMDUpICogMC4xNTtcclxuICAgICAgICBwYXJ0aWNsZXMucm90YXRpb24ueiArPSAwLjAxICogc3BlZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlbmRlcmVyLnJlbmRlcih7IHNjZW5lOiBwYXJ0aWNsZXMsIGNhbWVyYSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUpO1xyXG4gICAgICBpZiAobW92ZVBhcnRpY2xlc09uSG92ZXIpIHtcclxuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgICAgfVxyXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcclxuICAgICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhnbC5jYW52YXMpKSB7XHJcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGdsLmNhbnZhcyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW1xyXG4gICAgcGFydGljbGVDb3VudCxcclxuICAgIHBhcnRpY2xlU3ByZWFkLFxyXG4gICAgc3BlZWQsXHJcbiAgICBtb3ZlUGFydGljbGVzT25Ib3ZlcixcclxuICAgIHBhcnRpY2xlSG92ZXJGYWN0b3IsXHJcbiAgICBhbHBoYVBhcnRpY2xlcyxcclxuICAgIHBhcnRpY2xlQmFzZVNpemUsXHJcbiAgICBzaXplUmFuZG9tbmVzcyxcclxuICAgIGNhbWVyYURpc3RhbmNlLFxyXG4gICAgZGlzYWJsZVJvdGF0aW9uLFxyXG4gICAgcGl4ZWxSYXRpb1xyXG4gIF0pO1xyXG5cclxuICByZXR1cm4gPGRpdiByZWY9e2NvbnRhaW5lclJlZn0gY2xhc3NOYW1lPXtgcmVsYXRpdmUgdy1mdWxsIGgtZnVsbCAke2NsYXNzTmFtZX1gfSAvPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBhcnRpY2xlcztcclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlJlbmRlcmVyIiwiQ2FtZXJhIiwiR2VvbWV0cnkiLCJQcm9ncmFtIiwiTWVzaCIsImRlZmF1bHRDb2xvcnMiLCJoZXhUb1JnYiIsImhleCIsInJlcGxhY2UiLCJsZW5ndGgiLCJzcGxpdCIsIm1hcCIsImMiLCJqb2luIiwiaW50IiwicGFyc2VJbnQiLCJyIiwiZyIsImIiLCJ2ZXJ0ZXgiLCJmcmFnbWVudCIsIlBhcnRpY2xlcyIsInBhcnRpY2xlQ291bnQiLCJwYXJ0aWNsZVNwcmVhZCIsInNwZWVkIiwicGFydGljbGVDb2xvcnMiLCJtb3ZlUGFydGljbGVzT25Ib3ZlciIsInBhcnRpY2xlSG92ZXJGYWN0b3IiLCJhbHBoYVBhcnRpY2xlcyIsInBhcnRpY2xlQmFzZVNpemUiLCJzaXplUmFuZG9tbmVzcyIsImNhbWVyYURpc3RhbmNlIiwiZGlzYWJsZVJvdGF0aW9uIiwicGl4ZWxSYXRpbyIsImNsYXNzTmFtZSIsImNvbnRhaW5lclJlZiIsIm1vdXNlUmVmIiwieCIsInkiLCJjb250YWluZXIiLCJjdXJyZW50IiwicmVuZGVyZXIiLCJkcHIiLCJkZXB0aCIsImFscGhhIiwiZ2wiLCJhcHBlbmRDaGlsZCIsImNhbnZhcyIsImNsZWFyQ29sb3IiLCJjYW1lcmEiLCJmb3YiLCJwb3NpdGlvbiIsInNldCIsInJlc2l6ZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzZXRTaXplIiwicGVyc3BlY3RpdmUiLCJhc3BlY3QiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlTW91c2VNb3ZlIiwiZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJjb3VudCIsInBvc2l0aW9ucyIsIkZsb2F0MzJBcnJheSIsInJhbmRvbXMiLCJjb2xvcnMiLCJwYWxldHRlIiwiaSIsInoiLCJsZW4iLCJNYXRoIiwicmFuZG9tIiwiY2JydCIsImNvbCIsImZsb29yIiwiZ2VvbWV0cnkiLCJzaXplIiwiZGF0YSIsImNvbG9yIiwicHJvZ3JhbSIsInVuaWZvcm1zIiwidVRpbWUiLCJ2YWx1ZSIsInVTcHJlYWQiLCJ1QmFzZVNpemUiLCJ1U2l6ZVJhbmRvbW5lc3MiLCJ1QWxwaGFQYXJ0aWNsZXMiLCJ0cmFuc3BhcmVudCIsImRlcHRoVGVzdCIsInBhcnRpY2xlcyIsIm1vZGUiLCJQT0lOVFMiLCJhbmltYXRpb25GcmFtZUlkIiwibGFzdFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVsYXBzZWQiLCJ1cGRhdGUiLCJ0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZGVsdGEiLCJyb3RhdGlvbiIsInNpbiIsImNvcyIsInJlbmRlciIsInNjZW5lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY29udGFpbnMiLCJyZW1vdmVDaGlsZCIsImRpdiIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/Particles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/StaggeredMenu.js":
/*!*****************************************!*\
  !*** ./app/components/StaggeredMenu.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StaggeredMenu: function() { return /* binding */ StaggeredMenu; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/gsap/index.js\");\n/* __next_internal_client_entry_do_not_use__ StaggeredMenu,default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst StaggeredMenu = (param)=>{\n    let { position = \"right\", colors = [\n        \"#10b981\",\n        \"#34d399\",\n        \"#059669\"\n    ], items = [], socialItems = [], displaySocials = true, displayItemNumbering = true, className, logoUrl = \"/src/assets/logos/reactbits-gh-white.svg\", menuButtonColor = \"#fff\", openMenuButtonColor = \"#fff\", changeMenuColorOnOpen = true, isFixed = false, accentColor = \"#5227FF\", closeOnClickAway = true, customLogo, headerClassName = \"\", onMenuOpen, onMenuClose } = param;\n    _s();\n    const [open, setOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const openRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const panelRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const preLayersRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const preLayerElsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const plusHRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const plusVRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const iconRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textInnerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textWrapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [textLines, setTextLines] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        \"Menu\",\n        \"Close\"\n    ]);\n    const openTlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const closeTweenRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const spinTweenRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textCycleAnimRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const colorTweenRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const toggleBtnRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const busyRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const itemEntranceTweenRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        const ctx = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.context(()=>{\n            const panel = panelRef.current;\n            const preContainer = preLayersRef.current;\n            const plusH = plusHRef.current;\n            const plusV = plusVRef.current;\n            const icon = iconRef.current;\n            const textInner = textInnerRef.current;\n            if (!panel || !plusH || !plusV || !icon || !textInner) return;\n            let preLayers = [];\n            if (preContainer) {\n                preLayers = Array.from(preContainer.querySelectorAll(\".sm-prelayer\"));\n            }\n            preLayerElsRef.current = preLayers;\n            const offscreen = position === \"left\" ? -100 : 100;\n            gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set([\n                panel,\n                ...preLayers\n            ], {\n                xPercent: offscreen\n            });\n            gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(plusH, {\n                transformOrigin: \"50% 50%\",\n                rotate: 0\n            });\n            gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(plusV, {\n                transformOrigin: \"50% 50%\",\n                rotate: 90\n            });\n            gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(icon, {\n                rotate: 0,\n                transformOrigin: \"50% 50%\"\n            });\n            gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(textInner, {\n                yPercent: 0\n            });\n            if (toggleBtnRef.current) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(toggleBtnRef.current, {\n                color: menuButtonColor\n            });\n        });\n        return ()=>ctx.revert();\n    }, [\n        menuButtonColor,\n        position\n    ]);\n    const buildOpenTimeline = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _openTlRef_current, _itemEntranceTweenRef_current;\n        const panel = panelRef.current;\n        const layers = preLayerElsRef.current;\n        if (!panel) return null;\n        (_openTlRef_current = openTlRef.current) === null || _openTlRef_current === void 0 ? void 0 : _openTlRef_current.kill();\n        if (closeTweenRef.current) {\n            closeTweenRef.current.kill();\n            closeTweenRef.current = null;\n        }\n        (_itemEntranceTweenRef_current = itemEntranceTweenRef.current) === null || _itemEntranceTweenRef_current === void 0 ? void 0 : _itemEntranceTweenRef_current.kill();\n        const itemEls = Array.from(panel.querySelectorAll(\".sm-panel-itemLabel\"));\n        const numberEls = Array.from(panel.querySelectorAll(\".sm-panel-list[data-numbering] .sm-panel-item\"));\n        const socialTitle = panel.querySelector(\".sm-socials-title\");\n        const socialLinks = Array.from(panel.querySelectorAll(\".sm-socials-link\"));\n        const layerStates = layers.map((el)=>({\n                el,\n                start: Number(gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.getProperty(el, \"xPercent\"))\n            }));\n        const panelStart = Number(gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.getProperty(panel, \"xPercent\"));\n        if (itemEls.length) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(itemEls, {\n            yPercent: 140,\n            rotate: 10\n        });\n        if (numberEls.length) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(numberEls, {\n            [\"--sm-num-opacity\"]: 0\n        });\n        if (socialTitle) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(socialTitle, {\n            opacity: 0\n        });\n        if (socialLinks.length) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(socialLinks, {\n            y: 25,\n            opacity: 0\n        });\n        const tl = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.timeline({\n            paused: true\n        });\n        layerStates.forEach((ls, i)=>{\n            tl.fromTo(ls.el, {\n                xPercent: ls.start\n            }, {\n                xPercent: 0,\n                duration: 0.5,\n                ease: \"power4.out\"\n            }, i * 0.07);\n        });\n        const lastTime = layerStates.length ? (layerStates.length - 1) * 0.07 : 0;\n        const panelInsertTime = lastTime + (layerStates.length ? 0.08 : 0);\n        const panelDuration = 0.65;\n        tl.fromTo(panel, {\n            xPercent: panelStart\n        }, {\n            xPercent: 0,\n            duration: panelDuration,\n            ease: \"power4.out\"\n        }, panelInsertTime);\n        if (itemEls.length) {\n            const itemsStartRatio = 0.15;\n            const itemsStart = panelInsertTime + panelDuration * itemsStartRatio;\n            tl.to(itemEls, {\n                yPercent: 0,\n                rotate: 0,\n                duration: 1,\n                ease: \"power4.out\",\n                stagger: {\n                    each: 0.1,\n                    from: \"start\"\n                }\n            }, itemsStart);\n            if (numberEls.length) {\n                tl.to(numberEls, {\n                    duration: 0.6,\n                    ease: \"power2.out\",\n                    [\"--sm-num-opacity\"]: 1,\n                    stagger: {\n                        each: 0.08,\n                        from: \"start\"\n                    }\n                }, itemsStart + 0.1);\n            }\n        }\n        if (socialTitle || socialLinks.length) {\n            const socialsStart = panelInsertTime + panelDuration * 0.4;\n            if (socialTitle) tl.to(socialTitle, {\n                opacity: 1,\n                duration: 0.5,\n                ease: \"power2.out\"\n            }, socialsStart);\n            if (socialLinks.length) {\n                tl.to(socialLinks, {\n                    y: 0,\n                    opacity: 1,\n                    duration: 0.55,\n                    ease: \"power3.out\",\n                    stagger: {\n                        each: 0.08,\n                        from: \"start\"\n                    },\n                    onComplete: ()=>gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(socialLinks, {\n                            clearProps: \"opacity\"\n                        })\n                }, socialsStart + 0.04);\n            }\n        }\n        openTlRef.current = tl;\n        return tl;\n    }, []);\n    const playOpen = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (busyRef.current) return;\n        busyRef.current = true;\n        const tl = buildOpenTimeline();\n        if (tl) {\n            tl.eventCallback(\"onComplete\", ()=>{\n                busyRef.current = false;\n            });\n            tl.play(0);\n        } else {\n            busyRef.current = false;\n        }\n    }, [\n        buildOpenTimeline\n    ]);\n    const playClose = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _openTlRef_current, _itemEntranceTweenRef_current, _closeTweenRef_current;\n        (_openTlRef_current = openTlRef.current) === null || _openTlRef_current === void 0 ? void 0 : _openTlRef_current.kill();\n        openTlRef.current = null;\n        (_itemEntranceTweenRef_current = itemEntranceTweenRef.current) === null || _itemEntranceTweenRef_current === void 0 ? void 0 : _itemEntranceTweenRef_current.kill();\n        const panel = panelRef.current;\n        const layers = preLayerElsRef.current;\n        if (!panel) return;\n        const all = [\n            ...layers,\n            panel\n        ];\n        (_closeTweenRef_current = closeTweenRef.current) === null || _closeTweenRef_current === void 0 ? void 0 : _closeTweenRef_current.kill();\n        const offscreen = position === \"left\" ? -100 : 100;\n        closeTweenRef.current = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.to(all, {\n            xPercent: offscreen,\n            duration: 0.32,\n            ease: \"power3.in\",\n            overwrite: \"auto\",\n            onComplete: ()=>{\n                const itemEls = Array.from(panel.querySelectorAll(\".sm-panel-itemLabel\"));\n                if (itemEls.length) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(itemEls, {\n                    yPercent: 140,\n                    rotate: 10\n                });\n                const numberEls = Array.from(panel.querySelectorAll(\".sm-panel-list[data-numbering] .sm-panel-item\"));\n                if (numberEls.length) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(numberEls, {\n                    [\"--sm-num-opacity\"]: 0\n                });\n                const socialTitle = panel.querySelector(\".sm-socials-title\");\n                const socialLinks = Array.from(panel.querySelectorAll(\".sm-socials-link\"));\n                if (socialTitle) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(socialTitle, {\n                    opacity: 0\n                });\n                if (socialLinks.length) gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(socialLinks, {\n                    y: 25,\n                    opacity: 0\n                });\n                busyRef.current = false;\n            }\n        });\n    }, [\n        position\n    ]);\n    const animateIcon = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((opening)=>{\n        var _spinTweenRef_current;\n        const icon = iconRef.current;\n        const h = plusHRef.current;\n        const v = plusVRef.current;\n        if (!icon || !h || !v) return;\n        (_spinTweenRef_current = spinTweenRef.current) === null || _spinTweenRef_current === void 0 ? void 0 : _spinTweenRef_current.kill();\n        if (opening) {\n            gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(icon, {\n                rotate: 0,\n                transformOrigin: \"50% 50%\"\n            });\n            spinTweenRef.current = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.timeline({\n                defaults: {\n                    ease: \"power4.out\"\n                }\n            }).to(h, {\n                rotate: 45,\n                duration: 0.5\n            }, 0).to(v, {\n                rotate: -45,\n                duration: 0.5\n            }, 0);\n        } else {\n            spinTweenRef.current = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.timeline({\n                defaults: {\n                    ease: \"power3.inOut\"\n                }\n            }).to(h, {\n                rotate: 0,\n                duration: 0.35\n            }, 0).to(v, {\n                rotate: 90,\n                duration: 0.35\n            }, 0).to(icon, {\n                rotate: 0,\n                duration: 0.001\n            }, 0);\n        }\n    }, []);\n    const animateColor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((opening)=>{\n        var _colorTweenRef_current;\n        const btn = toggleBtnRef.current;\n        if (!btn) return;\n        (_colorTweenRef_current = colorTweenRef.current) === null || _colorTweenRef_current === void 0 ? void 0 : _colorTweenRef_current.kill();\n        if (changeMenuColorOnOpen) {\n            const targetColor = opening ? openMenuButtonColor : menuButtonColor;\n            colorTweenRef.current = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.to(btn, {\n                color: targetColor,\n                delay: 0.18,\n                duration: 0.3,\n                ease: \"power2.out\"\n            });\n        } else {\n            gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(btn, {\n                color: menuButtonColor\n            });\n        }\n    }, [\n        openMenuButtonColor,\n        menuButtonColor,\n        changeMenuColorOnOpen\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        if (toggleBtnRef.current) {\n            if (changeMenuColorOnOpen) {\n                const targetColor = openRef.current ? openMenuButtonColor : menuButtonColor;\n                gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(toggleBtnRef.current, {\n                    color: targetColor\n                });\n            } else {\n                gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(toggleBtnRef.current, {\n                    color: menuButtonColor\n                });\n            }\n        }\n    }, [\n        changeMenuColorOnOpen,\n        menuButtonColor,\n        openMenuButtonColor\n    ]);\n    const animateText = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((opening)=>{\n        var _textCycleAnimRef_current;\n        const inner = textInnerRef.current;\n        if (!inner) return;\n        (_textCycleAnimRef_current = textCycleAnimRef.current) === null || _textCycleAnimRef_current === void 0 ? void 0 : _textCycleAnimRef_current.kill();\n        const currentLabel = opening ? \"Menu\" : \"Close\";\n        const targetLabel = opening ? \"Close\" : \"Menu\";\n        const cycles = 3;\n        const seq = [\n            currentLabel\n        ];\n        let last = currentLabel;\n        for(let i = 0; i < cycles; i++){\n            last = last === \"Menu\" ? \"Close\" : \"Menu\";\n            seq.push(last);\n        }\n        if (last !== targetLabel) seq.push(targetLabel);\n        seq.push(targetLabel);\n        setTextLines(seq);\n        gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.set(inner, {\n            yPercent: 0\n        });\n        const lineCount = seq.length;\n        const finalShift = (lineCount - 1) / lineCount * 100;\n        textCycleAnimRef.current = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.to(inner, {\n            yPercent: -finalShift,\n            duration: 0.5 + lineCount * 0.07,\n            ease: \"power4.out\"\n        });\n    }, []);\n    const toggleMenu = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const target = !openRef.current;\n        openRef.current = target;\n        setOpen(target);\n        if (target) {\n            onMenuOpen === null || onMenuOpen === void 0 ? void 0 : onMenuOpen();\n            playOpen();\n        } else {\n            onMenuClose === null || onMenuClose === void 0 ? void 0 : onMenuClose();\n            playClose();\n        }\n        animateIcon(target);\n        animateColor(target);\n        animateText(target);\n    }, [\n        playOpen,\n        playClose,\n        animateIcon,\n        animateColor,\n        animateText,\n        onMenuOpen,\n        onMenuClose\n    ]);\n    const closeMenu = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (openRef.current) {\n            openRef.current = false;\n            setOpen(false);\n            onMenuClose === null || onMenuClose === void 0 ? void 0 : onMenuClose();\n            playClose();\n            animateIcon(false);\n            animateColor(false);\n            animateText(false);\n        }\n    }, [\n        playClose,\n        animateIcon,\n        animateColor,\n        animateText,\n        onMenuClose\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        if (!closeOnClickAway || !open) return;\n        const handleClickOutside = (event)=>{\n            if (panelRef.current && !panelRef.current.contains(event.target) && toggleBtnRef.current && !toggleBtnRef.current.contains(event.target)) {\n                closeMenu();\n            }\n        };\n        document.addEventListener(\"mousedown\", handleClickOutside);\n        return ()=>{\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n        };\n    }, [\n        closeOnClickAway,\n        open,\n        closeMenu\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"sm-scope z-40 \".concat(isFixed ? \"fixed top-0 left-0 w-screen h-screen overflow-hidden\" : \"w-full h-full\"),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (className ? className + \" \" : \"\") + \"staggered-menu-wrapper pointer-events-none relative w-full h-full\",\n                style: accentColor ? {\n                    [\"--sm-accent\"]: accentColor\n                } : undefined,\n                \"data-position\": position,\n                \"data-open\": open || undefined,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        ref: preLayersRef,\n                        className: \"sm-prelayers absolute top-0 right-0 bottom-0 pointer-events-none z-[5]\",\n                        \"aria-hidden\": \"true\",\n                        children: (()=>{\n                            const raw = colors && colors.length ? colors.slice(0, 4) : [\n                                \"#1e1e22\",\n                                \"#35353c\"\n                            ];\n                            let arr = [\n                                ...raw\n                            ];\n                            if (arr.length >= 3) {\n                                const mid = Math.floor(arr.length / 2);\n                                arr.splice(mid, 1);\n                            }\n                            return arr.map((c, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"sm-prelayer absolute top-0 right-0 h-full w-full translate-x-0\",\n                                    style: {\n                                        background: c\n                                    }\n                                }, i, false, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                    lineNumber: 376,\n                                    columnNumber: 15\n                                }, undefined));\n                        })()\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                        lineNumber: 363,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                        className: \"staggered-menu-header absolute top-0 left-0 w-full flex items-center justify-between p-[2em] bg-transparent pointer-events-none z-20 \".concat(headerClassName),\n                        \"aria-label\": \"Main navigation header\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"sm-logo flex items-center select-none pointer-events-auto\",\n                                \"aria-label\": \"Logo\",\n                                children: customLogo ? customLogo : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: logoUrl || \"/src/assets/logos/reactbits-gh-white.svg\",\n                                    alt: \"Logo\",\n                                    className: \"sm-logo-img block h-8 w-auto object-contain\",\n                                    draggable: false,\n                                    width: 110,\n                                    height: 24\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                    lineNumber: 393,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                lineNumber: 389,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                ref: toggleBtnRef,\n                                className: \"sm-toggle relative inline-flex items-center gap-[0.3rem] bg-transparent border-0 cursor-pointer text-[#e9e9ef] font-medium leading-none overflow-visible pointer-events-auto\",\n                                \"aria-label\": open ? \"Close menu\" : \"Open menu\",\n                                \"aria-expanded\": open,\n                                \"aria-controls\": \"staggered-menu-panel\",\n                                onClick: toggleMenu,\n                                type: \"button\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        ref: textWrapRef,\n                                        className: \"sm-toggle-textWrap relative inline-block h-[1em] overflow-hidden whitespace-nowrap w-[var(--sm-toggle-width,auto)] min-w-[var(--sm-toggle-width,auto)]\",\n                                        \"aria-hidden\": \"true\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            ref: textInnerRef,\n                                            className: \"sm-toggle-textInner flex flex-col leading-none\",\n                                            children: textLines.map((l, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"sm-toggle-line block h-[1em] leading-none\",\n                                                    children: l\n                                                }, i, false, {\n                                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                    lineNumber: 420,\n                                                    columnNumber: 19\n                                                }, undefined))\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                            lineNumber: 418,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                        lineNumber: 413,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        ref: iconRef,\n                                        className: \"sm-icon relative w-[14px] h-[14px] shrink-0 inline-flex items-center justify-center [will-change:transform]\",\n                                        \"aria-hidden\": \"true\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                ref: plusHRef,\n                                                className: \"sm-icon-line absolute left-1/2 top-1/2 w-full h-[2px] bg-current rounded-[2px] -translate-x-1/2 -translate-y-1/2 [will-change:transform]\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                lineNumber: 432,\n                                                columnNumber: 15\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                ref: plusVRef,\n                                                className: \"sm-icon-line sm-icon-line-v absolute left-1/2 top-1/2 w-full h-[2px] bg-current rounded-[2px] -translate-x-1/2 -translate-y-1/2 [will-change:transform]\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                lineNumber: 436,\n                                                columnNumber: 15\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                        lineNumber: 427,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                lineNumber: 404,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                        lineNumber: 385,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"aside\", {\n                        id: \"staggered-menu-panel\",\n                        ref: panelRef,\n                        className: \"staggered-menu-panel absolute top-0 right-0 h-full bg-white flex flex-col p-[6em_2em_2em_2em] overflow-y-auto z-10 backdrop-blur-[12px] pointer-events-auto\",\n                        style: {\n                            WebkitBackdropFilter: \"blur(12px)\"\n                        },\n                        \"aria-hidden\": !open,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"sm-panel-inner flex-1 flex flex-col gap-5\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                    className: \"sm-panel-list list-none m-0 p-0 flex flex-col gap-2\",\n                                    role: \"list\",\n                                    \"data-numbering\": displayItemNumbering || undefined,\n                                    children: items && items.length ? items.map((it, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                            className: \"sm-panel-itemWrap relative overflow-hidden leading-none\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                                className: \"sm-panel-item relative text-black font-semibold text-[4rem] cursor-pointer leading-none tracking-[-2px] uppercase transition-[background,color] duration-150 ease-linear inline-block no-underline pr-[1.4em]\",\n                                                href: it.link,\n                                                \"aria-label\": it.ariaLabel,\n                                                \"data-index\": idx + 1,\n                                                onClick: ()=>{\n                                                    // Close menu when a link is clicked\n                                                    if (closeOnClickAway) closeMenu();\n                                                },\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"sm-panel-itemLabel inline-block [transform-origin:50%_100%] will-change-transform\",\n                                                    children: it.label\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                    lineNumber: 470,\n                                                    columnNumber: 23\n                                                }, undefined)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                lineNumber: 460,\n                                                columnNumber: 21\n                                            }, undefined)\n                                        }, it.label + idx, false, {\n                                            fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                            lineNumber: 459,\n                                            columnNumber: 19\n                                        }, undefined)) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"sm-panel-itemWrap relative overflow-hidden leading-none\",\n                                        \"aria-hidden\": \"true\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"sm-panel-item relative text-black font-semibold text-[4rem] cursor-pointer leading-none tracking-[-2px] uppercase transition-[background,color] duration-150 ease-linear inline-block no-underline pr-[1.4em]\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"sm-panel-itemLabel inline-block [transform-origin:50%_100%] will-change-transform\",\n                                                children: \"No items\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                lineNumber: 479,\n                                                columnNumber: 21\n                                            }, undefined)\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                            lineNumber: 478,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                        lineNumber: 477,\n                                        columnNumber: 17\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                    lineNumber: 452,\n                                    columnNumber: 13\n                                }, undefined),\n                                displaySocials && socialItems && socialItems.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"sm-socials mt-auto pt-8 flex flex-col gap-3\",\n                                    \"aria-label\": \"Social links\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: \"sm-socials-title m-0 text-base font-medium [color:var(--sm-accent,#ff0000)]\",\n                                            children: \"Socials\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                            lineNumber: 489,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                            className: \"sm-socials-list list-none m-0 p-0 flex flex-row items-center gap-4 flex-wrap\",\n                                            role: \"list\",\n                                            children: socialItems.map((s, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    className: \"sm-socials-item\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                                        href: s.link,\n                                                        target: \"_blank\",\n                                                        rel: \"noopener noreferrer\",\n                                                        className: \"sm-socials-link text-[1.2rem] font-medium text-[#111] no-underline relative inline-block py-[2px] transition-[color,opacity] duration-300 ease-linear\",\n                                                        children: s.label\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                        lineNumber: 496,\n                                                        columnNumber: 23\n                                                    }, undefined)\n                                                }, s.label + i, false, {\n                                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                                    lineNumber: 495,\n                                                    columnNumber: 21\n                                                }, undefined))\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                            lineNumber: 490,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                                    lineNumber: 488,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                            lineNumber: 451,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                        lineNumber: 444,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                lineNumber: 355,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"style\", {\n                dangerouslySetInnerHTML: {\n                    __html: \"\\n.sm-scope .staggered-menu-wrapper { position: relative; width: 100%; height: 100%; z-index: 40; pointer-events: none; }\\n.sm-scope .staggered-menu-header { position: absolute; top: 0; left: 0; width: 100%; display: flex; align-items: center; justify-content: space-between; padding: 2em; background: transparent; pointer-events: none; z-index: 20; }\\n.sm-scope .staggered-menu-header > * { pointer-events: auto; }\\n.sm-scope .sm-logo { display: flex; align-items: center; user-select: none; }\\n.sm-scope .sm-logo-img { display: block; height: 32px; width: auto; object-fit: contain; }\\n.sm-scope .sm-toggle { position: relative; display: inline-flex; align-items: center; gap: 0.3rem; background: transparent; border: none; cursor: pointer; color: #e9e9ef; font-weight: 500; line-height: 1; overflow: visible; }\\n.sm-scope .sm-toggle:focus-visible { outline: 2px solid #ffffffaa; outline-offset: 4px; border-radius: 4px; }\\n.sm-scope .sm-line:last-of-type { margin-top: 6px; }\\n.sm-scope .sm-toggle-textWrap { position: relative; margin-right: 0.5em; display: inline-block; height: 1em; overflow: hidden; white-space: nowrap; width: var(--sm-toggle-width, auto); min-width: var(--sm-toggle-width, auto); }\\n.sm-scope .sm-toggle-textInner { display: flex; flex-direction: column; line-height: 1; }\\n.sm-scope .sm-toggle-line { display: block; height: 1em; line-height: 1; }\\n.sm-scope .sm-icon { position: relative; width: 14px; height: 14px; flex: 0 0 14px; display: inline-flex; align-items: center; justify-content: center; will-change: transform; }\\n.sm-scope .sm-panel-itemWrap { position: relative; overflow: hidden; line-height: 1; }\\n.sm-scope .sm-icon-line { position: absolute; left: 50%; top: 50%; width: 100%; height: 2px; background: currentColor; border-radius: 2px; transform: translate(-50%, -50%); will-change: transform; }\\n.sm-scope .sm-line { display: none !important; }\\n.sm-scope .staggered-menu-panel { position: absolute; top: 0; right: 0; width: clamp(260px, 38vw, 420px); height: 100%; background: white; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); display: flex; flex-direction: column; padding: 6em 2em 2em 2em; overflow-y: auto; z-index: 10; transform: translateX(100%); }\\n.sm-scope [data-position='left'] .staggered-menu-panel { right: auto; left: 0; transform: translateX(-100%); }\\n.sm-scope .sm-prelayers { position: absolute; top: 0; right: 0; bottom: 0; width: clamp(260px, 38vw, 420px); pointer-events: none; z-index: 5; }\\n.sm-scope [data-position='left'] .sm-prelayers { right: auto; left: 0; }\\n.sm-scope [data-position='left'] .sm-prelayer { transform: translateX(-100%); }\\n.sm-scope .sm-prelayer { position: absolute; top: 0; right: 0; height: 100%; width: 100%; transform: translateX(100%); }\\n.sm-scope .sm-panel-inner { flex: 1; display: flex; flex-direction: column; gap: 1.25rem; }\\n.sm-scope .sm-socials { margin-top: auto; padding-top: 2rem; display: flex; flex-direction: column; gap: 0.75rem; }\\n.sm-scope .sm-socials-title { margin: 0; font-size: 1rem; font-weight: 500; color: var(--sm-accent, #ff0000); }\\n.sm-scope .sm-socials-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: row; align-items: center; gap: 1rem; flex-wrap: wrap; }\\n.sm-scope .sm-socials-list .sm-socials-link { opacity: 1; transition: opacity 0.3s ease; }\\n.sm-scope .sm-socials-list:hover .sm-socials-link:not(:hover) { opacity: 0.35; }\\n.sm-scope .sm-socials-list:focus-within .sm-socials-link:not(:focus-visible) { opacity: 0.35; }\\n.sm-scope .sm-socials-list .sm-socials-link:hover,\\n.sm-scope .sm-socials-list .sm-socials-link:focus-visible { opacity: 1; }\\n.sm-scope .sm-socials-link:focus-visible { outline: 2px solid var(--sm-accent, #ff0000); outline-offset: 3px; }\\n.sm-scope .sm-socials-link { font-size: 1.2rem; font-weight: 500; color: #111; text-decoration: none; position: relative; padding: 2px 0; display: inline-block; transition: color 0.3s ease, opacity 0.3s ease; }\\n.sm-scope .sm-socials-link:hover { color: var(--sm-accent, #ff0000); }\\n.sm-scope .sm-panel-title { margin: 0; font-size: 1rem; font-weight: 600; color: #fff; text-transform: uppercase; }\\n.sm-scope .sm-panel-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 0.5rem; }\\n.sm-scope .sm-panel-item { position: relative; color: #000; font-weight: 600; font-size: 4rem; cursor: pointer; line-height: 1; letter-spacing: -2px; text-transform: uppercase; transition: background 0.25s, color 0.25s; display: inline-block; text-decoration: none; padding-right: 1.4em; }\\n.sm-scope .sm-panel-itemLabel { display: inline-block; will-change: transform; transform-origin: 50% 100%; }\\n.sm-scope .sm-panel-item:hover { color: var(--sm-accent, #ff0000); }\\n.sm-scope .sm-panel-list[data-numbering] { counter-reset: smItem; }\\n.sm-scope .sm-panel-list[data-numbering] .sm-panel-item::after { counter-increment: smItem; content: counter(smItem, decimal-leading-zero); position: absolute; top: 0.1em; right: 3.2em; font-size: 18px; font-weight: 400; color: var(--sm-accent, #ff0000); letter-spacing: 0; pointer-events: none; user-select: none; opacity: var(--sm-num-opacity, 0); }\\n@media (max-width: 1024px) { .sm-scope .staggered-menu-panel { width: 100%; left: 0; right: 0; } .sm-scope .staggered-menu-wrapper[data-open] .sm-logo-img { filter: invert(100%); } }\\n@media (max-width: 640px) { .sm-scope .staggered-menu-panel { width: 100%; left: 0; right: 0; } .sm-scope .staggered-menu-wrapper[data-open] .sm-logo-img { filter: invert(100%); } }\\n      \"\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n                lineNumber: 513,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\USER\\\\Downloads\\\\pot\\\\bus-transport-app\\\\app\\\\components\\\\StaggeredMenu.js\",\n        lineNumber: 352,\n        columnNumber: 5\n    }, undefined);\n};\n_s(StaggeredMenu, \"NUrbJG76cb1TBA/TbGQQV+2q5C4=\");\n_c = StaggeredMenu;\n/* harmony default export */ __webpack_exports__[\"default\"] = (StaggeredMenu);\nvar _c;\n$RefreshReg$(_c, \"StaggeredMenu\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1N0YWdnZXJlZE1lbnUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFOEU7QUFDakQ7QUFDRDtBQUVyQixNQUFNTyxnQkFBZ0I7UUFBQyxFQUM1QkMsV0FBVyxPQUFPLEVBQ2xCQyxTQUFTO1FBQUM7UUFBVztRQUFXO0tBQVUsRUFDMUNDLFFBQVEsRUFBRSxFQUNWQyxjQUFjLEVBQUUsRUFDaEJDLGlCQUFpQixJQUFJLEVBQ3JCQyx1QkFBdUIsSUFBSSxFQUMzQkMsU0FBUyxFQUNUQyxVQUFVLDBDQUEwQyxFQUNwREMsa0JBQWtCLE1BQU0sRUFDeEJDLHNCQUFzQixNQUFNLEVBQzVCQyx3QkFBd0IsSUFBSSxFQUM1QkMsVUFBVSxLQUFLLEVBQ2ZDLGNBQWMsU0FBUyxFQUN2QkMsbUJBQW1CLElBQUksRUFDdkJDLFVBQVUsRUFDVkMsa0JBQWtCLEVBQUUsRUFDcEJDLFVBQVUsRUFDVkMsV0FBVyxFQUNaOztJQUNDLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHdkIsK0NBQVFBLENBQUM7SUFDakMsTUFBTXdCLFVBQVV6Qiw2Q0FBTUEsQ0FBQztJQUV2QixNQUFNMEIsV0FBVzFCLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU0yQixlQUFlM0IsNkNBQU1BLENBQUM7SUFDNUIsTUFBTTRCLGlCQUFpQjVCLDZDQUFNQSxDQUFDLEVBQUU7SUFFaEMsTUFBTTZCLFdBQVc3Qiw2Q0FBTUEsQ0FBQztJQUN4QixNQUFNOEIsV0FBVzlCLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU0rQixVQUFVL0IsNkNBQU1BLENBQUM7SUFFdkIsTUFBTWdDLGVBQWVoQyw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNaUMsY0FBY2pDLDZDQUFNQSxDQUFDO0lBQzNCLE1BQU0sQ0FBQ2tDLFdBQVdDLGFBQWEsR0FBR2xDLCtDQUFRQSxDQUFDO1FBQUM7UUFBUTtLQUFRO0lBRTVELE1BQU1tQyxZQUFZcEMsNkNBQU1BLENBQUM7SUFDekIs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eEI7MERBRUEsNEVBQUNvQztvREFBSzVKLFdBQVU7OERBQ2JvSyxHQUFHTyxLQUFLOzs7Ozs7Ozs7OzsyQ0FaOERQLEdBQUdPLEtBQUssR0FBR047Ozs7dUVBa0IxRiw4REFBQ0M7d0NBQUd0SyxXQUFVO3dDQUEwRHFJLGVBQVk7a0RBQ2xGLDRFQUFDdUI7NENBQUs1SixXQUFVO3NEQUNkLDRFQUFDNEo7Z0RBQUs1SixXQUFVOzBEQUFvRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQVEzR0Ysa0JBQWtCRCxlQUFlQSxZQUFZd0UsTUFBTSxHQUFHLG1CQUNyRCw4REFBQzBEO29DQUFJL0gsV0FBVTtvQ0FBOENnSixjQUFXOztzREFDdEUsOERBQUM0Qjs0Q0FBRzVLLFdBQVU7c0RBQThFOzs7Ozs7c0RBQzVGLDhEQUFDaUs7NENBQ0NqSyxXQUFVOzRDQUNWa0ssTUFBSztzREFFSnJLLFlBQVlrRSxHQUFHLENBQUMsQ0FBQzhHLEdBQUdoRyxrQkFDbkIsOERBQUN5RjtvREFBcUJ0SyxXQUFVOzhEQUM5Qiw0RUFBQzhLO3dEQUNDUCxNQUFNTSxFQUFFTCxJQUFJO3dEQUNaakQsUUFBTzt3REFDUHdELEtBQUk7d0RBQ0ovSyxXQUFVO2tFQUVUNkssRUFBRUYsS0FBSzs7Ozs7O21EQVBIRSxFQUFFRixLQUFLLEdBQUc5Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWtCakMsOERBQUNtRDtnQkFBTWdELHlCQUF5QjtvQkFBRUMsUUFBUztnQkEyQzFDOzs7Ozs7Ozs7Ozs7QUFHUCxFQUFFO0dBeGlCV3hMO0tBQUFBO0FBMGlCYiwrREFBZUEsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9TdGFnZ2VyZWRNZW51LmpzP2E5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcclxuXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnO1xyXG5pbXBvcnQgeyBnc2FwIH0gZnJvbSAnZ3NhcCc7XHJcblxyXG5leHBvcnQgY29uc3QgU3RhZ2dlcmVkTWVudSA9ICh7XHJcbiAgcG9zaXRpb24gPSAncmlnaHQnLFxyXG4gIGNvbG9ycyA9IFsnIzEwYjk4MScsICcjMzRkMzk5JywgJyMwNTk2NjknXSxcclxuICBpdGVtcyA9IFtdLFxyXG4gIHNvY2lhbEl0ZW1zID0gW10sXHJcbiAgZGlzcGxheVNvY2lhbHMgPSB0cnVlLFxyXG4gIGRpc3BsYXlJdGVtTnVtYmVyaW5nID0gdHJ1ZSxcclxuICBjbGFzc05hbWUsXHJcbiAgbG9nb1VybCA9ICcvc3JjL2Fzc2V0cy9sb2dvcy9yZWFjdGJpdHMtZ2gtd2hpdGUuc3ZnJyxcclxuICBtZW51QnV0dG9uQ29sb3IgPSAnI2ZmZicsXHJcbiAgb3Blbk1lbnVCdXR0b25Db2xvciA9ICcjZmZmJyxcclxuICBjaGFuZ2VNZW51Q29sb3JPbk9wZW4gPSB0cnVlLFxyXG4gIGlzRml4ZWQgPSBmYWxzZSxcclxuICBhY2NlbnRDb2xvciA9ICcjNTIyN0ZGJyxcclxuICBjbG9zZU9uQ2xpY2tBd2F5ID0gdHJ1ZSxcclxuICBjdXN0b21Mb2dvLFxyXG4gIGhlYWRlckNsYXNzTmFtZSA9ICcnLFxyXG4gIG9uTWVudU9wZW4sXHJcbiAgb25NZW51Q2xvc2VcclxufSkgPT4ge1xyXG4gIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBvcGVuUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuXHJcbiAgY29uc3QgcGFuZWxSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgY29uc3QgcHJlTGF5ZXJzUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IHByZUxheWVyRWxzUmVmID0gdXNlUmVmKFtdKTtcclxuXHJcbiAgY29uc3QgcGx1c0hSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgY29uc3QgcGx1c1ZSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgY29uc3QgaWNvblJlZiA9IHVzZVJlZihudWxsKTtcclxuXHJcbiAgY29uc3QgdGV4dElubmVyUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IHRleHRXcmFwUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IFt0ZXh0TGluZXMsIHNldFRleHRMaW5lc10gPSB1c2VTdGF0ZShbJ01lbnUnLCAnQ2xvc2UnXSk7XHJcblxyXG4gIGNvbnN0IG9wZW5UbFJlZiA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCBjbG9zZVR3ZWVuUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IHNwaW5Ud2VlblJlZiA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCB0ZXh0Q3ljbGVBbmltUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IGNvbG9yVHdlZW5SZWYgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZUJ0blJlZiA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCBidXN5UmVmID0gdXNlUmVmKGZhbHNlKTtcclxuXHJcbiAgY29uc3QgaXRlbUVudHJhbmNlVHdlZW5SZWYgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjdHggPSBnc2FwLmNvbnRleHQoKCkgPT4ge1xyXG4gICAgICBjb25zdCBwYW5lbCA9IHBhbmVsUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IHByZUNvbnRhaW5lciA9IHByZUxheWVyc1JlZi5jdXJyZW50O1xyXG5cclxuICAgICAgY29uc3QgcGx1c0ggPSBwbHVzSFJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBwbHVzViA9IHBsdXNWUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGljb24gPSBpY29uUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IHRleHRJbm5lciA9IHRleHRJbm5lclJlZi5jdXJyZW50O1xyXG5cclxuICAgICAgaWYgKCFwYW5lbCB8fCAhcGx1c0ggfHwgIXBsdXNWIHx8ICFpY29uIHx8ICF0ZXh0SW5uZXIpIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBwcmVMYXllcnMgPSBbXTtcclxuICAgICAgaWYgKHByZUNvbnRhaW5lcikge1xyXG4gICAgICAgIHByZUxheWVycyA9IEFycmF5LmZyb20ocHJlQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbS1wcmVsYXllcicpKTtcclxuICAgICAgfVxyXG4gICAgICBwcmVMYXllckVsc1JlZi5jdXJyZW50ID0gcHJlTGF5ZXJzO1xyXG5cclxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC0xMDAgOiAxMDA7XHJcbiAgICAgIGdzYXAuc2V0KFtwYW5lbCwgLi4ucHJlTGF5ZXJzXSwgeyB4UGVyY2VudDogb2Zmc2NyZWVuIH0pO1xyXG5cclxuICAgICAgZ3NhcC5zZXQocGx1c0gsIHsgdHJhbnNmb3JtT3JpZ2luOiAnNTAlIDUwJScsIHJvdGF0ZTogMCB9KTtcclxuICAgICAgZ3NhcC5zZXQocGx1c1YsIHsgdHJhbnNmb3JtT3JpZ2luOiAnNTAlIDUwJScsIHJvdGF0ZTogOTAgfSk7XHJcbiAgICAgIGdzYXAuc2V0KGljb24sIHsgcm90YXRlOiAwLCB0cmFuc2Zvcm1PcmlnaW46ICc1MCUgNTAlJyB9KTtcclxuXHJcbiAgICAgIGdzYXAuc2V0KHRleHRJbm5lciwgeyB5UGVyY2VudDogMCB9KTtcclxuXHJcbiAgICAgIGlmICh0b2dnbGVCdG5SZWYuY3VycmVudCkgZ3NhcC5zZXQodG9nZ2xlQnRuUmVmLmN1cnJlbnQsIHsgY29sb3I6IG1lbnVCdXR0b25Db2xvciB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IGN0eC5yZXZlcnQoKTtcclxuICB9LCBbbWVudUJ1dHRvbkNvbG9yLCBwb3NpdGlvbl0pO1xyXG5cclxuICBjb25zdCBidWlsZE9wZW5UaW1lbGluZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGNvbnN0IHBhbmVsID0gcGFuZWxSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGxheWVycyA9IHByZUxheWVyRWxzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIXBhbmVsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBvcGVuVGxSZWYuY3VycmVudD8ua2lsbCgpO1xyXG4gICAgaWYgKGNsb3NlVHdlZW5SZWYuY3VycmVudCkge1xyXG4gICAgICBjbG9zZVR3ZWVuUmVmLmN1cnJlbnQua2lsbCgpO1xyXG4gICAgICBjbG9zZVR3ZWVuUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXRlbUVudHJhbmNlVHdlZW5SZWYuY3VycmVudD8ua2lsbCgpO1xyXG5cclxuICAgIGNvbnN0IGl0ZW1FbHMgPSBBcnJheS5mcm9tKHBhbmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbS1wYW5lbC1pdGVtTGFiZWwnKSk7XHJcbiAgICBjb25zdCBudW1iZXJFbHMgPSBBcnJheS5mcm9tKHBhbmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbS1wYW5lbC1saXN0W2RhdGEtbnVtYmVyaW5nXSAuc20tcGFuZWwtaXRlbScpKTtcclxuICAgIGNvbnN0IHNvY2lhbFRpdGxlID0gcGFuZWwucXVlcnlTZWxlY3RvcignLnNtLXNvY2lhbHMtdGl0bGUnKTtcclxuICAgIGNvbnN0IHNvY2lhbExpbmtzID0gQXJyYXkuZnJvbShwYW5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuc20tc29jaWFscy1saW5rJykpO1xyXG5cclxuICAgIGNvbnN0IGxheWVyU3RhdGVzID0gbGF5ZXJzLm1hcChlbCA9PiAoeyBlbCwgc3RhcnQ6IE51bWJlcihnc2FwLmdldFByb3BlcnR5KGVsLCAneFBlcmNlbnQnKSkgfSkpO1xyXG4gICAgY29uc3QgcGFuZWxTdGFydCA9IE51bWJlcihnc2FwLmdldFByb3BlcnR5KHBhbmVsLCAneFBlcmNlbnQnKSk7XHJcblxyXG4gICAgaWYgKGl0ZW1FbHMubGVuZ3RoKSBnc2FwLnNldChpdGVtRWxzLCB7IHlQZXJjZW50OiAxNDAsIHJvdGF0ZTogMTAgfSk7XHJcbiAgICBpZiAobnVtYmVyRWxzLmxlbmd0aCkgZ3NhcC5zZXQobnVtYmVyRWxzLCB7IFsnLS1zbS1udW0tb3BhY2l0eSddOiAwIH0pO1xyXG4gICAgaWYgKHNvY2lhbFRpdGxlKSBnc2FwLnNldChzb2NpYWxUaXRsZSwgeyBvcGFjaXR5OiAwIH0pO1xyXG4gICAgaWYgKHNvY2lhbExpbmtzLmxlbmd0aCkgZ3NhcC5zZXQoc29jaWFsTGlua3MsIHsgeTogMjUsIG9wYWNpdHk6IDAgfSk7XHJcblxyXG4gICAgY29uc3QgdGwgPSBnc2FwLnRpbWVsaW5lKHsgcGF1c2VkOiB0cnVlIH0pO1xyXG5cclxuICAgIGxheWVyU3RhdGVzLmZvckVhY2goKGxzLCBpKSA9PiB7XHJcbiAgICAgIHRsLmZyb21Ubyhscy5lbCwgeyB4UGVyY2VudDogbHMuc3RhcnQgfSwgeyB4UGVyY2VudDogMCwgZHVyYXRpb246IDAuNSwgZWFzZTogJ3Bvd2VyNC5vdXQnIH0sIGkgKiAwLjA3KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGxhc3RUaW1lID0gbGF5ZXJTdGF0ZXMubGVuZ3RoID8gKGxheWVyU3RhdGVzLmxlbmd0aCAtIDEpICogMC4wNyA6IDA7XHJcbiAgICBjb25zdCBwYW5lbEluc2VydFRpbWUgPSBsYXN0VGltZSArIChsYXllclN0YXRlcy5sZW5ndGggPyAwLjA4IDogMCk7XHJcbiAgICBjb25zdCBwYW5lbER1cmF0aW9uID0gMC42NTtcclxuXHJcbiAgICB0bC5mcm9tVG8oXHJcbiAgICAgIHBhbmVsLFxyXG4gICAgICB7IHhQZXJjZW50OiBwYW5lbFN0YXJ0IH0sXHJcbiAgICAgIHsgeFBlcmNlbnQ6IDAsIGR1cmF0aW9uOiBwYW5lbER1cmF0aW9uLCBlYXNlOiAncG93ZXI0Lm91dCcgfSxcclxuICAgICAgcGFuZWxJbnNlcnRUaW1lXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChpdGVtRWxzLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBpdGVtc1N0YXJ0UmF0aW8gPSAwLjE1O1xyXG4gICAgICBjb25zdCBpdGVtc1N0YXJ0ID0gcGFuZWxJbnNlcnRUaW1lICsgcGFuZWxEdXJhdGlvbiAqIGl0ZW1zU3RhcnRSYXRpbztcclxuXHJcbiAgICAgIHRsLnRvKFxyXG4gICAgICAgIGl0ZW1FbHMsXHJcbiAgICAgICAgeyB5UGVyY2VudDogMCwgcm90YXRlOiAwLCBkdXJhdGlvbjogMSwgZWFzZTogJ3Bvd2VyNC5vdXQnLCBzdGFnZ2VyOiB7IGVhY2g6IDAuMSwgZnJvbTogJ3N0YXJ0JyB9IH0sXHJcbiAgICAgICAgaXRlbXNTdGFydFxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKG51bWJlckVscy5sZW5ndGgpIHtcclxuICAgICAgICB0bC50byhcclxuICAgICAgICAgIG51bWJlckVscyxcclxuICAgICAgICAgIHsgZHVyYXRpb246IDAuNiwgZWFzZTogJ3Bvd2VyMi5vdXQnLCBbJy0tc20tbnVtLW9wYWNpdHknXTogMSwgc3RhZ2dlcjogeyBlYWNoOiAwLjA4LCBmcm9tOiAnc3RhcnQnIH0gfSxcclxuICAgICAgICAgIGl0ZW1zU3RhcnQgKyAwLjFcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvY2lhbFRpdGxlIHx8IHNvY2lhbExpbmtzLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBzb2NpYWxzU3RhcnQgPSBwYW5lbEluc2VydFRpbWUgKyBwYW5lbER1cmF0aW9uICogMC40O1xyXG5cclxuICAgICAgaWYgKHNvY2lhbFRpdGxlKSB0bC50byhzb2NpYWxUaXRsZSwgeyBvcGFjaXR5OiAxLCBkdXJhdGlvbjogMC41LCBlYXNlOiAncG93ZXIyLm91dCcgfSwgc29jaWFsc1N0YXJ0KTtcclxuICAgICAgaWYgKHNvY2lhbExpbmtzLmxlbmd0aCkge1xyXG4gICAgICAgIHRsLnRvKFxyXG4gICAgICAgICAgc29jaWFsTGlua3MsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjU1LFxyXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIzLm91dCcsXHJcbiAgICAgICAgICAgIHN0YWdnZXI6IHsgZWFjaDogMC4wOCwgZnJvbTogJ3N0YXJ0JyB9LFxyXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiBnc2FwLnNldChzb2NpYWxMaW5rcywgeyBjbGVhclByb3BzOiAnb3BhY2l0eScgfSlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzb2NpYWxzU3RhcnQgKyAwLjA0XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9wZW5UbFJlZi5jdXJyZW50ID0gdGw7XHJcbiAgICByZXR1cm4gdGw7XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBwbGF5T3BlbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChidXN5UmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGJ1c3lSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICBjb25zdCB0bCA9IGJ1aWxkT3BlblRpbWVsaW5lKCk7XHJcbiAgICBpZiAodGwpIHtcclxuICAgICAgdGwuZXZlbnRDYWxsYmFjaygnb25Db21wbGV0ZScsICgpID0+IHtcclxuICAgICAgICBidXN5UmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRsLnBsYXkoMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidXN5UmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9LCBbYnVpbGRPcGVuVGltZWxpbmVdKTtcclxuXHJcbiAgY29uc3QgcGxheUNsb3NlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgb3BlblRsUmVmLmN1cnJlbnQ/LmtpbGwoKTtcclxuICAgIG9wZW5UbFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgIGl0ZW1FbnRyYW5jZVR3ZWVuUmVmLmN1cnJlbnQ/LmtpbGwoKTtcclxuXHJcbiAgICBjb25zdCBwYW5lbCA9IHBhbmVsUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBsYXllcnMgPSBwcmVMYXllckVsc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFwYW5lbCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGFsbCA9IFsuLi5sYXllcnMsIHBhbmVsXTtcclxuICAgIGNsb3NlVHdlZW5SZWYuY3VycmVudD8ua2lsbCgpO1xyXG5cclxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtMTAwIDogMTAwO1xyXG5cclxuICAgIGNsb3NlVHdlZW5SZWYuY3VycmVudCA9IGdzYXAudG8oYWxsLCB7XHJcbiAgICAgIHhQZXJjZW50OiBvZmZzY3JlZW4sXHJcbiAgICAgIGR1cmF0aW9uOiAwLjMyLFxyXG4gICAgICBlYXNlOiAncG93ZXIzLmluJyxcclxuICAgICAgb3ZlcndyaXRlOiAnYXV0bycsXHJcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBpdGVtRWxzID0gQXJyYXkuZnJvbShwYW5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuc20tcGFuZWwtaXRlbUxhYmVsJykpO1xyXG4gICAgICAgIGlmIChpdGVtRWxzLmxlbmd0aCkgZ3NhcC5zZXQoaXRlbUVscywgeyB5UGVyY2VudDogMTQwLCByb3RhdGU6IDEwIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBudW1iZXJFbHMgPSBBcnJheS5mcm9tKHBhbmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbS1wYW5lbC1saXN0W2RhdGEtbnVtYmVyaW5nXSAuc20tcGFuZWwtaXRlbScpKTtcclxuICAgICAgICBpZiAobnVtYmVyRWxzLmxlbmd0aCkgZ3NhcC5zZXQobnVtYmVyRWxzLCB7IFsnLS1zbS1udW0tb3BhY2l0eSddOiAwIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBzb2NpYWxUaXRsZSA9IHBhbmVsLnF1ZXJ5U2VsZWN0b3IoJy5zbS1zb2NpYWxzLXRpdGxlJyk7XHJcbiAgICAgICAgY29uc3Qgc29jaWFsTGlua3MgPSBBcnJheS5mcm9tKHBhbmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbS1zb2NpYWxzLWxpbmsnKSk7XHJcbiAgICAgICAgaWYgKHNvY2lhbFRpdGxlKSBnc2FwLnNldChzb2NpYWxUaXRsZSwgeyBvcGFjaXR5OiAwIH0pO1xyXG4gICAgICAgIGlmIChzb2NpYWxMaW5rcy5sZW5ndGgpIGdzYXAuc2V0KHNvY2lhbExpbmtzLCB7IHk6IDI1LCBvcGFjaXR5OiAwIH0pO1xyXG5cclxuICAgICAgICBidXN5UmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSwgW3Bvc2l0aW9uXSk7XHJcblxyXG4gIGNvbnN0IGFuaW1hdGVJY29uID0gdXNlQ2FsbGJhY2sob3BlbmluZyA9PiB7XHJcbiAgICBjb25zdCBpY29uID0gaWNvblJlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgaCA9IHBsdXNIUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCB2ID0gcGx1c1ZSZWYuY3VycmVudDtcclxuICAgIGlmICghaWNvbiB8fCAhaCB8fCAhdikgcmV0dXJuO1xyXG5cclxuICAgIHNwaW5Ud2VlblJlZi5jdXJyZW50Py5raWxsKCk7XHJcblxyXG4gICAgaWYgKG9wZW5pbmcpIHtcclxuICAgICAgZ3NhcC5zZXQoaWNvbiwgeyByb3RhdGU6IDAsIHRyYW5zZm9ybU9yaWdpbjogJzUwJSA1MCUnIH0pO1xyXG4gICAgICBzcGluVHdlZW5SZWYuY3VycmVudCA9IGdzYXBcclxuICAgICAgICAudGltZWxpbmUoeyBkZWZhdWx0czogeyBlYXNlOiAncG93ZXI0Lm91dCcgfSB9KVxyXG4gICAgICAgIC50byhoLCB7IHJvdGF0ZTogNDUsIGR1cmF0aW9uOiAwLjUgfSwgMClcclxuICAgICAgICAudG8odiwgeyByb3RhdGU6IC00NSwgZHVyYXRpb246IDAuNSB9LCAwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNwaW5Ud2VlblJlZi5jdXJyZW50ID0gZ3NhcFxyXG4gICAgICAgIC50aW1lbGluZSh7IGRlZmF1bHRzOiB7IGVhc2U6ICdwb3dlcjMuaW5PdXQnIH0gfSlcclxuICAgICAgICAudG8oaCwgeyByb3RhdGU6IDAsIGR1cmF0aW9uOiAwLjM1IH0sIDApXHJcbiAgICAgICAgLnRvKHYsIHsgcm90YXRlOiA5MCwgZHVyYXRpb246IDAuMzUgfSwgMClcclxuICAgICAgICAudG8oaWNvbiwgeyByb3RhdGU6IDAsIGR1cmF0aW9uOiAwLjAwMSB9LCAwKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IGFuaW1hdGVDb2xvciA9IHVzZUNhbGxiYWNrKFxyXG4gICAgb3BlbmluZyA9PiB7XHJcbiAgICAgIGNvbnN0IGJ0biA9IHRvZ2dsZUJ0blJlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoIWJ0bikgcmV0dXJuO1xyXG4gICAgICBjb2xvclR3ZWVuUmVmLmN1cnJlbnQ/LmtpbGwoKTtcclxuICAgICAgaWYgKGNoYW5nZU1lbnVDb2xvck9uT3Blbikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENvbG9yID0gb3BlbmluZyA/IG9wZW5NZW51QnV0dG9uQ29sb3IgOiBtZW51QnV0dG9uQ29sb3I7XHJcbiAgICAgICAgY29sb3JUd2VlblJlZi5jdXJyZW50ID0gZ3NhcC50byhidG4sIHsgY29sb3I6IHRhcmdldENvbG9yLCBkZWxheTogMC4xOCwgZHVyYXRpb246IDAuMywgZWFzZTogJ3Bvd2VyMi5vdXQnIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdzYXAuc2V0KGJ0biwgeyBjb2xvcjogbWVudUJ1dHRvbkNvbG9yIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW29wZW5NZW51QnV0dG9uQ29sb3IsIG1lbnVCdXR0b25Db2xvciwgY2hhbmdlTWVudUNvbG9yT25PcGVuXVxyXG4gICk7XHJcblxyXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodG9nZ2xlQnRuUmVmLmN1cnJlbnQpIHtcclxuICAgICAgaWYgKGNoYW5nZU1lbnVDb2xvck9uT3Blbikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENvbG9yID0gb3BlblJlZi5jdXJyZW50ID8gb3Blbk1lbnVCdXR0b25Db2xvciA6IG1lbnVCdXR0b25Db2xvcjtcclxuICAgICAgICBnc2FwLnNldCh0b2dnbGVCdG5SZWYuY3VycmVudCwgeyBjb2xvcjogdGFyZ2V0Q29sb3IgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ3NhcC5zZXQodG9nZ2xlQnRuUmVmLmN1cnJlbnQsIHsgY29sb3I6IG1lbnVCdXR0b25Db2xvciB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtjaGFuZ2VNZW51Q29sb3JPbk9wZW4sIG1lbnVCdXR0b25Db2xvciwgb3Blbk1lbnVCdXR0b25Db2xvcl0pO1xyXG5cclxuICBjb25zdCBhbmltYXRlVGV4dCA9IHVzZUNhbGxiYWNrKG9wZW5pbmcgPT4ge1xyXG4gICAgY29uc3QgaW5uZXIgPSB0ZXh0SW5uZXJSZWYuY3VycmVudDtcclxuICAgIGlmICghaW5uZXIpIHJldHVybjtcclxuXHJcbiAgICB0ZXh0Q3ljbGVBbmltUmVmLmN1cnJlbnQ/LmtpbGwoKTtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50TGFiZWwgPSBvcGVuaW5nID8gJ01lbnUnIDogJ0Nsb3NlJztcclxuICAgIGNvbnN0IHRhcmdldExhYmVsID0gb3BlbmluZyA/ICdDbG9zZScgOiAnTWVudSc7XHJcbiAgICBjb25zdCBjeWNsZXMgPSAzO1xyXG5cclxuICAgIGNvbnN0IHNlcSA9IFtjdXJyZW50TGFiZWxdO1xyXG4gICAgbGV0IGxhc3QgPSBjdXJyZW50TGFiZWw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN5Y2xlczsgaSsrKSB7XHJcbiAgICAgIGxhc3QgPSBsYXN0ID09PSAnTWVudScgPyAnQ2xvc2UnIDogJ01lbnUnO1xyXG4gICAgICBzZXEucHVzaChsYXN0KTtcclxuICAgIH1cclxuICAgIGlmIChsYXN0ICE9PSB0YXJnZXRMYWJlbCkgc2VxLnB1c2godGFyZ2V0TGFiZWwpO1xyXG4gICAgc2VxLnB1c2godGFyZ2V0TGFiZWwpO1xyXG5cclxuICAgIHNldFRleHRMaW5lcyhzZXEpO1xyXG4gICAgZ3NhcC5zZXQoaW5uZXIsIHsgeVBlcmNlbnQ6IDAgfSk7XHJcblxyXG4gICAgY29uc3QgbGluZUNvdW50ID0gc2VxLmxlbmd0aDtcclxuICAgIGNvbnN0IGZpbmFsU2hpZnQgPSAoKGxpbmVDb3VudCAtIDEpIC8gbGluZUNvdW50KSAqIDEwMDtcclxuXHJcbiAgICB0ZXh0Q3ljbGVBbmltUmVmLmN1cnJlbnQgPSBnc2FwLnRvKGlubmVyLCB7XHJcbiAgICAgIHlQZXJjZW50OiAtZmluYWxTaGlmdCxcclxuICAgICAgZHVyYXRpb246IDAuNSArIGxpbmVDb3VudCAqIDAuMDcsXHJcbiAgICAgIGVhc2U6ICdwb3dlcjQub3V0J1xyXG4gICAgfSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCB0b2dnbGVNZW51ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gIW9wZW5SZWYuY3VycmVudDtcclxuICAgIG9wZW5SZWYuY3VycmVudCA9IHRhcmdldDtcclxuICAgIHNldE9wZW4odGFyZ2V0KTtcclxuXHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgIG9uTWVudU9wZW4/LigpO1xyXG4gICAgICBwbGF5T3BlbigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb25NZW51Q2xvc2U/LigpO1xyXG4gICAgICBwbGF5Q2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRlSWNvbih0YXJnZXQpO1xyXG4gICAgYW5pbWF0ZUNvbG9yKHRhcmdldCk7XHJcbiAgICBhbmltYXRlVGV4dCh0YXJnZXQpO1xyXG4gIH0sIFtwbGF5T3BlbiwgcGxheUNsb3NlLCBhbmltYXRlSWNvbiwgYW5pbWF0ZUNvbG9yLCBhbmltYXRlVGV4dCwgb25NZW51T3Blbiwgb25NZW51Q2xvc2VdKTtcclxuXHJcbiAgY29uc3QgY2xvc2VNZW51ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKG9wZW5SZWYuY3VycmVudCkge1xyXG4gICAgICBvcGVuUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgc2V0T3BlbihmYWxzZSk7XHJcbiAgICAgIG9uTWVudUNsb3NlPy4oKTtcclxuICAgICAgcGxheUNsb3NlKCk7XHJcbiAgICAgIGFuaW1hdGVJY29uKGZhbHNlKTtcclxuICAgICAgYW5pbWF0ZUNvbG9yKGZhbHNlKTtcclxuICAgICAgYW5pbWF0ZVRleHQoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sIFtwbGF5Q2xvc2UsIGFuaW1hdGVJY29uLCBhbmltYXRlQ29sb3IsIGFuaW1hdGVUZXh0LCBvbk1lbnVDbG9zZV0pO1xyXG5cclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjbG9zZU9uQ2xpY2tBd2F5IHx8ICFvcGVuKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2tPdXRzaWRlID0gZXZlbnQgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcGFuZWxSZWYuY3VycmVudCAmJlxyXG4gICAgICAgICFwYW5lbFJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiZcclxuICAgICAgICB0b2dnbGVCdG5SZWYuY3VycmVudCAmJlxyXG4gICAgICAgICF0b2dnbGVCdG5SZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNsb3NlTWVudSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xyXG4gICAgfTtcclxuICB9LCBbY2xvc2VPbkNsaWNrQXdheSwgb3BlbiwgY2xvc2VNZW51XSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2XHJcbiAgICAgIGNsYXNzTmFtZT17YHNtLXNjb3BlIHotNDAgJHtpc0ZpeGVkID8gJ2ZpeGVkIHRvcC0wIGxlZnQtMCB3LXNjcmVlbiBoLXNjcmVlbiBvdmVyZmxvdy1oaWRkZW4nIDogJ3ctZnVsbCBoLWZ1bGwnfWB9XHJcbiAgICA+XHJcbiAgICAgIDxkaXZcclxuICAgICAgICBjbGFzc05hbWU9e1xyXG4gICAgICAgICAgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArICdzdGFnZ2VyZWQtbWVudS13cmFwcGVyIHBvaW50ZXItZXZlbnRzLW5vbmUgcmVsYXRpdmUgdy1mdWxsIGgtZnVsbCdcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGU9e2FjY2VudENvbG9yID8geyBbJy0tc20tYWNjZW50J106IGFjY2VudENvbG9yIH0gOiB1bmRlZmluZWR9XHJcbiAgICAgICAgZGF0YS1wb3NpdGlvbj17cG9zaXRpb259XHJcbiAgICAgICAgZGF0YS1vcGVuPXtvcGVuIHx8IHVuZGVmaW5lZH1cclxuICAgICAgPlxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIHJlZj17cHJlTGF5ZXJzUmVmfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwic20tcHJlbGF5ZXJzIGFic29sdXRlIHRvcC0wIHJpZ2h0LTAgYm90dG9tLTAgcG9pbnRlci1ldmVudHMtbm9uZSB6LVs1XVwiXHJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIHsoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYXcgPSBjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCA/IGNvbG9ycy5zbGljZSgwLCA0KSA6IFsnIzFlMWUyMicsICcjMzUzNTNjJ107XHJcbiAgICAgICAgICAgIGxldCBhcnIgPSBbLi4ucmF3XTtcclxuICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPj0gMykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoYXJyLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgICAgICAgIGFyci5zcGxpY2UobWlkLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcCgoYywgaSkgPT4gKFxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGtleT17aX1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNtLXByZWxheWVyIGFic29sdXRlIHRvcC0wIHJpZ2h0LTAgaC1mdWxsIHctZnVsbCB0cmFuc2xhdGUteC0wXCJcclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IGJhY2tncm91bmQ6IGMgfX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICAgIH0pKCl9XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxoZWFkZXJcclxuICAgICAgICAgIGNsYXNzTmFtZT17YHN0YWdnZXJlZC1tZW51LWhlYWRlciBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgdy1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBwLVsyZW1dIGJnLXRyYW5zcGFyZW50IHBvaW50ZXItZXZlbnRzLW5vbmUgei0yMCAke2hlYWRlckNsYXNzTmFtZX1gfVxyXG4gICAgICAgICAgYXJpYS1sYWJlbD1cIk1haW4gbmF2aWdhdGlvbiBoZWFkZXJcIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic20tbG9nbyBmbGV4IGl0ZW1zLWNlbnRlciBzZWxlY3Qtbm9uZSBwb2ludGVyLWV2ZW50cy1hdXRvXCIgYXJpYS1sYWJlbD1cIkxvZ29cIj5cclxuICAgICAgICAgICAge2N1c3RvbUxvZ28gPyAoXHJcbiAgICAgICAgICAgICAgY3VzdG9tTG9nb1xyXG4gICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgIDxpbWdcclxuICAgICAgICAgICAgICAgIHNyYz17bG9nb1VybCB8fCAnL3NyYy9hc3NldHMvbG9nb3MvcmVhY3RiaXRzLWdoLXdoaXRlLnN2Zyd9XHJcbiAgICAgICAgICAgICAgICBhbHQ9XCJMb2dvXCJcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNtLWxvZ28taW1nIGJsb2NrIGgtOCB3LWF1dG8gb2JqZWN0LWNvbnRhaW5cIlxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlPXtmYWxzZX1cclxuICAgICAgICAgICAgICAgIHdpZHRoPXsxMTB9XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezI0fVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgIHJlZj17dG9nZ2xlQnRuUmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJzbS10b2dnbGUgcmVsYXRpdmUgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGdhcC1bMC4zcmVtXSBiZy10cmFuc3BhcmVudCBib3JkZXItMCBjdXJzb3ItcG9pbnRlciB0ZXh0LVsjZTllOWVmXSBmb250LW1lZGl1bSBsZWFkaW5nLW5vbmUgb3ZlcmZsb3ctdmlzaWJsZSBwb2ludGVyLWV2ZW50cy1hdXRvXCJcclxuICAgICAgICAgICAgYXJpYS1sYWJlbD17b3BlbiA/ICdDbG9zZSBtZW51JyA6ICdPcGVuIG1lbnUnfVxyXG4gICAgICAgICAgICBhcmlhLWV4cGFuZGVkPXtvcGVufVxyXG4gICAgICAgICAgICBhcmlhLWNvbnRyb2xzPVwic3RhZ2dlcmVkLW1lbnUtcGFuZWxcIlxyXG4gICAgICAgICAgICBvbkNsaWNrPXt0b2dnbGVNZW51fVxyXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICByZWY9e3RleHRXcmFwUmVmfVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNtLXRvZ2dsZS10ZXh0V3JhcCByZWxhdGl2ZSBpbmxpbmUtYmxvY2sgaC1bMWVtXSBvdmVyZmxvdy1oaWRkZW4gd2hpdGVzcGFjZS1ub3dyYXAgdy1bdmFyKC0tc20tdG9nZ2xlLXdpZHRoLGF1dG8pXSBtaW4tdy1bdmFyKC0tc20tdG9nZ2xlLXdpZHRoLGF1dG8pXVwiXHJcbiAgICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxzcGFuIHJlZj17dGV4dElubmVyUmVmfSBjbGFzc05hbWU9XCJzbS10b2dnbGUtdGV4dElubmVyIGZsZXggZmxleC1jb2wgbGVhZGluZy1ub25lXCI+XHJcbiAgICAgICAgICAgICAgICB7dGV4dExpbmVzLm1hcCgobCwgaSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzbS10b2dnbGUtbGluZSBibG9jayBoLVsxZW1dIGxlYWRpbmctbm9uZVwiIGtleT17aX0+XHJcbiAgICAgICAgICAgICAgICAgICAge2x9XHJcbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG5cclxuICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICByZWY9e2ljb25SZWZ9XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwic20taWNvbiByZWxhdGl2ZSB3LVsxNHB4XSBoLVsxNHB4XSBzaHJpbmstMCBpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgW3dpbGwtY2hhbmdlOnRyYW5zZm9ybV1cIlxyXG4gICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICA8c3BhblxyXG4gICAgICAgICAgICAgICAgcmVmPXtwbHVzSFJlZn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNtLWljb24tbGluZSBhYnNvbHV0ZSBsZWZ0LTEvMiB0b3AtMS8yIHctZnVsbCBoLVsycHhdIGJnLWN1cnJlbnQgcm91bmRlZC1bMnB4XSAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgW3dpbGwtY2hhbmdlOnRyYW5zZm9ybV1cIlxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgIHJlZj17cGx1c1ZSZWZ9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJzbS1pY29uLWxpbmUgc20taWNvbi1saW5lLXYgYWJzb2x1dGUgbGVmdC0xLzIgdG9wLTEvMiB3LWZ1bGwgaC1bMnB4XSBiZy1jdXJyZW50IHJvdW5kZWQtWzJweF0gLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIFt3aWxsLWNoYW5nZTp0cmFuc2Zvcm1dXCJcclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICA8L2hlYWRlcj5cclxuXHJcbiAgICAgICAgPGFzaWRlXHJcbiAgICAgICAgICBpZD1cInN0YWdnZXJlZC1tZW51LXBhbmVsXCJcclxuICAgICAgICAgIHJlZj17cGFuZWxSZWZ9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJzdGFnZ2VyZWQtbWVudS1wYW5lbCBhYnNvbHV0ZSB0b3AtMCByaWdodC0wIGgtZnVsbCBiZy13aGl0ZSBmbGV4IGZsZXgtY29sIHAtWzZlbV8yZW1fMmVtXzJlbV0gb3ZlcmZsb3cteS1hdXRvIHotMTAgYmFja2Ryb3AtYmx1ci1bMTJweF0gcG9pbnRlci1ldmVudHMtYXV0b1wiXHJcbiAgICAgICAgICBzdHlsZT17eyBXZWJraXRCYWNrZHJvcEZpbHRlcjogJ2JsdXIoMTJweCknIH19XHJcbiAgICAgICAgICBhcmlhLWhpZGRlbj17IW9wZW59XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzbS1wYW5lbC1pbm5lciBmbGV4LTEgZmxleCBmbGV4LWNvbCBnYXAtNVwiPlxyXG4gICAgICAgICAgICA8dWxcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJzbS1wYW5lbC1saXN0IGxpc3Qtbm9uZSBtLTAgcC0wIGZsZXggZmxleC1jb2wgZ2FwLTJcIlxyXG4gICAgICAgICAgICAgIHJvbGU9XCJsaXN0XCJcclxuICAgICAgICAgICAgICBkYXRhLW51bWJlcmluZz17ZGlzcGxheUl0ZW1OdW1iZXJpbmcgfHwgdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAge2l0ZW1zICYmIGl0ZW1zLmxlbmd0aCA/IChcclxuICAgICAgICAgICAgICAgIGl0ZW1zLm1hcCgoaXQsIGlkeCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwic20tcGFuZWwtaXRlbVdyYXAgcmVsYXRpdmUgb3ZlcmZsb3ctaGlkZGVuIGxlYWRpbmctbm9uZVwiIGtleT17aXQubGFiZWwgKyBpZHh9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxMaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJzbS1wYW5lbC1pdGVtIHJlbGF0aXZlIHRleHQtYmxhY2sgZm9udC1zZW1pYm9sZCB0ZXh0LVs0cmVtXSBjdXJzb3ItcG9pbnRlciBsZWFkaW5nLW5vbmUgdHJhY2tpbmctWy0ycHhdIHVwcGVyY2FzZSB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLGNvbG9yXSBkdXJhdGlvbi0xNTAgZWFzZS1saW5lYXIgaW5saW5lLWJsb2NrIG5vLXVuZGVybGluZSBwci1bMS40ZW1dXCJcclxuICAgICAgICAgICAgICAgICAgICAgIGhyZWY9e2l0Lmxpbmt9XHJcbiAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtpdC5hcmlhTGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLWluZGV4PXtpZHggKyAxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBtZW51IHdoZW4gYSBsaW5rIGlzIGNsaWNrZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlT25DbGlja0F3YXkpIGNsb3NlTWVudSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzbS1wYW5lbC1pdGVtTGFiZWwgaW5saW5lLWJsb2NrIFt0cmFuc2Zvcm0tb3JpZ2luOjUwJV8xMDAlXSB3aWxsLWNoYW5nZS10cmFuc2Zvcm1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2l0LmxhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICkpXHJcbiAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJzbS1wYW5lbC1pdGVtV3JhcCByZWxhdGl2ZSBvdmVyZmxvdy1oaWRkZW4gbGVhZGluZy1ub25lXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNtLXBhbmVsLWl0ZW0gcmVsYXRpdmUgdGV4dC1ibGFjayBmb250LXNlbWlib2xkIHRleHQtWzRyZW1dIGN1cnNvci1wb2ludGVyIGxlYWRpbmctbm9uZSB0cmFja2luZy1bLTJweF0gdXBwZXJjYXNlIHRyYW5zaXRpb24tW2JhY2tncm91bmQsY29sb3JdIGR1cmF0aW9uLTE1MCBlYXNlLWxpbmVhciBpbmxpbmUtYmxvY2sgbm8tdW5kZXJsaW5lIHByLVsxLjRlbV1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzbS1wYW5lbC1pdGVtTGFiZWwgaW5saW5lLWJsb2NrIFt0cmFuc2Zvcm0tb3JpZ2luOjUwJV8xMDAlXSB3aWxsLWNoYW5nZS10cmFuc2Zvcm1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgIE5vIGl0ZW1zXHJcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDwvdWw+XHJcblxyXG4gICAgICAgICAgICB7ZGlzcGxheVNvY2lhbHMgJiYgc29jaWFsSXRlbXMgJiYgc29jaWFsSXRlbXMubGVuZ3RoID4gMCAmJiAoXHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzbS1zb2NpYWxzIG10LWF1dG8gcHQtOCBmbGV4IGZsZXgtY29sIGdhcC0zXCIgYXJpYS1sYWJlbD1cIlNvY2lhbCBsaW5rc1wiPlxyXG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInNtLXNvY2lhbHMtdGl0bGUgbS0wIHRleHQtYmFzZSBmb250LW1lZGl1bSBbY29sb3I6dmFyKC0tc20tYWNjZW50LCNmZjAwMDApXVwiPlNvY2lhbHM8L2gzPlxyXG4gICAgICAgICAgICAgICAgPHVsXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNtLXNvY2lhbHMtbGlzdCBsaXN0LW5vbmUgbS0wIHAtMCBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBnYXAtNCBmbGV4LXdyYXBcIlxyXG4gICAgICAgICAgICAgICAgICByb2xlPVwibGlzdFwiXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIHtzb2NpYWxJdGVtcy5tYXAoKHMsIGkpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtzLmxhYmVsICsgaX0gY2xhc3NOYW1lPVwic20tc29jaWFscy1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmPXtzLmxpbmt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJzbS1zb2NpYWxzLWxpbmsgdGV4dC1bMS4ycmVtXSBmb250LW1lZGl1bSB0ZXh0LVsjMTExXSBuby11bmRlcmxpbmUgcmVsYXRpdmUgaW5saW5lLWJsb2NrIHB5LVsycHhdIHRyYW5zaXRpb24tW2NvbG9yLG9wYWNpdHldIGR1cmF0aW9uLTMwMCBlYXNlLWxpbmVhclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzLmxhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvYXNpZGU+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPHN0eWxlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogYFxyXG4uc20tc2NvcGUgLnN0YWdnZXJlZC1tZW51LXdyYXBwZXIgeyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDQwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxyXG4uc20tc2NvcGUgLnN0YWdnZXJlZC1tZW51LWhlYWRlciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOyBwYWRkaW5nOiAyZW07IGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogMjA7IH1cclxuLnNtLXNjb3BlIC5zdGFnZ2VyZWQtbWVudS1oZWFkZXIgPiAqIHsgcG9pbnRlci1ldmVudHM6IGF1dG87IH1cclxuLnNtLXNjb3BlIC5zbS1sb2dvIHsgZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgdXNlci1zZWxlY3Q6IG5vbmU7IH1cclxuLnNtLXNjb3BlIC5zbS1sb2dvLWltZyB7IGRpc3BsYXk6IGJsb2NrOyBoZWlnaHQ6IDMycHg7IHdpZHRoOiBhdXRvOyBvYmplY3QtZml0OiBjb250YWluOyB9XHJcbi5zbS1zY29wZSAuc20tdG9nZ2xlIHsgcG9zaXRpb246IHJlbGF0aXZlOyBkaXNwbGF5OiBpbmxpbmUtZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgZ2FwOiAwLjNyZW07IGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyBib3JkZXI6IG5vbmU7IGN1cnNvcjogcG9pbnRlcjsgY29sb3I6ICNlOWU5ZWY7IGZvbnQtd2VpZ2h0OiA1MDA7IGxpbmUtaGVpZ2h0OiAxOyBvdmVyZmxvdzogdmlzaWJsZTsgfVxyXG4uc20tc2NvcGUgLnNtLXRvZ2dsZTpmb2N1cy12aXNpYmxlIHsgb3V0bGluZTogMnB4IHNvbGlkICNmZmZmZmZhYTsgb3V0bGluZS1vZmZzZXQ6IDRweDsgYm9yZGVyLXJhZGl1czogNHB4OyB9XHJcbi5zbS1zY29wZSAuc20tbGluZTpsYXN0LW9mLXR5cGUgeyBtYXJnaW4tdG9wOiA2cHg7IH1cclxuLnNtLXNjb3BlIC5zbS10b2dnbGUtdGV4dFdyYXAgeyBwb3NpdGlvbjogcmVsYXRpdmU7IG1hcmdpbi1yaWdodDogMC41ZW07IGRpc3BsYXk6IGlubGluZS1ibG9jazsgaGVpZ2h0OiAxZW07IG92ZXJmbG93OiBoaWRkZW47IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdpZHRoOiB2YXIoLS1zbS10b2dnbGUtd2lkdGgsIGF1dG8pOyBtaW4td2lkdGg6IHZhcigtLXNtLXRvZ2dsZS13aWR0aCwgYXV0byk7IH1cclxuLnNtLXNjb3BlIC5zbS10b2dnbGUtdGV4dElubmVyIHsgZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgbGluZS1oZWlnaHQ6IDE7IH1cclxuLnNtLXNjb3BlIC5zbS10b2dnbGUtbGluZSB7IGRpc3BsYXk6IGJsb2NrOyBoZWlnaHQ6IDFlbTsgbGluZS1oZWlnaHQ6IDE7IH1cclxuLnNtLXNjb3BlIC5zbS1pY29uIHsgcG9zaXRpb246IHJlbGF0aXZlOyB3aWR0aDogMTRweDsgaGVpZ2h0OiAxNHB4OyBmbGV4OiAwIDAgMTRweDsgZGlzcGxheTogaW5saW5lLWZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyOyB3aWxsLWNoYW5nZTogdHJhbnNmb3JtOyB9XHJcbi5zbS1zY29wZSAuc20tcGFuZWwtaXRlbVdyYXAgeyBwb3NpdGlvbjogcmVsYXRpdmU7IG92ZXJmbG93OiBoaWRkZW47IGxpbmUtaGVpZ2h0OiAxOyB9XHJcbi5zbS1zY29wZSAuc20taWNvbi1saW5lIHsgcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiA1MCU7IHRvcDogNTAlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAycHg7IGJhY2tncm91bmQ6IGN1cnJlbnRDb2xvcjsgYm9yZGVyLXJhZGl1czogMnB4OyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTsgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTsgfVxyXG4uc20tc2NvcGUgLnNtLWxpbmUgeyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH1cclxuLnNtLXNjb3BlIC5zdGFnZ2VyZWQtbWVudS1wYW5lbCB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyByaWdodDogMDsgd2lkdGg6IGNsYW1wKDI2MHB4LCAzOHZ3LCA0MjBweCk7IGhlaWdodDogMTAwJTsgYmFja2dyb3VuZDogd2hpdGU7IGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMnB4KTsgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoMTJweCk7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHBhZGRpbmc6IDZlbSAyZW0gMmVtIDJlbTsgb3ZlcmZsb3cteTogYXV0bzsgei1pbmRleDogMTA7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMDAlKTsgfVxyXG4uc20tc2NvcGUgW2RhdGEtcG9zaXRpb249J2xlZnQnXSAuc3RhZ2dlcmVkLW1lbnUtcGFuZWwgeyByaWdodDogYXV0bzsgbGVmdDogMDsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMDAlKTsgfVxyXG4uc20tc2NvcGUgLnNtLXByZWxheWVycyB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyB3aWR0aDogY2xhbXAoMjYwcHgsIDM4dncsIDQyMHB4KTsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IDU7IH1cclxuLnNtLXNjb3BlIFtkYXRhLXBvc2l0aW9uPSdsZWZ0J10gLnNtLXByZWxheWVycyB7IHJpZ2h0OiBhdXRvOyBsZWZ0OiAwOyB9XHJcbi5zbS1zY29wZSBbZGF0YS1wb3NpdGlvbj0nbGVmdCddIC5zbS1wcmVsYXllciB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAwJSk7IH1cclxuLnNtLXNjb3BlIC5zbS1wcmVsYXllciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyByaWdodDogMDsgaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJTsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwMCUpOyB9XHJcbi5zbS1zY29wZSAuc20tcGFuZWwtaW5uZXIgeyBmbGV4OiAxOyBkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyBnYXA6IDEuMjVyZW07IH1cclxuLnNtLXNjb3BlIC5zbS1zb2NpYWxzIHsgbWFyZ2luLXRvcDogYXV0bzsgcGFkZGluZy10b3A6IDJyZW07IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IGdhcDogMC43NXJlbTsgfVxyXG4uc20tc2NvcGUgLnNtLXNvY2lhbHMtdGl0bGUgeyBtYXJnaW46IDA7IGZvbnQtc2l6ZTogMXJlbTsgZm9udC13ZWlnaHQ6IDUwMDsgY29sb3I6IHZhcigtLXNtLWFjY2VudCwgI2ZmMDAwMCk7IH1cclxuLnNtLXNjb3BlIC5zbS1zb2NpYWxzLWxpc3QgeyBsaXN0LXN0eWxlOiBub25lOyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiByb3c7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGdhcDogMXJlbTsgZmxleC13cmFwOiB3cmFwOyB9XHJcbi5zbS1zY29wZSAuc20tc29jaWFscy1saXN0IC5zbS1zb2NpYWxzLWxpbmsgeyBvcGFjaXR5OiAxOyB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZTsgfVxyXG4uc20tc2NvcGUgLnNtLXNvY2lhbHMtbGlzdDpob3ZlciAuc20tc29jaWFscy1saW5rOm5vdCg6aG92ZXIpIHsgb3BhY2l0eTogMC4zNTsgfVxyXG4uc20tc2NvcGUgLnNtLXNvY2lhbHMtbGlzdDpmb2N1cy13aXRoaW4gLnNtLXNvY2lhbHMtbGluazpub3QoOmZvY3VzLXZpc2libGUpIHsgb3BhY2l0eTogMC4zNTsgfVxyXG4uc20tc2NvcGUgLnNtLXNvY2lhbHMtbGlzdCAuc20tc29jaWFscy1saW5rOmhvdmVyLFxyXG4uc20tc2NvcGUgLnNtLXNvY2lhbHMtbGlzdCAuc20tc29jaWFscy1saW5rOmZvY3VzLXZpc2libGUgeyBvcGFjaXR5OiAxOyB9XHJcbi5zbS1zY29wZSAuc20tc29jaWFscy1saW5rOmZvY3VzLXZpc2libGUgeyBvdXRsaW5lOiAycHggc29saWQgdmFyKC0tc20tYWNjZW50LCAjZmYwMDAwKTsgb3V0bGluZS1vZmZzZXQ6IDNweDsgfVxyXG4uc20tc2NvcGUgLnNtLXNvY2lhbHMtbGluayB7IGZvbnQtc2l6ZTogMS4ycmVtOyBmb250LXdlaWdodDogNTAwOyBjb2xvcjogIzExMTsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyBwb3NpdGlvbjogcmVsYXRpdmU7IHBhZGRpbmc6IDJweCAwOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHRyYW5zaXRpb246IGNvbG9yIDAuM3MgZWFzZSwgb3BhY2l0eSAwLjNzIGVhc2U7IH1cclxuLnNtLXNjb3BlIC5zbS1zb2NpYWxzLWxpbms6aG92ZXIgeyBjb2xvcjogdmFyKC0tc20tYWNjZW50LCAjZmYwMDAwKTsgfVxyXG4uc20tc2NvcGUgLnNtLXBhbmVsLXRpdGxlIHsgbWFyZ2luOiAwOyBmb250LXNpemU6IDFyZW07IGZvbnQtd2VpZ2h0OiA2MDA7IGNvbG9yOiAjZmZmOyB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOyB9XHJcbi5zbS1zY29wZSAuc20tcGFuZWwtbGlzdCB7IGxpc3Qtc3R5bGU6IG5vbmU7IG1hcmdpbjogMDsgcGFkZGluZzogMDsgZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgZ2FwOiAwLjVyZW07IH1cclxuLnNtLXNjb3BlIC5zbS1wYW5lbC1pdGVtIHsgcG9zaXRpb246IHJlbGF0aXZlOyBjb2xvcjogIzAwMDsgZm9udC13ZWlnaHQ6IDYwMDsgZm9udC1zaXplOiA0cmVtOyBjdXJzb3I6IHBvaW50ZXI7IGxpbmUtaGVpZ2h0OiAxOyBsZXR0ZXItc3BhY2luZzogLTJweDsgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjI1cywgY29sb3IgMC4yNXM7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyBwYWRkaW5nLXJpZ2h0OiAxLjRlbTsgfVxyXG4uc20tc2NvcGUgLnNtLXBhbmVsLWl0ZW1MYWJlbCB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTsgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7IH1cclxuLnNtLXNjb3BlIC5zbS1wYW5lbC1pdGVtOmhvdmVyIHsgY29sb3I6IHZhcigtLXNtLWFjY2VudCwgI2ZmMDAwMCk7IH1cclxuLnNtLXNjb3BlIC5zbS1wYW5lbC1saXN0W2RhdGEtbnVtYmVyaW5nXSB7IGNvdW50ZXItcmVzZXQ6IHNtSXRlbTsgfVxyXG4uc20tc2NvcGUgLnNtLXBhbmVsLWxpc3RbZGF0YS1udW1iZXJpbmddIC5zbS1wYW5lbC1pdGVtOjphZnRlciB7IGNvdW50ZXItaW5jcmVtZW50OiBzbUl0ZW07IGNvbnRlbnQ6IGNvdW50ZXIoc21JdGVtLCBkZWNpbWFsLWxlYWRpbmctemVybyk7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwLjFlbTsgcmlnaHQ6IDMuMmVtOyBmb250LXNpemU6IDE4cHg7IGZvbnQtd2VpZ2h0OiA0MDA7IGNvbG9yOiB2YXIoLS1zbS1hY2NlbnQsICNmZjAwMDApOyBsZXR0ZXItc3BhY2luZzogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHVzZXItc2VsZWN0OiBub25lOyBvcGFjaXR5OiB2YXIoLS1zbS1udW0tb3BhY2l0eSwgMCk7IH1cclxuQG1lZGlhIChtYXgtd2lkdGg6IDEwMjRweCkgeyAuc20tc2NvcGUgLnN0YWdnZXJlZC1tZW51LXBhbmVsIHsgd2lkdGg6IDEwMCU7IGxlZnQ6IDA7IHJpZ2h0OiAwOyB9IC5zbS1zY29wZSAuc3RhZ2dlcmVkLW1lbnUtd3JhcHBlcltkYXRhLW9wZW5dIC5zbS1sb2dvLWltZyB7IGZpbHRlcjogaW52ZXJ0KDEwMCUpOyB9IH1cclxuQG1lZGlhIChtYXgtd2lkdGg6IDY0MHB4KSB7IC5zbS1zY29wZSAuc3RhZ2dlcmVkLW1lbnUtcGFuZWwgeyB3aWR0aDogMTAwJTsgbGVmdDogMDsgcmlnaHQ6IDA7IH0gLnNtLXNjb3BlIC5zdGFnZ2VyZWQtbWVudS13cmFwcGVyW2RhdGEtb3Blbl0gLnNtLWxvZ28taW1nIHsgZmlsdGVyOiBpbnZlcnQoMTAwJSk7IH0gfVxyXG4gICAgICBgfX0gLz5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdGFnZ2VyZWRNZW51O1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiTGluayIsImdzYXAiLCJTdGFnZ2VyZWRNZW51IiwicG9zaXRpb24iLCJjb2xvcnMiLCJpdGVtcyIsInNvY2lhbEl0ZW1zIiwiZGlzcGxheVNvY2lhbHMiLCJkaXNwbGF5SXRlbU51bWJlcmluZyIsImNsYXNzTmFtZSIsImxvZ29VcmwiLCJtZW51QnV0dG9uQ29sb3IiLCJvcGVuTWVudUJ1dHRvbkNvbG9yIiwiY2hhbmdlTWVudUNvbG9yT25PcGVuIiwiaXNGaXhlZCIsImFjY2VudENvbG9yIiwiY2xvc2VPbkNsaWNrQXdheSIsImN1c3RvbUxvZ28iLCJoZWFkZXJDbGFzc05hbWUiLCJvbk1lbnVPcGVuIiwib25NZW51Q2xvc2UiLCJvcGVuIiwic2V0T3BlbiIsIm9wZW5SZWYiLCJwYW5lbFJlZiIsInByZUxheWVyc1JlZiIsInByZUxheWVyRWxzUmVmIiwicGx1c0hSZWYiLCJwbHVzVlJlZiIsImljb25SZWYiLCJ0ZXh0SW5uZXJSZWYiLCJ0ZXh0V3JhcFJlZiIsInRleHRMaW5lcyIsInNldFRleHRMaW5lcyIsIm9wZW5UbFJlZiIsImNsb3NlVHdlZW5SZWYiLCJzcGluVHdlZW5SZWYiLCJ0ZXh0Q3ljbGVBbmltUmVmIiwiY29sb3JUd2VlblJlZiIsInRvZ2dsZUJ0blJlZiIsImJ1c3lSZWYiLCJpdGVtRW50cmFuY2VUd2VlblJlZiIsImN0eCIsImNvbnRleHQiLCJwYW5lbCIsImN1cnJlbnQiLCJwcmVDb250YWluZXIiLCJwbHVzSCIsInBsdXNWIiwiaWNvbiIsInRleHRJbm5lciIsInByZUxheWVycyIsIkFycmF5IiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvZmZzY3JlZW4iLCJzZXQiLCJ4UGVyY2VudCIsInRyYW5zZm9ybU9yaWdpbiIsInJvdGF0ZSIsInlQZXJjZW50IiwiY29sb3IiLCJyZXZlcnQiLCJidWlsZE9wZW5UaW1lbGluZSIsImxheWVycyIsImtpbGwiLCJpdGVtRWxzIiwibnVtYmVyRWxzIiwic29jaWFsVGl0bGUiLCJxdWVyeVNlbGVjdG9yIiwic29jaWFsTGlua3MiLCJsYXllclN0YXRlcyIsIm1hcCIsImVsIiwic3RhcnQiLCJOdW1iZXIiLCJnZXRQcm9wZXJ0eSIsInBhbmVsU3RhcnQiLCJsZW5ndGgiLCJvcGFjaXR5IiwieSIsInRsIiwidGltZWxpbmUiLCJwYXVzZWQiLCJmb3JFYWNoIiwibHMiLCJpIiwiZnJvbVRvIiwiZHVyYXRpb24iLCJlYXNlIiwibGFzdFRpbWUiLCJwYW5lbEluc2VydFRpbWUiLCJwYW5lbER1cmF0aW9uIiwiaXRlbXNTdGFydFJhdGlvIiwiaXRlbXNTdGFydCIsInRvIiwic3RhZ2dlciIsImVhY2giLCJzb2NpYWxzU3RhcnQiLCJvbkNvbXBsZXRlIiwiY2xlYXJQcm9wcyIsInBsYXlPcGVuIiwiZXZlbnRDYWxsYmFjayIsInBsYXkiLCJwbGF5Q2xvc2UiLCJhbGwiLCJvdmVyd3JpdGUiLCJhbmltYXRlSWNvbiIsIm9wZW5pbmciLCJoIiwidiIsImRlZmF1bHRzIiwiYW5pbWF0ZUNvbG9yIiwiYnRuIiwidGFyZ2V0Q29sb3IiLCJkZWxheSIsInVzZUVmZmVjdCIsImFuaW1hdGVUZXh0IiwiaW5uZXIiLCJjdXJyZW50TGFiZWwiLCJ0YXJnZXRMYWJlbCIsImN5Y2xlcyIsInNlcSIsImxhc3QiLCJwdXNoIiwibGluZUNvdW50IiwiZmluYWxTaGlmdCIsInRvZ2dsZU1lbnUiLCJ0YXJnZXQiLCJjbG9zZU1lbnUiLCJoYW5kbGVDbGlja091dHNpZGUiLCJldmVudCIsImNvbnRhaW5zIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpdiIsInN0eWxlIiwidW5kZWZpbmVkIiwiZGF0YS1wb3NpdGlvbiIsImRhdGEtb3BlbiIsInJlZiIsImFyaWEtaGlkZGVuIiwicmF3Iiwic2xpY2UiLCJhcnIiLCJtaWQiLCJNYXRoIiwiZmxvb3IiLCJzcGxpY2UiLCJjIiwiYmFja2dyb3VuZCIsImhlYWRlciIsImFyaWEtbGFiZWwiLCJpbWciLCJzcmMiLCJhbHQiLCJkcmFnZ2FibGUiLCJ3aWR0aCIsImhlaWdodCIsImJ1dHRvbiIsImFyaWEtZXhwYW5kZWQiLCJhcmlhLWNvbnRyb2xzIiwib25DbGljayIsInR5cGUiLCJzcGFuIiwibCIsImFzaWRlIiwiaWQiLCJXZWJraXRCYWNrZHJvcEZpbHRlciIsInVsIiwicm9sZSIsImRhdGEtbnVtYmVyaW5nIiwiaXQiLCJpZHgiLCJsaSIsImhyZWYiLCJsaW5rIiwiYXJpYUxhYmVsIiwiZGF0YS1pbmRleCIsImxhYmVsIiwiaDMiLCJzIiwiYSIsInJlbCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/StaggeredMenu.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDZDQUE0QztJQUN4Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDBCQUEwQkMsbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1GLFlBQVksU0FBU0csSUFBSTtJQUMzQixJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87UUFDdEdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztJQUNwQztJQUNBLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPUDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9QLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU87SUFBSztJQUNuRUgsT0FBT3NCLE1BQU0sQ0FBQ3BCLFFBQVFrQixPQUFPLEVBQUVsQjtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanM/ZTJkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBhZGRMb2NhbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlXCIpLmFkZExvY2FsZShwYXRoLCAuLi5hcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYWRkTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwicGF0aCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywwQkFBMEJDLG1CQUFPQSxDQUFDLG1IQUE0QjtBQUNwRSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLGdCQUFnQk8sSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsYUFBYTtJQUN6RCxJQUFJTixLQUErQixFQUFFLEVBV3BDLE1BQU07UUFDSCxPQUFPO0lBQ1g7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPUixRQUFRMkIsT0FBTyxLQUFLLGNBQWUsT0FBTzNCLFFBQVEyQixPQUFPLEtBQUssWUFBWTNCLFFBQVEyQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQixRQUFRMkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJCLE9BQU8sRUFBRSxjQUFjO1FBQUUxQixPQUFPO0lBQUs7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRMkIsT0FBTyxFQUFFM0I7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRMkIsT0FBTztBQUNsQyxFQUVBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz81YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9tYWluTG9jYWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREb21haW5Mb2NhbGU7XG4gICAgfVxufSk7XG5jb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIikubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIikuZGV0ZWN0RG9tYWluTG9jYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcm90byArIGRvbWFpbi5kb21haW4gKyAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKFwiXCIgKyBiYXNlUGF0aCArIGZpbmFsTG9jYWxlICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXREb21haW5Mb2NhbGUiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMscUdBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsbUZBQU87QUFDdkUsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsMkZBQWdCO0FBQzdDLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyxpSUFBdUM7QUFDbEUsTUFBTU8sU0FBU1AsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLHVGQUFjO0FBQ3pDLE1BQU1TLDhCQUE4QlQsbUJBQU9BLENBQUMsNklBQTZDO0FBQ3pGLE1BQU1VLGlDQUFpQ1YsbUJBQU9BLENBQUMscUpBQWlEO0FBQ2hHLE1BQU1XLG1CQUFtQlgsbUJBQU9BLENBQUMsbUdBQW9CO0FBQ3JELE1BQU1ZLG1CQUFtQlosbUJBQU9BLENBQUMscUdBQXFCO0FBQ3RELE1BQU1hLGVBQWViLG1CQUFPQSxDQUFDLDZGQUFpQjtBQUM5QyxNQUFNYyxzQkFBc0JkLG1CQUFPQSxDQUFDLCtKQUFrRDtBQUN0RixNQUFNZSxhQUFhLElBQUlDO0FBQ3ZCLFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ2hFLElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUNELGdK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LE9BQU8sRUFBRSxjQUFjO1FBQUVqRSxPQUFPO0lBQUs7SUFDbkVILE9BQU9vSyxNQUFNLENBQUNsSyxRQUFRa0UsT0FBTyxFQUFFbEU7SUFDL0JtSyxPQUFPbkssT0FBTyxHQUFHQSxRQUFRa0UsT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi9yZXNvbHZlLWhyZWZcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmNvbnN0IF9hZGRsb2NhbGUgPSByZXF1aXJlKFwiLi9hZGQtbG9jYWxlXCIpO1xuY29uc3QgX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfdXNlaW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmNvbnN0IF9nZXRkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi9nZXQtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcbmNvbnN0IHByZWZldGNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCBvcHRpb25zLCBhcHBPcHRpb25zLCBpc0FwcFJvdXRlcikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgaWYgKCFpc0FwcFJvdXRlciAmJiAhKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGhyZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgZGVkdXBlIHJlcXVlc3RzIHdoZW4gZXhwZXJpbWVudGFsLm9wdGltaXN0aWNDbGllbnRDYWNoZSBpc1xuICAgIC8vIGRpc2FibGVkLlxuICAgIGlmICghb3B0aW9ucy5ieXBhc3NQcmVmZXRjaGVkQ2hlY2spIHtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gLy8gTGV0IHRoZSBsaW5rJ3MgbG9jYWxlIHByb3Agb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcm91dGVyIGxvY2FsZS5cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgOiBcImxvY2FsZVwiIGluIHJvdXRlciA/IHJvdXRlci5sb2NhbGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHByZWZldGNoZWRLZXkgPSBocmVmICsgXCIlXCIgKyBhcyArIFwiJVwiICsgbG9jYWxlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZldGNoZWQgdGhlIGtleSwgdGhlbiBkb24ndCBwcmVmZXRjaCBpdCBhZ2FpbiFcbiAgICAgICAgaWYgKHByZWZldGNoZWQuaGFzKHByZWZldGNoZWRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayB0aGlzIFVSTCBhcyBwcmVmZXRjaGVkLlxuICAgICAgICBwcmVmZXRjaGVkLmFkZChwcmVmZXRjaGVkS2V5KTtcbiAgICB9XG4gICAgY29uc3QgcHJlZmV0Y2hQcm9taXNlID0gaXNBcHBSb3V0ZXIgPyByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXBwT3B0aW9ucykgOiByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpO1xuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gICAgUHJvbWlzZS5yZXNvbHZlKHByZWZldGNoUHJvbWlzZSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSBcIl9zZWxmXCIgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyO1xufVxuZnVuY3Rpb24gbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG4gICAgY29uc3QgaXNBbmNob3JOb2RlTmFtZSA9IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiQVwiO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XG4gICAgICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuICAgICAgICBjb25zdCByb3V0ZXJTY3JvbGwgPSBzY3JvbGwgIT0gbnVsbCA/IHNjcm9sbCA6IHRydWU7XG4gICAgICAgIGlmIChcImJlZm9yZVBvcFN0YXRlXCIgaW4gcm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCJdKGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiXShhcyB8fCBocmVmLCB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRVcmwpKHVybE9iak9yU3RyaW5nKTtcbn1cbi8qKlxuICogUmVhY3QgQ29tcG9uZW50IHRoYXQgZW5hYmxlcyBjbGllbnQtc2lkZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHJvdXRlcy5cbiAqLyBjb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBjb25zdCB7IGhyZWY6IGhyZWZQcm9wLCBhczogYXNQcm9wLCBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wLCBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wID0gbnVsbCwgcGFzc0hyZWYsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlclByb3AsIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0UHJvcCwgbGVnYWN5QmVoYXZpb3IgPSBmYWxzZSwgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImFcIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IGFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkFwcFJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IHJvdXRlciA9IHBhZ2VzUm91dGVyICE9IG51bGwgPyBwYWdlc1JvdXRlciA6IGFwcFJvdXRlcjtcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXI7XG4gICAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zc2libGUgc3RhdGVzIGZvciBwcmVmZXRjaCBhcmU6XG4gICAgICogLSBudWxsOiB0aGlzIGlzIHRoZSBkZWZhdWx0IFwiYXV0b1wiIG1vZGUsIHdoZXJlIHdlIHdpbGwgcHJlZmV0Y2ggcGFydGlhbGx5IGlmIHRoZSBsaW5rIGlzIGluIHRoZSB2aWV3cG9ydFxuICAgICAqIC0gdHJ1ZTogd2Ugd2lsbCBwcmVmZXRjaCBpZiB0aGUgbGluayBpcyB2aXNpYmxlIGFuZCBwcmVmZXRjaCB0aGUgZnVsbCBwYWdlLCBub3QganVzdCBwYXJ0aWFsbHlcbiAgICAgKiAtIGZhbHNlOiB3ZSB3aWxsIG5vdCBwcmVmZXRjaCBpZiBpbiB0aGUgdmlld3BvcnQgYXQgYWxsXG4gICAgICovIGNvbnN0IGFwcFByZWZldGNoS2luZCA9IHByZWZldGNoUHJvcCA9PT0gbnVsbCA/IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE8gOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBgXCIgKyBhcmdzLmtleSArIFwiYCBleHBlY3RzIGEgXCIgKyBhcmdzLmV4cGVjdGVkICsgXCIgaW4gYDxMaW5rPmAsIGJ1dCBnb3QgYFwiICsgYXJncy5hY3R1YWwgKyBcImAgaW5zdGVhZC5cIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJocmVmXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wc1trZXldICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYCBvciBgb2JqZWN0YFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgcHJvcHNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBhczogdHJ1ZSxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICAgICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRydWUsXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICBsZWdhY3lCZWhhdmlvcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzID0gT2JqZWN0LmtleXMob3B0aW9uYWxQcm9wc0d1YXJkKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImFzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcInN0cmluZ1wiICYmIHZhbFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgIG9yIGBvYmplY3RgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwibG9jYWxlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm9uQ2xpY2tcIiB8fCBrZXkgPT09IFwib25Nb3VzZUVudGVyXCIgfHwga2V5ID09PSBcIm9uVG91Y2hTdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgZnVuY3Rpb25gXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwicmVwbGFjZVwiIHx8IGtleSA9PT0gXCJzY3JvbGxcIiB8fCBrZXkgPT09IFwic2hhbGxvd1wiIHx8IGtleSA9PT0gXCJwYXNzSHJlZlwiIHx8IGtleSA9PT0gXCJwcmVmZXRjaFwiIHx8IGtleSA9PT0gXCJsZWdhY3lCZWhhdmlvclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYGJvb2xlYW5gXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IGhhc1dhcm5lZCA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQgJiYgIWlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChpc0FwcFJvdXRlciAmJiAhYXNQcm9wKSB7XG4gICAgICAgICAgICBsZXQgaHJlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHJlZlByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgaHJlZlByb3AucGF0aG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNTZWdtZW50ID0gaHJlZi5zcGxpdChcIi9cIikuc29tZSgoc2VnbWVudCk9PnNlZ21lbnQuc3RhcnRzV2l0aChcIltcIikgJiYgc2VnbWVudC5lbmRzV2l0aChcIl1cIikpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIGhyZWYgYFwiICsgaHJlZiArIFwiYCBmb3VuZCBpbiA8TGluaz4gd2hpbGUgdXNpbmcgdGhlIGAvYXBwYCByb3V0ZXIsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9hcHAtZGlyLWR5bmFtaWMtaHJlZlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBocmVmLCBhcyB9ID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICBpZiAoIXBhZ2VzUm91dGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmb3JtYXRTdHJpbmdPclVybChocmVmUHJvcCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgICAgICBhczogYXNQcm9wID8gZm9ybWF0U3RyaW5nT3JVcmwoYXNQcm9wKSA6IHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBocmVmUHJvcCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBhczogYXNQcm9wID8gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocGFnZXNSb3V0ZXIsIGFzUHJvcCkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcGFnZXNSb3V0ZXIsXG4gICAgICAgIGhyZWZQcm9wLFxuICAgICAgICBhc1Byb3BcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG4gICAgY29uc3QgcHJldmlvdXNBcyA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihhcyk7XG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1wib25DbGlja1wiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGAnICsgaHJlZlByb3AgKyAnYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25DbGljayBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGluaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTW91c2VFbnRlclByb3ApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1wib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYCcgKyBocmVmUHJvcCArICdgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGBcIiArIGhyZWZQcm9wICsgXCJgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGBcIiArIGhyZWZQcm9wICsgXCJgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlblwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICBpZiAoKGNoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZHJlbi50eXBlKSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkUmVmID0gbGVnYWN5QmVoYXZpb3IgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgY2hpbGQucmVmIDogZm9yd2FyZGVkUmVmO1xuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9ICgwLCBfdXNlaW50ZXJzZWN0aW9uLnVzZUludGVyc2VjdGlvbikoe1xuICAgICAgICByb290TWFyZ2luOiBcIjIwMHB4XCJcbiAgICB9KTtcbiAgICBjb25zdCBzZXRSZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIC8vIEJlZm9yZSB0aGUgbGluayBnZXR0aW5nIG9ic2VydmVkLCBjaGVjayBpZiB2aXNpYmxlIHN0YXRlIG5lZWQgdG8gYmUgcmVzZXRcbiAgICAgICAgaWYgKHByZXZpb3VzQXMuY3VycmVudCAhPT0gYXMgfHwgcHJldmlvdXNIcmVmLmN1cnJlbnQgIT09IGhyZWYpIHtcbiAgICAgICAgICAgIHJlc2V0VmlzaWJsZSgpO1xuICAgICAgICAgICAgcHJldmlvdXNBcy5jdXJyZW50ID0gYXM7XG4gICAgICAgICAgICBwcmV2aW91c0hyZWYuY3VycmVudCA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKTtcbiAgICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSBcImZ1bmN0aW9uXCIpIGNoaWxkUmVmKGVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBocmVmLFxuICAgICAgICByZXNldFZpc2libGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZlxuICAgIF0pO1xuICAgIC8vIFByZWZldGNoIHRoZSBVUkwgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGFuZCBpdCdzIHZpc2libGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIGluIGRldiwgd2Ugb25seSBwcmVmZXRjaCBvbiBob3ZlciB0byBhdm9pZCB3YXN0aW5nIHJlc291cmNlcyBhcyB0aGUgcHJlZmV0Y2ggd2lsbCB0cmlnZ2VyIGNvbXBpbGluZyB0aGUgcGFnZS5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgbmVlZCB0byBwcmVmZXRjaCB0aGUgVVJMLCBkb24ndCBkbyBwcmVmZXRjaC5cbiAgICAgICAgaWYgKCFpc1Zpc2libGUgfHwgIXByZWZldGNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZldGNoIHRoZSBVUkwuXG4gICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgaXNBcHBSb3V0ZXIsXG4gICAgICAgIGFwcFByZWZldGNoS2luZFxuICAgIF0pO1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICAgIHJlZjogc2V0UmVmLFxuICAgICAgICBvbkNsaWNrIChlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghcHJlZmV0Y2hFbmFibGVkIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpICYmIGlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0IChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gICAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgZG9tYWluIGFuZCBsb2NhbGUuXG4gICAgaWYgKCgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkoYXMpKSB7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzO1xuICAgIH0gZWxzZSBpZiAoIWxlZ2FjeUJlaGF2aW9yIHx8IHBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09IFwiYVwiICYmICEoXCJocmVmXCIgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbGUgOiBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSAocGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmlzTG9jYWxlRG9tYWluKSAmJiAoMCwgX2dldGRvbWFpbmxvY2FsZS5nZXREb21haW5Mb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGVzLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGxvY2FsZURvbWFpbiB8fCAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgLi4ucmVzdFByb3BzLFxuICAgICAgICAuLi5jaGlsZFByb3BzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn0pO1xuY29uc3QgX2RlZmF1bHQgPSBMaW5rO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVzb2x2ZWhyZWYiLCJfaXNsb2NhbHVybCIsIl9mb3JtYXR1cmwiLCJfdXRpbHMiLCJfYWRkbG9jYWxlIiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX3VzZWludGVyc2VjdGlvbiIsIl9nZXRkb21haW5sb2NhbGUiLCJfYWRkYmFzZXBhdGgiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwicHJlZmV0Y2hlZCIsIlNldCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImFwcE9wdGlvbnMiLCJpc0FwcFJvdXRlciIsImlzTG9jYWxVUkwiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwicHJlZmV0Y2hQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJyb3V0ZXJTY3JvbGwiLCJkZWZhdWx0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsImZvcm1hdFVybCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJyZXN0UHJvcHMiLCJqc3giLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInByZWZldGNoRW5hYmxlZCIsImFwcFByZWZldGNoS2luZCIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwia2V5cyIsImZvckVhY2giLCJvcHRpb25hbFByb3BzR3VhcmQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsInVzZVJlZiIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJjaGlsZFJlZiIsInJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0Iiwia2luZCIsImNoaWxkUHJvcHMiLCJkZWZhdWx0UHJldmVudGVkIiwicHJpb3JpdHkiLCJpc0Fic29sdXRlVXJsIiwiY3VyTG9jYWxlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJnZXREb21haW5Mb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImNsb25lRWxlbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHNCQUFzQixPQUFPUSxTQUFTLGVBQWVBLEtBQUtSLG1CQUFtQixJQUFJUSxLQUFLUixtQkFBbUIsQ0FBQ1MsSUFBSSxDQUFDQyxXQUFXLFNBQVNDLEVBQUU7SUFDdkksSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDbkJKLEdBQUc7WUFDQ0ssWUFBWTtZQUNaQyxlQUFlO2dCQUNYLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBSTtZQUM5QztRQUNKO0lBQ0osR0FBRztBQUNQO0FBQ0EsTUFBTVgscUJBQXFCLE9BQU9PLFNBQVMsZUFBZUEsS0FBS1Asa0JBQWtCLElBQUlPLEtBQUtQLGtCQUFrQixDQUFDUSxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRTtJQUNwSSxPQUFPQyxhQUFhRDtBQUN4QjtBQUVBLElBQUksQ0FBQyxPQUFPdkIsUUFBUXlCLE9BQU8sS0FBSyxjQUFlLE9BQU96QixRQUFReUIsT0FBTyxLQUFLLFlBQVl6QixRQUFReUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsUUFBUXlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks1QixPQUFPQyxjQUFjLENBQUNDLFFBQVF5QixPQUFPLEVBQUUsY0FBYztRQUFFeEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNkIsTUFBTSxDQUFDM0IsUUFBUXlCLE9BQU8sRUFBRXpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogbnVsbCxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG59KTtcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsbUlBQXdDO0FBQ3JFLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGlJQUF1QztBQUNsRSxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxxSEFBaUM7QUFDdkQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1JLDBCQUEwQkosbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQyxpSEFBNEI7QUFDcEQsTUFBTU8saUJBQWlCUCxtQkFBT0EsQ0FBQyx5SUFBMkM7QUFDMUUsU0FBU0YsWUFBWVUsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDeEMsNENBQTRDO0lBQzVDLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxPQUFPSCxTQUFTLFdBQVdBLE9BQU8sQ0FBQyxHQUFHUixXQUFXWSxvQkFBb0IsRUFBRUo7SUFDekYsNkRBQTZEO0lBQzdELG1EQUFtRDtJQUNuRCxNQUFNSyxnQkFBZ0JGLFlBQVlHLEtBQUssQ0FBQztJQUN4QyxNQUFNQyxxQkFBcUJGLGdCQUFnQkYsWUFBWUssS0FBSyxDQUFDSCxhQUFhLENBQUMsRUFBRSxDQUFDSSxNQUFNLElBQUlOO0lBQ3hGLE1BQU1PLFdBQVdILG1CQUFtQkksS0FBSyxDQUFDLEtBQUs7SUFDL0MsSUFBSSxDQUFDRCxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUMsRUFBR0osS0FBSyxDQUFDLGNBQWM7UUFDeENNLFFBQVFDLEtBQUssQ0FBQyxtQkFBbUJWLGNBQWMsdUNBQXVDSixPQUFPZSxRQUFRLEdBQUc7UUFDeEcsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR3JCLE9BQU9zQix3QkFBd0IsRUFBRVQ7UUFDM0RKLGNBQWMsQ0FBQ0UsZ0JBQWdCQSxhQUFhLENBQUMsRUFBRSxHQUFHLEVBQUMsSUFBS1U7SUFDNUQ7SUFDQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDLENBQUMsR0FBR25CLFlBQVlxQixVQUFVLEVBQUVkLGNBQWM7UUFDM0MsT0FBT0YsWUFBWTtZQUNmRTtTQUNILEdBQUdBO0lBQ1I7SUFDQSxJQUFJO1FBQ0FELE9BQU8sSUFBSWdCLElBQUlmLFlBQVlnQixVQUFVLENBQUMsT0FBT3BCLE9BQU9xQixNQUFNLEdBQUdyQixPQUFPZSxRQUFRLEVBQUU7SUFDbEYsRUFBRSxPQUFPTyxHQUFHO1FBQ1Isa0RBQWtEO1FBQ2xEbkIsT0FBTyxJQUFJZ0IsSUFBSSxLQUFLO0lBQ3hCO0lBQ0EsSUFBSTtRQUNBLE1BQU1JLFdBQVcsSUFBSUosSUFBSWYsYUFBYUQ7UUFDdENvQixTQUFTUixRQUFRLEdBQUcsQ0FBQyxHQUFHbkIsd0JBQXdCNEIsMEJBQTBCLEVBQUVELFNBQVNSLFFBQVE7UUFDN0YsSUFBSVUsaUJBQWlCO1FBQ3JCLElBQUksQ0FBQyxHQUFHM0IsUUFBUTRCLGNBQWMsRUFBRUgsU0FBU1IsUUFBUSxLQUFLUSxTQUFTSSxZQUFZLElBQUl6QixXQUFXO1lBQ3RGLE1BQU0wQixRQUFRLENBQUMsR0FBR3JDLGFBQWFzQyxzQkFBc0IsRUFBRU4sU0FBU0ksWUFBWTtZQUM1RSxNQUFNLEVBQUVHLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHaEMsZUFBZWlDLGFBQWEsRUFBRVQsU0FBU1IsUUFBUSxFQUFFUSxTQUFTUixRQUFRLEVBQUVhO1lBQ25HLElBQUlFLFFBQVE7Z0JBQ1JMLGlCQUFpQixDQUFDLEdBQUdoQyxXQUFXWSxvQkFBb0IsRUFBRTtvQkFDbERVLFVBQVVlO29CQUNWRyxNQUFNVixTQUFTVSxJQUFJO29CQUNuQkwsT0FBTyxDQUFDLEdBQUdsQyxNQUFNd0MsSUFBSSxFQUFFTixPQUFPRztnQkFDbEM7WUFDSjtRQUNKO1FBQ0Esb0VBQW9FO1FBQ3BFLE1BQU1JLGVBQWVaLFNBQVNhLE1BQU0sS0FBS2pDLEtBQUtpQyxNQUFNLEdBQUdiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUFJYSxTQUFTdEIsSUFBSTtRQUNsSCxPQUFPQyxZQUFZO1lBQ2ZpQztZQUNBVixrQkFBa0JVO1NBQ3JCLEdBQUdBO0lBQ1IsRUFBRSxPQUFPYixHQUFHO1FBQ1IsT0FBT3BCLFlBQVk7WUFDZkU7U0FDSCxHQUFHQTtJQUNSO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2xCLFFBQVFtRCxPQUFPLEtBQUssY0FBZSxPQUFPbkQsUUFBUW1ELE9BQU8sS0FBSyxZQUFZbkQsUUFBUW1ELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25ELFFBQVFtRCxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRbUQsT0FBTyxFQUFFLGNBQWM7UUFBRWxELE9BQU87SUFBSztJQUNuRUgsT0FBT3VELE1BQU0sQ0FBQ3JELFFBQVFtRCxPQUFPLEVBQUVuRDtJQUMvQnNELE9BQU90RCxPQUFPLEdBQUdBLFFBQVFtRCxPQUFPO0FBQ2xDLEVBRUEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcz8yZjllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZUhyZWZcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVIcmVmO1xuICAgIH1cbn0pO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfdXRpbHMxID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXNcIik7XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09IFwic3RyaW5nXCIgPyBocmVmIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKGhyZWYpO1xuICAgIC8vIHJlcGVhdGVkIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSBVUkwgYXJlIGNvbnNpZGVyZWRcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcbiAgICBjb25zdCB1cmxQcm90b01hdGNoID0gdXJsQXNTdHJpbmcubWF0Y2goL15bYS16QS1aXXsxLH06XFwvXFwvLyk7XG4gICAgY29uc3QgdXJsQXNTdHJpbmdOb1Byb3RvID0gdXJsUHJvdG9NYXRjaCA/IHVybEFzU3RyaW5nLnNsaWNlKHVybFByb3RvTWF0Y2hbMF0ubGVuZ3RoKSA6IHVybEFzU3RyaW5nO1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KFwiP1wiLCAxKTtcbiAgICBpZiAoKHVybFBhcnRzWzBdIHx8IFwiXCIpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgaHJlZiAnXCIgKyB1cmxBc1N0cmluZyArIFwiJyBwYXNzZWQgdG8gbmV4dC9yb3V0ZXIgaW4gcGFnZTogJ1wiICsgcm91dGVyLnBhdGhuYW1lICsgXCInLiBSZXBlYXRlZCBmb3J3YXJkLXNsYXNoZXMgKC8vKSBvciBiYWNrc2xhc2hlcyBcXFxcIGFyZSBub3QgdmFsaWQgaW4gdGhlIGhyZWYuXCIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscy5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMpKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogXCJcIikgKyBub3JtYWxpemVkVXJsO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybEFzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiYXNlID0gbmV3IFVSTCh1cmxBc1N0cmluZy5zdGFydHNXaXRoKFwiI1wiKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsIFwiaHR0cDovL25cIik7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xuICAgICAgICBiYXNlID0gbmV3IFVSTChcIi9cIiwgXCJodHRwOi8vblwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gXCJcIjtcbiAgICAgICAgaWYgKCgwLCBfdXRpbHMxLmlzRHluYW1pY1JvdXRlKShmaW5hbFVybC5wYXRobmFtZSkgJiYgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmIHJlc29sdmVBcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSAoMCwgX3F1ZXJ5c3RyaW5nLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkpKGZpbmFsVXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIF0gOiByZXNvbHZlZEhyZWY7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS1ocmVmLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXNvbHZlSHJlZiIsIl9xdWVyeXN0cmluZyIsInJlcXVpcmUiLCJfZm9ybWF0dXJsIiwiX29taXQiLCJfdXRpbHMiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsIl9pc2xvY2FsdXJsIiwiX3V0aWxzMSIsIl9pbnRlcnBvbGF0ZWFzIiwicm91dGVyIiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwic2xpY2UiLCJsZW5ndGgiLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwicGF0aG5hbWUiLCJub3JtYWxpemVkVXJsIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwiaXNMb2NhbFVSTCIsIlVSTCIsInN0YXJ0c1dpdGgiLCJhc1BhdGgiLCJfIiwiZmluYWxVcmwiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImludGVycG9sYXRlZEFzIiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJyZXN1bHQiLCJwYXJhbXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXQiLCJyZXNvbHZlZEhyZWYiLCJvcmlnaW4iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsNkdBQXlCO0FBQzlELE1BQU1FLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFDaEUsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxTQUFTLEVBQUU7QUFDakIsU0FBU0MsZUFBZUMsT0FBTztJQUMzQixNQUFNQyxLQUFLO1FBQ1BDLE1BQU1GLFFBQVFFLElBQUksSUFBSTtRQUN0QkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVQLEdBQUcsQ0FBQ2dCO1FBQ3pCLElBQUlHLFVBQVU7WUFDVixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxNQUFNQyxXQUFXLElBQUlaO0lBQ3JCLE1BQU1hLFdBQVcsSUFBSWYscUJBQXFCLENBQUNnQjtRQUN2Q0EsUUFBUUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IsTUFBTUMsV0FBV0wsU0FBU3BCLEdBQUcsQ0FBQ3dCLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN2QkYsU0FBU0U7WUFDYjtRQUNKO0lBQ0osR0FBR2hCO0lBQ0hRLFdBQVc7UUFDUFA7UUFDQVM7UUFDQUQ7SUFDSjtJQUNBWCxPQUFPcUIsSUFBSSxDQUFDbEI7SUFDWkwsVUFBVXdCLEdBQUcsQ0FBQ25CLElBQUlPO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTYSxRQUFRQyxPQUFPLEVBQUVSLFFBQVEsRUFBRWQsT0FBTztJQUN2QyxNQUFNLEVBQUVDLEVBQUUsRUFBRVMsUUFBUSxFQUFFRCxRQUFRLEVBQUUsR0FBR1YsZUFBZUM7SUFDbERTLFNBQVNXLEdBQUcsQ0FBQ0UsU0FBU1I7SUFDdEJKLFNBQVNXLE9BQU8sQ0FBQ0M7SUFDakIsT0FBTyxTQUFTQztRQUNaZCxTQUFTZSxNQUFNLENBQUNGO1FBQ2hCWixTQUFTYSxTQUFTLENBQUNEO1FBQ25CLHVEQUF1RDtRQUN2RCxJQUFJYixTQUFTZ0IsSUFBSSxLQUFLLEdBQUc7WUFDckJmLFNBQVNnQixVQUFVO1lBQ25COUIsVUFBVTRCLE1BQU0sQ0FBQ3ZCO1lBQ2pCLE1BQU0wQixRQUFRN0IsT0FBTzhCLFNBQVMsQ0FBQyxDQUFDckIsTUFBTUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtZQUN0RixJQUFJd0IsUUFBUSxDQUFDLEdBQUc7Z0JBQ1o3QixPQUFPK0IsTUFBTSxDQUFDRixPQUFPO1lBQ3pCO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU3JDLGdCQUFnQndDLEtBQUs7SUFDMUIsSUFBSSxFQUFFQyxPQUFPLEVBQUUzQixVQUFVLEVBQUU0QixRQUFRLEVBQUUsR0FBR0Y7SUFDeEMsTUFBTUcsYUFBYUQsWUFBWSxDQUFDdEM7SUFDaEMsTUFBTSxDQUFDd0MsU0FBU0MsV0FBVyxHQUFHLENBQUMsR0FBRzVDLE9BQU82QyxRQUFRLEVBQUU7SUFDbkQsTUFBTUMsYUFBYSxDQUFDLEdBQUc5QyxPQUFPK0MsTUFBTSxFQUFFO0lBQ3RDLE1BQU1DLGFBQWEsQ0FBQyxHQUFHaEQsT0FBT2lELFdBQVcsRUFBRSxDQUFDbEI7UUFDeENlLFdBQVdJLE9BQU8sR0FBR25CO0lBQ3pCLEdBQUcsRUFBRTtJQUNKLElBQUcvQixPQUFPbUQsU0FBUyxFQUFFO1FBQ2xCLElBQUloRCx5QkFBeUI7WUFDekIsSUFBSXVDLGNBQWNDLFNBQVM7WUFDM0IsTUFBTVosVUFBVWUsV0FBV0ksT0FBTztZQUNsQyxJQUFJbkIsV0FBV0EsUUFBUXFCLE9BQU8sRUFBRTtnQkFDNUIsTUFBTXBCLFlBQVlGLFFBQVFDLFNBQVMsQ0FBQ04sWUFBWUEsYUFBYW1CLFdBQVduQixZQUFZO29CQUNoRmQsTUFBTTZCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFVLE9BQU87b0JBQ2hEckM7Z0JBQ0o7Z0JBQ0EsT0FBT21CO1lBQ1g7UUFDSixPQUFPO1lBQ0gsSUFBSSxDQUFDVyxTQUFTO2dCQUNWLE1BQU1VLGVBQWUsQ0FBQyxHQUFHbkQscUJBQXFCb0QsbUJBQW1CLEVBQUUsSUFBSVYsV0FBVztnQkFDbEYsT0FBTyxJQUFJLENBQUMsR0FBRzFDLHFCQUFxQnFELGtCQUFrQixFQUFFRjtZQUM1RDtRQUNKO0lBQ0osdURBQXVEO0lBQ3ZELEdBQUc7UUFDQ1g7UUFDQTdCO1FBQ0EyQjtRQUNBRztRQUNBRyxXQUFXSSxPQUFPO0tBQ3JCO0lBQ0QsTUFBTU0sZUFBZSxDQUFDLEdBQUd4RCxPQUFPaUQsV0FBVyxFQUFFO1FBQ3pDTCxXQUFXO0lBQ2YsR0FBRyxFQUFFO0lBQ0wsT0FBTztRQUNISTtRQUNBTDtRQUNBYTtLQUNIO0FBQ0w7QUFFQSxJQUFJLENBQUMsT0FBTzdELFFBQVE4RCxPQUFPLEtBQUssY0FBZSxPQUFPOUQsUUFBUThELE9BQU8sS0FBSyxZQUFZOUQsUUFBUThELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzlELFFBQVE4RCxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakUsT0FBT0MsY0FBYyxDQUFDQyxRQUFROEQsT0FBTyxFQUFFLGNBQWM7UUFBRTdELE9BQU87SUFBSztJQUNuRUgsT0FBT2tFLE1BQU0sQ0FBQ2hFLFFBQVE4RCxPQUFPLEVBQUU5RDtJQUMvQmlFLE9BQU9qRSxPQUFPLEdBQUdBLFFBQVE4RCxPQUFPO0FBQ2xDLEVBRUEsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZUludGVyc2VjdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlSW50ZXJzZWN0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgX3JlcXVlc3RpZGxlY2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCBcIlwiXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHJvb3RSZWYsIHJvb3RNYXJnaW4sIGRpc2FibGVkIH0gPSBwYXJhbTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoZWxlbWVudCk9PntcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2suY2FuY2VsSWRsZUNhbGxiYWNrKShpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgcm9vdFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50XG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInVzZUludGVyc2VjdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVxdWVzdGlkbGVjYWxsYmFjayIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwYXJhbSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUM3RDtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFDeEIsU0FBU0YsbUJBQW1CRyxHQUFHO0lBQzNCLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDdkIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDeEM7SUFDQSxPQUFPQztBQUNYLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzP2RiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVnZXhwIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZXNjYXBlLXN0cmluZy1yZWdleHBcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlU3RyaW5nUmVnZXhwXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmdSZWdleHA7XG4gICAgfVxufSk7XG5jb25zdCByZUhhc1JlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dLztcbmNvbnN0IHJlUmVwbGFjZVJlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2c7XG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyKSB7XG4gICAgLy8gc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvMmRhMDI0YzNiNGY5OTQ3YTQ4NTE3NjM5ZGU3NTYwNDU3Y2Q0ZWM2Yy9lc2NhcGVSZWdFeHAuanMjTDIzXG4gICAgaWYgKHJlSGFzUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVSZXBsYWNlUmVnRXhwLCBcIlxcXFwkJlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLXJlZ2V4cC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixnQkFBZ0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDO0FBQ25ELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGNBQWNRLFdBQVcsR0FBRztBQUNoQyxFQUVBLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/OGZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlckNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUM1QjtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDRCQUE0QkMsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1DLGVBQWUsV0FBVyxHQUFHRiwwQkFBMEJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsMEdBQWU7QUFDdEYsTUFBTUcsbUJBQW1CO0FBQ3pCLFNBQVNiLFVBQVVjLE1BQU07SUFDckIsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBTztJQUNYTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUNwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDYkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUM3QixPQUFPLElBQUlMLFVBQVU7UUFDakJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQU8sTUFBTVIsV0FBVyxNQUFNQSxRQUFPO1FBQ3RFLElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNiSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDN0I7SUFDSjtJQUNBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3BDQSxRQUFRTSxPQUFPZixhQUFhZ0Isc0JBQXNCLENBQUNQO0lBQ3ZEO0lBQ0EsSUFBSVEsU0FBU2QsT0FBT2MsTUFBTSxJQUFJUixTQUFTLE1BQU1BLFNBQVM7SUFDdEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTWSxRQUFRLENBQUMsTUFBTVosWUFBWTtJQUNyRCxJQUFJSCxPQUFPZ0IsT0FBTyxJQUFJLENBQUMsQ0FBQ2IsWUFBWUosaUJBQWlCa0IsSUFBSSxDQUFDZCxTQUFRLEtBQU1JLFNBQVMsT0FBTztRQUNwRkEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRLEVBQUM7UUFDeEIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQzFELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2RBLE9BQU87SUFDWDtJQUNBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJUyxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFDaERWLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ00sU0FBU0EsT0FBT0wsT0FBTyxDQUFDLEtBQUs7SUFDN0IsT0FBTyxLQUFLTixXQUFXSSxPQUFPSCxXQUFXVSxTQUFTVDtBQUN0RDtBQUNBLE1BQU1sQixnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTQyxxQkFBcUI4QixHQUFHO0lBQzdCLElBQUlDLElBQXNDLEVBQUU7UUFDeEMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUN6Q3JDLE9BQU91QyxJQUFJLENBQUNGLEtBQUtHLE9BQU8sQ0FBQyxDQUFDQztnQkFDdEIsSUFBSSxDQUFDbkMsY0FBY29DLFFBQVEsQ0FBQ0QsTUFBTTtvQkFDOUJFLFFBQVFDLElBQUksQ0FBQyx1REFBdURIO2dCQUN4RTtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9wQyxVQUFVZ0M7QUFDckIsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0VXJsOiBudWxsLFxuICAgIHVybE9iamVjdEtleXM6IG51bGwsXG4gICAgZm9ybWF0V2l0aFZhbGlkYXRpb246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZm9ybWF0VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFVybDtcbiAgICB9LFxuICAgIHVybE9iamVjdEtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXJsT2JqZWN0S2V5cztcbiAgICB9LFxuICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFdpdGhWYWxpZGF0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4vcXVlcnlzdHJpbmdcIikpO1xuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztcbmZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmopIHtcbiAgICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCBcIlwiO1xuICAgIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCBcIlwiO1xuICAgIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgXCJcIjtcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgXCJcIjtcbiAgICBsZXQgaG9zdCA9IGZhbHNlO1xuICAgIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCBcIjpcIikgKyBcIkBcIiA6IFwiXCI7XG4gICAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3Q7XG4gICAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPyBcIltcIiArIGhvc3RuYW1lICsgXCJdXCIgOiBob3N0bmFtZSk7XG4gICAgICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgICAgICAgaG9zdCArPSBcIjpcIiArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBTdHJpbmcoX3F1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgXCI/XCIgKyBxdWVyeSB8fCBcIlwiO1xuICAgIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSBwcm90b2NvbCArPSBcIjpcIjtcbiAgICBpZiAodXJsT2JqLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgICAgICBob3N0ID0gXCIvL1wiICsgKGhvc3QgfHwgXCJcIik7XG4gICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gXCIvXCIpIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSBcIiNcIikgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gXCI/XCIpIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcbiAgICByZXR1cm4gXCJcIiArIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cbmNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICAgXCJhdXRoXCIsXG4gICAgXCJoYXNoXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJob3N0bmFtZVwiLFxuICAgIFwiaHJlZlwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0aG5hbWVcIixcbiAgICBcInBvcnRcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJxdWVyeVwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzbGFzaGVzXCJcbl07XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRVcmwodXJsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJmb3JtYXRVcmwiLCJ1cmxPYmplY3RLZXlzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9xdWVyeXN0cmluZyIsIl8iLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGlCQUFpQjtRQUNiLE9BQU9RLGNBQWNSLGVBQWU7SUFDeEM7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT1EsV0FBV1IsY0FBYztJQUNwQztBQUNKO0FBQ0EsTUFBTU8sZ0JBQWdCRSxtQkFBT0EsQ0FBQyw4R0FBaUI7QUFDL0MsTUFBTUQsYUFBYUMsbUJBQU9BLENBQUMsd0dBQWMsR0FFekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanM/ZjUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFNvcnRlZFJvdXRlczogbnVsbCxcbiAgICBpc0R5bmFtaWNSb3V0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRTb3J0ZWRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NvcnRlZHJvdXRlcy5nZXRTb3J0ZWRSb3V0ZXM7XG4gICAgfSxcbiAgICBpc0R5bmFtaWNSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX3NvcnRlZHJvdXRlcyA9IHJlcXVpcmUoXCIuL3NvcnRlZC1yb3V0ZXNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vaXMtZHluYW1pY1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc29ydGVkcm91dGVzIiwiX2lzZHluYW1pYyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsOEdBQWlCO0FBQy9DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDBHQUFlO0FBQzNDLFNBQVNGLGNBQWNJLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxLQUFLO0lBQzNDLElBQUlDLG9CQUFvQjtJQUN4QixNQUFNQyxlQUFlLENBQUMsR0FBR0wsWUFBWU0sYUFBYSxFQUFFTDtJQUNwRCxNQUFNTSxnQkFBZ0JGLGFBQWFHLE1BQU07SUFDekMsTUFBTUMsaUJBQ04sQ0FBQ1AsZUFBZUQsUUFBUSxDQUFDLEdBQUdILGNBQWNZLGVBQWUsRUFBRUwsY0FBY0gsY0FBYyxFQUFDLEtBQU0sZ0RBQWdEO0lBQzlJLHNFQUFzRTtJQUN0RUM7SUFDQUMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTcEIsT0FBT3FCLElBQUksQ0FBQ0w7SUFDM0IsSUFBSSxDQUFDSSxPQUFPRSxLQUFLLENBQUMsQ0FBQ0M7UUFDZixJQUFJcEIsUUFBUWUsY0FBYyxDQUFDSyxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHVCxhQUFhLENBQUNPLE1BQU07UUFDakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJRyxXQUFXLE1BQU9GLENBQUFBLFNBQVMsUUFBUSxFQUFDLElBQUtELFFBQVE7UUFDckQsSUFBSUUsVUFBVTtZQUNWQyxXQUFXLENBQUMsQ0FBQ3ZCLFFBQVEsTUFBTSxFQUFDLElBQUssTUFBTXVCLFdBQVc7UUFDdEQ7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ3pCLFFBQVFBLFFBQVE7WUFDekNBO1NBQ0g7UUFDRCxPQUFPLENBQUNzQixZQUFZRixTQUFTTCxjQUFhLEtBQU0sNkNBQTZDO1FBQzVGTCxDQUFBQSxvQkFBb0JBLGtCQUFrQmdCLE9BQU8sQ0FBQ0gsVUFBVUYsU0FBU3JCLE1BQU0yQixHQUFHLENBQzNFLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVVDLG1CQUFtQkQsVUFBVUUsSUFBSSxDQUFDLE9BQU9ELG1CQUFtQjdCLFdBQVcsR0FBRTtJQUN4RixJQUFJO1FBQ0FVLG9CQUFvQixHQUFHLG1DQUFtQzs7SUFFOUQsdUVBQXVFO0lBQ3ZFLGtEQUFrRDtJQUNsRDtJQUNBLE9BQU87UUFDSE87UUFDQWMsUUFBUXJCO0lBQ1o7QUFDSixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzLmpzP2QwZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcnBvbGF0ZUFzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUFzO1xuICAgIH1cbn0pO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3JvdXRlLXJlZ2V4XCIpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiO1xuICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XG4gICAgY29uc3QgZHluYW1pY01hdGNoZXMgPSAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogXCJcIikgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgXCJcIjtcbiAgICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gXCJbXCIgKyAocmVwZWF0ID8gXCIuLi5cIiA6IFwiXCIpICsgcGFyYW0gKyBcIl1cIjtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9ICghdmFsdWUgPyBcIi9cIiA6IFwiXCIpICsgXCJbXCIgKyByZXBsYWNlZCArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KSkuam9pbihcIi9cIikgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSB8fCBcIi9cIik7XG4gICAgfSkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycG9sYXRlLWFzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpbnRlcnBvbGF0ZUFzIiwiX3JvdXRlbWF0Y2hlciIsInJlcXVpcmUiLCJfcm91dGVyZWdleCIsInJvdXRlIiwiYXNQYXRobmFtZSIsInF1ZXJ5IiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImdyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW1zIiwia2V5cyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVwbGFjZSIsIm1hcCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyx3SkFBdUQ7QUFDM0YscUNBQXFDO0FBQ3JDLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0gsZUFBZUksS0FBSztJQUN6QixJQUFJLENBQUMsR0FBR0gsb0JBQW9CSSwwQkFBMEIsRUFBRUQsUUFBUTtRQUM1REEsUUFBUSxDQUFDLEdBQUdILG9CQUFvQkssbUNBQW1DLEVBQUVGLE9BQU9HLGdCQUFnQjtJQUNoRztJQUNBLE9BQU9KLFdBQVdLLElBQUksQ0FBQ0o7QUFDM0IsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLmpzPzQ2ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0R5bmFtaWNSb3V0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNEeW5hbWljUm91dGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvO1xuZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGUpIHtcbiAgICBpZiAoKDAsIF9pbnRlcmNlcHRpb25yb3V0ZXMuaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgpKHJvdXRlKSkge1xuICAgICAgICByb3V0ZSA9ICgwLCBfaW50ZXJjZXB0aW9ucm91dGVzLmV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uKShyb3V0ZSkuaW50ZXJjZXB0ZWRSb3V0ZTtcbiAgICB9XG4gICAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWR5bmFtaWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImlzRHluYW1pY1JvdXRlIiwiX2ludGVyY2VwdGlvbnJvdXRlcyIsInJlcXVpcmUiLCJURVNUX1JPVVRFIiwicm91dGUiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uIiwiaW50ZXJjZXB0ZWRSb3V0ZSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw4Q0FBNkM7SUFDekNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxxRkFBYTtBQUNwQyxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyw4R0FBa0M7QUFDL0QsU0FBU0YsV0FBV0ksR0FBRztJQUNuQixnRUFBZ0U7SUFDaEUsSUFBSSxDQUFDLENBQUMsR0FBR0gsT0FBT0ksYUFBYSxFQUFFRCxNQUFNLE9BQU87SUFDNUMsSUFBSTtRQUNBLDREQUE0RDtRQUM1RCxNQUFNRSxpQkFBaUIsQ0FBQyxHQUFHTCxPQUFPTSxpQkFBaUI7UUFDbkQsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQixDQUFDLEdBQUdILGFBQWFRLFdBQVcsRUFBRUgsU0FBU0ksUUFBUTtJQUNoRyxFQUFFLE9BQU9DLEdBQUc7UUFDUixPQUFPO0lBQ1g7QUFDSixFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC5qcz81ZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2NhbFVSTFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNMb2NhbFVSTDtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICghKDAsIF91dGlscy5pc0Fic29sdXRlVXJsKSh1cmwpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJlc29sdmVkLnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWxvY2FsLXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNMb2NhbFVSTCIsIl91dGlscyIsInJlcXVpcmUiLCJfaGFzYmFzZXBhdGgiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsd0NBQXVDO0lBQ25DSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsS0FBS0MsTUFBTSxFQUFFQyxJQUFJO0lBQ3RCLE1BQU1DLFVBQVUsQ0FBQztJQUNqQlQsT0FBT1EsSUFBSSxDQUFDRCxRQUFRRyxPQUFPLENBQUMsQ0FBQ0M7UUFDekIsSUFBSSxDQUFDSCxLQUFLSSxRQUFRLENBQUNELE1BQU07WUFDckJGLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHSixNQUFNLENBQUNJLElBQUk7UUFDOUI7SUFDSjtJQUNBLE9BQU9GO0FBQ1gsRUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LmpzP2ZiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbWl0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvbWl0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXMpIHtcbiAgICBjb25zdCBvbWl0dGVkID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBvbWl0dGVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvbWl0dGVkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbWl0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJvbWl0Iiwib2JqZWN0Iiwia2V5cyIsIm9taXR0ZWQiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    },\n    assign: function() {\n        return assign;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxTQUFTRix1QkFBdUJTLFlBQVk7SUFDeEMsTUFBTUMsUUFBUSxDQUFDO0lBQ2ZELGFBQWFFLE9BQU8sQ0FBQyxDQUFDYixPQUFPYztRQUN6QixJQUFJLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxLQUFLLGFBQWE7WUFDbkNGLEtBQUssQ0FBQ0UsSUFBSSxHQUFHZDtRQUNqQixPQUFPLElBQUllLE1BQU1DLE9BQU8sQ0FBQ0osS0FBSyxDQUFDRSxJQUFJLEdBQUc7WUFDbENGLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRyxJQUFJLENBQUNqQjtRQUNwQixPQUFPO1lBQ0hZLEtBQUssQ0FBQ0UsSUFBSSxHQUFHO2dCQUNURixLQUFLLENBQUNFLElBQUk7Z0JBQ1ZkO2FBQ0g7UUFDTDtJQUNKO0lBQ0EsT0FBT1k7QUFDWDtBQUNBLFNBQVNNLHVCQUF1QkMsS0FBSztJQUNqQyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFBVSxPQUFPQSxVQUFVLFdBQVc7UUFDdkcsT0FBT0UsT0FBT0Y7SUFDbEIsT0FBTztRQUNILE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU2hCLHVCQUF1Qm1CLFFBQVE7SUFDcEMsTUFBTUMsU0FBUyxJQUFJQztJQUNuQjNCLE9BQU80QixPQUFPLENBQUNILFVBQVVULE9BQU8sQ0FBQyxDQUFDTTtRQUM5QixJQUFJLENBQUNMLEtBQUtkLE1BQU0sR0FBR21CO1FBQ25CLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ2hCLFFBQVE7WUFDdEJBLE1BQU1hLE9BQU8sQ0FBQyxDQUFDYSxPQUFPSCxPQUFPSSxNQUFNLENBQUNiLEtBQUtJLHVCQUF1QlE7UUFDcEUsT0FBTztZQUNISCxPQUFPSyxHQUFHLENBQUNkLEtBQUtJLHVCQUF1QmxCO1FBQzNDO0lBQ0o7SUFDQSxPQUFPdUI7QUFDWDtBQUNBLFNBQVNuQixPQUFPRSxNQUFNO0lBQ2xCLElBQUksSUFBSXVCLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsbUJBQW1CLElBQUlqQixNQUFNYyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQU87UUFDbEhELGdCQUFnQixDQUFDQyxPQUFPLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxLQUFLO0lBQ2hEO0lBQ0FELGlCQUFpQm5CLE9BQU8sQ0FBQyxDQUFDRjtRQUN0QkksTUFBTW1CLElBQUksQ0FBQ3ZCLGFBQWF3QixJQUFJLElBQUl0QixPQUFPLENBQUMsQ0FBQ0MsTUFBTVIsT0FBTzhCLE1BQU0sQ0FBQ3RCO1FBQzdESCxhQUFhRSxPQUFPLENBQUMsQ0FBQ2IsT0FBT2MsTUFBTVIsT0FBT3FCLE1BQU0sQ0FBQ2IsS0FBS2Q7SUFDMUQ7SUFDQSxPQUFPTTtBQUNYLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanM/MDE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnk6IG51bGwsXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogbnVsbCxcbiAgICBhc3NpZ246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5O1xuICAgIH0sXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zO1xuICAgIH0sXG4gICAgYXNzaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbjtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG4gICAgICAgICAgICAgICAgcXVlcnlba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocGFyYW0pIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyh1cmxRdWVyeSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBwYXJhbTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKT0+cmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlYXJjaFBhcmFtc0xpc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHNlYXJjaFBhcmFtc0xpc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcyk9PntcbiAgICAgICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpPT50YXJnZXQuZGVsZXRlKGtleSkpO1xuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PnRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiYXNzaWduIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMscUZBQWE7QUFDcEMsU0FBU0YsZ0JBQWdCRyxLQUFLO0lBQzFCLElBQUksRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Y7SUFDckIsT0FBTyxDQUFDRztRQUNKLE1BQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsT0FBTztRQUNYO1FBQ0EsTUFBTUUsU0FBUyxDQUFDTjtZQUNaLElBQUk7Z0JBQ0EsT0FBT08sbUJBQW1CUDtZQUM5QixFQUFFLE9BQU9RLEdBQUc7Z0JBQ1IsTUFBTSxJQUFJVixPQUFPVyxXQUFXLENBQUM7WUFDakM7UUFDSjtRQUNBLE1BQU1DLFNBQVMsQ0FBQztRQUNoQm5CLE9BQU9vQixJQUFJLENBQUNULFFBQVFVLE9BQU8sQ0FBQyxDQUFDQztZQUN6QixNQUFNQyxJQUFJWixNQUFNLENBQUNXLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVgsVUFBVSxDQUFDVSxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDakJQLE1BQU0sQ0FBQ0csU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUFPSCxFQUFFSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLFFBQVFmLE9BQU9lLFVBQVVQLEVBQUVRLE1BQU0sR0FBRztvQkFDdkZoQixPQUFPUztpQkFDVixHQUFHVCxPQUFPUztZQUNmO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0FBQ0osRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzP2M4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRSb3V0ZU1hdGNoZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlTWF0Y2hlcjtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihwYXJhbSkge1xuICAgIGxldCB7IHJlLCBncm91cHMgfSA9IHBhcmFtO1xuICAgIHJldHVybiAocGF0aG5hbWUpPT57XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxzLkRlY29kZUVycm9yKFwiZmFpbGVkIHRvIGRlY29kZSBwYXJhbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZihcIi9cIikgPyBtLnNwbGl0KFwiL1wiKS5tYXAoKGVudHJ5KT0+ZGVjb2RlKGVudHJ5KSkgOiBnLnJlcGVhdCA/IFtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlKG0pXG4gICAgICAgICAgICAgICAgXSA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbWF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0Um91dGVNYXRjaGVyIiwiX3V0aWxzIiwicmVxdWlyZSIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0lBQ0FDLHlCQUF5QjtRQUNyQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxzQkFBc0JDLG1CQUFPQSxDQUFDLHdKQUF1RDtBQUMzRixNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHFHQUFxQjtBQUNuRCxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLDhIQUF5QjtBQUM5RCxNQUFNRywwQkFBMEI7QUFDaEMsTUFBTUMsa0NBQWtDO0FBQ3hDOzs7Ozs7O0NBT0MsR0FBRyxTQUFTQyxlQUFlQyxLQUFLO0lBQzdCLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNWRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzVCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDUkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3hCO0lBQ0EsT0FBTztRQUNIRSxLQUFLTjtRQUNMSztRQUNBSjtJQUNKO0FBQ0o7QUFDQSxTQUFTTSxxQkFBcUJDLEtBQUs7SUFD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LE9BQU87Z0JBQ0gsT0FBTyxNQUFNLENBQUMsR0FBRzVELGNBQWM2QixrQkFBa0IsRUFBRVI7WUFDdkQ7UUFDSixHQUFHUyxJQUFJLENBQUM7UUFDUmU7SUFDSjtBQUNKO0FBQ0EsU0FBU3ZELG1CQUFtQnlDLGVBQWUsRUFBRThCLGNBQWM7SUFDdkQsTUFBTUMsU0FBU1IsMEJBQTBCdkIsaUJBQWlCOEI7SUFDMUQsT0FBTztRQUNILEdBQUd4RSxjQUFjMEMsZ0JBQWdCO1FBQ2pDZ0MsWUFBWSxNQUFNRCxPQUFPTix1QkFBdUIsR0FBRztRQUNuRFgsV0FBV2lCLE9BQU9qQixTQUFTO0lBQy9CO0FBQ0o7QUFDQSxTQUFTdEQsd0JBQXdCd0MsZUFBZSxFQUFFaUMsT0FBTztJQUNyRCxNQUFNLEVBQUU3QyxrQkFBa0IsRUFBRSxHQUFHUCxxQkFBcUJtQjtJQUNwRCxNQUFNLEVBQUVrQyxXQUFXLElBQUksRUFBRSxHQUFHRDtJQUM1QixJQUFJN0MsdUJBQXVCLEtBQUs7UUFDNUIsSUFBSStDLGdCQUFnQkQsV0FBVyxPQUFPO1FBQ3RDLE9BQU87WUFDSEYsWUFBWSxPQUFPRyxnQkFBZ0I7UUFDdkM7SUFDSjtJQUNBLE1BQU0sRUFBRVYsdUJBQXVCLEVBQUUsR0FBR0YsMEJBQTBCdkIsaUJBQWlCO0lBQy9FLElBQUlvQyx1QkFBdUJGLFdBQVcsZUFBZTtJQUNyRCxPQUFPO1FBQ0hGLFlBQVksTUFBTVAsMEJBQTBCVyx1QkFBdUI7SUFDdkU7QUFDSixFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzP2VhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBudWxsLFxuICAgIGdldE5hbWVkUm91dGVSZWdleDogbnVsbCxcbiAgICBnZXROYW1lZE1pZGRsZXdhcmVSZWdleDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlUmVnZXg7XG4gICAgfSxcbiAgICBnZXROYW1lZFJvdXRlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRSb3V0ZVJlZ2V4O1xuICAgIH0sXG4gICAgZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuY29uc3QgX2VzY2FwZXJlZ2V4cCA9IHJlcXVpcmUoXCIuLi8uLi9lc2NhcGUtcmVnZXhwXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA9IFwibnh0UFwiO1xuY29uc3QgTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA9IFwibnh0SVwiO1xuLyoqXG4gKiBQYXJzZXMgYSBnaXZlbiBwYXJhbWV0ZXIgZnJvbSBhIHJvdXRlIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjYW4gYmUgdXNlZFxuICogdG8gZ2VuZXJhdGUgdGhlIHBhcmFtZXRyaXplZCByb3V0ZS4gRXhhbXBsZXM6XG4gKiAgIC0gYFsuLi5zbHVnXWAgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfWBcbiAqICAgLSBgLi4uc2x1Z2AgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IGZhbHNlIH1gXG4gKiAgIC0gYFtmb29dYCAtPiBgeyBrZXk6ICdmb28nLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogdHJ1ZSB9YFxuICogICAtIGBiYXJgIC0+IGB7IGtleTogJ2JhcicsIHJlcGVhdDogZmFsc2UsIG9wdGlvbmFsOiBmYWxzZSB9YFxuICovIGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKFwiW1wiKSAmJiBwYXJhbS5lbmRzV2l0aChcIl1cIik7XG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICBjb25zdCByZXBlYXQgPSBwYXJhbS5zdGFydHNXaXRoKFwiLi4uXCIpO1xuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBwYXJhbSxcbiAgICAgICAgcmVwZWF0LFxuICAgICAgICBvcHRpb25hbFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0cml6ZWRSb3V0ZShyb3V0ZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgbGV0IGdyb3VwSW5kZXggPSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgbWFya2VyTWF0Y2ggPSBfaW50ZXJjZXB0aW9ucm91dGVzLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pPT5zZWdtZW50LnN0YXJ0c1dpdGgobSkpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gc2VnbWVudC5tYXRjaCgvXFxbKCg/OlxcWy4qXFxdKXwuKylcXF0vKSAvLyBDaGVjayBmb3IgcGFyYW1ldGVyc1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG1hcmtlck1hdGNoICYmIHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShtYXJrZXJNYXRjaCkgKyBcIihbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCByZXBlYXQsIG9wdGlvbmFsIH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCA/IG9wdGlvbmFsID8gXCIoPzovKC4rPykpP1wiIDogXCIvKC4rPylcIiA6IFwiLyhbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkoc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIGdyb3Vwc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSkge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlLCBncm91cHMgfSA9IGdldFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmU6IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIiksXG4gICAgICAgIGdyb3VwczogZ3JvdXBzXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGRzIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsXG4gKiBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqLyBmdW5jdGlvbiBidWlsZEdldFNhZmVSb3V0ZUtleSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGxldCByb3V0ZUtleSA9IFwiXCI7XG4gICAgICAgIGxldCBqID0gKytpO1xuICAgICAgICB3aGlsZShqID4gMCl7XG4gICAgICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGogLSAxKSAlIDI2KTtcbiAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKChqIC0gMSkgLyAyNik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlS2V5O1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQocGFyYW0pIHtcbiAgICBsZXQgeyBpbnRlcmNlcHRpb25NYXJrZXIsIGdldFNhZmVSb3V0ZUtleSwgc2VnbWVudCwgcm91dGVLZXlzLCBrZXlQcmVmaXggfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50KTtcbiAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csIFwiXCIpO1xuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgY2xlYW5lZEtleSA9IFwiXCIgKyBrZXlQcmVmaXggKyBjbGVhbmVkS2V5O1xuICAgIH1cbiAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgIC8vIHNhZmUga2V5XG4gICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgaW52YWxpZEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zbGljZSgwLCAxKSkpKSB7XG4gICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KCk7XG4gICAgfVxuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0gXCJcIiArIGtleVByZWZpeCArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBzZWdtZW50IGhhcyBhbiBpbnRlcmNlcHRpb24gbWFya2VyLCBtYWtlIHN1cmUgdGhhdCdzIHBhcnQgb2YgdGhlIHJlZ2V4IHBhdHRlcm5cbiAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByb3V0ZSB3aXRoIHRoZSBpbnRlcmNlcHRpb24gbWFya2VyIGRvZXNuJ3QgaW5jb3JyZWN0bHkgbWF0Y2hcbiAgICAvLyB0aGUgbm9uLWludGVyY2VwdGVkIHJvdXRlIChpZSAvYXBwLyguKVt1c2VybmFtZV0gc2hvdWxkIG5vdCBtYXRjaCAvYXBwL1t1c2VybmFtZV0pXG4gICAgY29uc3QgaW50ZXJjZXB0aW9uUHJlZml4ID0gaW50ZXJjZXB0aW9uTWFya2VyID8gKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShpbnRlcmNlcHRpb25NYXJrZXIpIDogXCJcIjtcbiAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyBcIig/Oi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KSk/XCIgOiBcIi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KVwiIDogXCIvXCIgKyBpbnRlcmNlcHRpb25QcmVmaXggKyBcIig/PFwiICsgY2xlYW5lZEtleSArIFwiPlteL10rPylcIjtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUocm91dGUsIHByZWZpeFJvdXRlS2V5cykge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gYnVpbGRHZXRTYWZlUm91dGVLZXkoKTtcbiAgICBjb25zdCByb3V0ZUtleXMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaGFzSW50ZXJjZXB0aW9uTWFya2VyID0gX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5zb21lKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHNlZ21lbnQubWF0Y2goL1xcWygoPzpcXFsuKlxcXSl8LispXFxdLykgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25NYXJrZXIgJiYgcGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZWRNYXJrZXJdID0gc2VnbWVudC5zcGxpdChwYXJhbU1hdGNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgICAgICBnZXRTYWZlUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGludGVyY2VwdGlvbk1hcmtlcjogdXNlZE1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogcGFyYW1NYXRjaGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXJhbU1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAga2V5UHJlZml4OiBwcmVmaXhSb3V0ZUtleXMgPyBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICByb3V0ZUtleXNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSxcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyByZXN1bHQubmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIixcbiAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIGNvbnN0IHsgY2F0Y2hBbGwgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmIChwYXJhbWV0ZXJpemVkUm91dGUgPT09IFwiL1wiKSB7XG4gICAgICAgIGxldCBjYXRjaEFsbFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIi4qXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZWRSZWdleDogXCJeL1wiICsgY2F0Y2hBbGxSZWdleCArIFwiJFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgfSA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlLCBmYWxzZSk7XG4gICAgbGV0IGNhdGNoQWxsR3JvdXBlZFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIig/OigvLiopPylcIiA6IFwiXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSArIGNhdGNoQWxsR3JvdXBlZFJlZ2V4ICsgXCIkXCJcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1yZWdleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJnZXRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXgiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJjZXB0aW9ucm91dGVzIiwicmVxdWlyZSIsIl9lc2NhcGVyZWdleHAiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIk5FWFRfUVVFUllfUEFSQU1fUFJFRklYIiwiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsInBhcnNlUGFyYW1ldGVyIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJtYXJrZXJNYXRjaCIsIklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIiwiZmluZCIsIm0iLCJwYXJhbU1hdGNoZXMiLCJtYXRjaCIsInBvcyIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsImpvaW4iLCJub3JtYWxpemVkUm91dGUiLCJyZSIsIlJlZ0V4cCIsImJ1aWxkR2V0U2FmZVJvdXRlS2V5IiwiaSIsInJvdXRlS2V5IiwiaiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIk1hdGgiLCJmbG9vciIsImdldFNhZmVLZXlGcm9tU2VnbWVudCIsImludGVyY2VwdGlvbk1hcmtlciIsImdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5cyIsImtleVByZWZpeCIsImNsZWFuZWRLZXkiLCJyZXBsYWNlIiwiaW52YWxpZEtleSIsImxlbmd0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnRlcmNlcHRpb25QcmVmaXgiLCJnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlIiwicHJlZml4Um91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJoYXNJbnRlcmNlcHRpb25NYXJrZXIiLCJzb21lIiwidXNlZE1hcmtlciIsInVuZGVmaW5lZCIsInByZWZpeFJvdXRlS2V5IiwicmVzdWx0IiwibmFtZWRSZWdleCIsIm9wdGlvbnMiLCJjYXRjaEFsbCIsImNhdGNoQWxsUmVnZXgiLCJjYXRjaEFsbEdyb3VwZWRSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUM7SUFDRkMsT0FBT0MsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDQyxPQUFPLENBQUNELFFBQVFFLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFVBQVUsRUFBRSxFQUFFO0lBQ3pEO0lBQ0FDLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQSxRQUFRQyxNQUFNLEVBQUU7UUFDWixJQUFJQSxXQUFXLEtBQUssR0FBR0EsU0FBUztRQUNoQyxNQUFNQyxnQkFBZ0I7ZUFDZixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUN4QixDQUFDQyxJQUFJO1FBQ04sSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQ3hCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3REO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzVCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3pEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDcENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDM0Q7UUFDQSxNQUFNRyxTQUFTVCxjQUFjVSxHQUFHLENBQUMsQ0FBQ0MsSUFBSSxJQUFJLENBQUNWLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDdUIsR0FBR2IsT0FBTyxDQUFDLEtBQUtDLFNBQVNZLElBQUksTUFBTUMsTUFBTSxDQUFD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RkFBaUY7UUFDakYsSUFBSSxDQUFDLElBQUksQ0FBQ3hCLFFBQVEsQ0FBQ29DLEdBQUcsQ0FBQ1osY0FBYztZQUNqQyxJQUFJLENBQUN4QixRQUFRLENBQUNxQyxHQUFHLENBQUNiLGFBQWEsSUFBSW5DO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDVyxRQUFRLENBQUNiLEdBQUcsQ0FBQ3FDLGFBQWFoQyxPQUFPLENBQUM0QixTQUFTSCxLQUFLLENBQUMsSUFBSUksV0FBV0M7SUFDekU7SUFDQWdCLGFBQWE7UUFDVCxJQUFJLENBQUN2QixXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDZixRQUFRLEdBQUcsSUFBSXVDO1FBQ3BCLElBQUksQ0FBQ3BDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ2hDO0FBQ0o7QUFDQSxTQUFTbkIsZ0JBQWdCb0QsZUFBZTtJQUNwQyxrRkFBa0Y7SUFDbEYsNEVBQTRFO0lBQzVFLDJDQUEyQztJQUMzQyx5RUFBeUU7SUFDekUsMkJBQTJCO0lBQzNCLG9DQUFvQztJQUNwQyw4RUFBOEU7SUFDOUUsd0VBQXdFO0lBQ3hFLGdIQUFnSDtJQUNoSCw0RUFBNEU7SUFDNUUsTUFBTUMsT0FBTyxJQUFJcEQ7SUFDakIsNkZBQTZGO0lBQzdGbUQsZ0JBQWdCUCxPQUFPLENBQUMsQ0FBQ1MsV0FBV0QsS0FBS25ELE1BQU0sQ0FBQ29EO0lBQ2hELDRHQUE0RztJQUM1RyxPQUFPRCxLQUFLN0MsTUFBTTtBQUN0QixFQUVBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3NvcnRlZC1yb3V0ZXMuanM/MmY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNvcnRlZFJvdXRlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U29ydGVkUm91dGVzO1xuICAgIH1cbn0pO1xuY2xhc3MgVXJsTm9kZSB7XG4gICAgaW5zZXJ0KHVybFBhdGgpIHtcbiAgICAgICAgdGhpcy5faW5zZXJ0KHVybFBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKSwgW10sIGZhbHNlKTtcbiAgICB9XG4gICAgc21vb3NoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3NoKCk7XG4gICAgfVxuICAgIF9zbW9vc2gocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgcHJlZml4ID0gXCIvXCI7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aHMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmNoaWxkcmVuLmtleXMoKVxuICAgICAgICBdLnNvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIltdXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIlsuLi5dXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW5QYXRocy5zcGxpY2UoY2hpbGRyZW5QYXRocy5pbmRleE9mKFwiW1suLi5dXVwiKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVzID0gY2hpbGRyZW5QYXRocy5tYXAoKGMpPT50aGlzLmNoaWxkcmVuLmdldChjKS5fc21vb3NoKFwiXCIgKyBwcmVmaXggKyBjICsgXCIvXCIpKS5yZWR1Y2UoKHByZXYsIGN1cnIpPT5bXG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAuLi5jdXJyXG4gICAgICAgICAgICBdLCBbXSk7XG4gICAgICAgIGlmICh0aGlzLnNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldChcIltdXCIpLl9zbW9vc2gocHJlZml4ICsgXCJbXCIgKyB0aGlzLnNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcHJlZml4ID09PSBcIi9cIiA/IFwiL1wiIDogcHJlZml4LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZGVmaW5lIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2l0eSBhcyBhIG9wdGlvbmFsIGNhdGNoLWFsbCByb3V0ZSAoXCInICsgciArICdcIiBhbmQgXCInICsgciArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyAnXV1cIikuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXMudW5zaGlmdChyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiWy4uLl1cIikuX3Ntb29zaChwcmVmaXggKyBcIlsuLi5cIiArIHRoaXMucmVzdFNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiW1suLi5dXVwiKS5fc21vb3NoKHByZWZpeCArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyBcIl1dL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG4gICAgX2luc2VydCh1cmxQYXRocywgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKSB7XG4gICAgICAgIGlmICh1cmxQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYXRjaEFsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0Y2gtYWxsIG11c3QgYmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgVVJMLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV4dCBzZWdtZW50IGluIHRoZSB1cmxQYXRocyBsaXN0XG4gICAgICAgIGxldCBuZXh0U2VnbWVudCA9IHVybFBhdGhzWzBdO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBtYXRjaGVzIGBbc29tZXRoaW5nXWBcbiAgICAgICAgaWYgKG5leHRTZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIG5leHRTZWdtZW50LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgICAgICAgLy8gU3RyaXAgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgbGV0IHNlZ21lbnROYW1lID0gbmV4dFNlZ21lbnQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgbGV0IGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBvcHRpb25hbCBgW2AgYW5kIGBdYCwgbGVhdmluZyBvbmx5IGBzb21ldGhpbmdgXG4gICAgICAgICAgICAgICAgc2VnbWVudE5hbWUgPSBzZWdtZW50TmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGAuLi5gLCBsZWF2aW5nIG9ubHkgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICBzZWdtZW50TmFtZSA9IHNlZ21lbnROYW1lLnN1YnN0cmluZygzKTtcbiAgICAgICAgICAgICAgICBpc0NhdGNoQWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSB8fCBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgb3IgZW5kIHdpdGggZXh0cmEgYnJhY2tldHMgKCdcIiArIHNlZ21lbnROYW1lICsgXCInKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgd2l0aCBlcnJvbmVvdXMgcGVyaW9kcyAoJ1wiICsgc2VnbWVudE5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNsdWcocHJldmlvdXNTbHVnLCBuZXh0U2x1Zykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NsdWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmljIHNlZ21lbnQgYWxyZWFkeSBoYXMgYSBzbHVnIGJ1dCB0aGUgc2x1ZyBpcyBub3QgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjb2xsaXNpb25zIGxpa2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2VzL1twb3N0XS9pbmRleC5qc1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlcy9baWRdL2luZGV4LmpzXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgY3VycmVudGx5IG11bHRpcGxlIGR5bmFtaWMgcGFyYW1zIG9uIHRoZSBzYW1lIHNlZ21lbnQgbGV2ZWwgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2x1ZyAhPT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3Igc2VlbXMgdG8gYmUgY29uZnVzaW5nIGZvciB1c2VycywgbmVlZHMgYW4gZXJyb3IgbGluaywgdGhlIGRlc2NyaXB0aW9uIGNhbiBiZSBiYXNlZCBvbiBhYm92ZSBjb21tZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB1c2UgZGlmZmVyZW50IHNsdWcgbmFtZXMgZm9yIHRoZSBzYW1lIGR5bmFtaWMgcGF0aCAoJ1wiICsgcHJldmlvdXNTbHVnICsgXCInICE9PSAnXCIgKyBuZXh0U2x1ZyArIFwiJykuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5mb3JFYWNoKChzbHVnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2x1ZyA9PT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBoYXZlIHRoZSBzYW1lIHNsdWcgbmFtZSBcIicgKyBuZXh0U2x1ZyArICdcIiByZXBlYXQgd2l0aGluIGEgc2luZ2xlIGR5bmFtaWMgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbHVnLnJlcGxhY2UoL1xcVy9nLCBcIlwiKSA9PT0gbmV4dFNlZ21lbnQucmVwbGFjZSgvXFxXL2csIFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2x1ZyBuYW1lcyBcIicgKyBzbHVnICsgJ1wiIGFuZCBcIicgKyBuZXh0U2x1ZyArICdcIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5wdXNoKG5leHRTbHVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBhbiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsIChcIlsuLi4nICsgdGhpcy5yZXN0U2x1Z05hbWUgKyAnXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIiApLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgPSBzZWdtZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW1suLi5dXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbWy4uLl1dXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGFuIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBjYXRjaC1hbGwgcm91dGUgYXQgdGhlIHNhbWUgbGV2ZWwgKFwiW1suLi4nICsgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSArICddXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2x1Zyh0aGlzLnJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFsuLi5dIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBcIlsuLi5dXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbmFsIHJvdXRlIHBhcmFtZXRlcnMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIChcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5zbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcbiAgICAgICAgICAgICAgICB0aGlzLnNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW10gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgVXJsTm9kZSBkb2Vzbid0IGhhdmUgdGhlIG5leHRTZWdtZW50IHlldCB3ZSBjcmVhdGUgYSBuZXcgY2hpbGQgVXJsTm9kZVxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4uaGFzKG5leHRTZWdtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQobmV4dFNlZ21lbnQsIG5ldyBVcmxOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZ2V0KG5leHRTZWdtZW50KS5faW5zZXJ0KHVybFBhdGhzLnNsaWNlKDEpLCBzbHVnTmFtZXMsIGlzQ2F0Y2hBbGwpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zbHVnTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U29ydGVkUm91dGVzKG5vcm1hbGl6ZWRQYWdlcykge1xuICAgIC8vIEZpcnN0IHRoZSBVcmxOb2RlIGlzIGNyZWF0ZWQsIGFuZCBldmVyeSBVcmxOb2RlIGNhbiBoYXZlIG9ubHkgMSBkeW5hbWljIHNlZ21lbnRcbiAgICAvLyBFZyB5b3UgY2FuJ3QgaGF2ZSBwYWdlcy9bcG9zdF0vYWJjLmpzIGFuZCBwYWdlcy9baGVsbG9dL3NvbWV0aGluZy1lbHNlLmpzXG4gICAgLy8gT25seSAxIGR5bmFtaWMgc2VnbWVudCBwZXIgbmVzdGluZyBsZXZlbFxuICAgIC8vIFNvIGluIHRoZSBjYXNlIHRoYXQgaXMgdGVzdC9pbnRlZ3JhdGlvbi9keW5hbWljLXJvdXRpbmcgaXQnbGwgYmUgdGhpczpcbiAgICAvLyBwYWdlcy9bcG9zdF0vY29tbWVudHMuanNcbiAgICAvLyBwYWdlcy9ibG9nL1twb3N0XS9jb21tZW50L1tpZF0uanNcbiAgICAvLyBCb3RoIGFyZSBmaW5lIGJlY2F1c2UgYHBhZ2VzL1twb3N0XWAgYW5kIGBwYWdlcy9ibG9nYCBhcmUgb24gdGhlIHNhbWUgbGV2ZWxcbiAgICAvLyBTbyBpbiB0aGlzIGNhc2UgYFVybE5vZGVgIGNyZWF0ZWQgaGVyZSBoYXMgYHRoaXMuc2x1Z05hbWUgPT09ICdwb3N0J2BcbiAgICAvLyBBbmQgc2luY2UgeW91ciBQUiBwYXNzZWQgdGhyb3VnaCBgc2x1Z05hbWVgIGFzIGFuIGFycmF5IGJhc2ljYWxseSBpdCdkIGluY2x1ZGluZyBpdCBpbiB0b28gbWFueSBwb3NzaWJpbGl0aWVzXG4gICAgLy8gSW5zdGVhZCB3aGF0IGhhcyB0byBiZSBwYXNzZWQgdGhyb3VnaCBpcyB0aGUgdXB3YXJkcyBwYXRoJ3MgZHluYW1pYyBuYW1lc1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgVXJsTm9kZSgpO1xuICAgIC8vIEhlcmUgdGhlIGByb290YCBnZXRzIGluamVjdGVkIG11bHRpcGxlIHBhdGhzLCBhbmQgaW5zZXJ0IHdpbGwgYnJlYWsgdGhlbSB1cCBpbnRvIHN1YmxldmVsc1xuICAgIG5vcm1hbGl6ZWRQYWdlcy5mb3JFYWNoKChwYWdlUGF0aCk9PnJvb3QuaW5zZXJ0KHBhZ2VQYXRoKSk7XG4gICAgLy8gU21vb3NoIHdpbGwgdGhlbiBzb3J0IHRob3NlIHN1YmxldmVscyB1cCB0byB0aGUgcG9pbnQgd2hlcmUgeW91IGdldCB0aGUgY29ycmVjdCByb3V0ZSBkZWZpbml0aW9uIHByaW9yaXR5XG4gICAgcmV0dXJuIHJvb3Quc21vb3NoKCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRlZC1yb3V0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldFNvcnRlZFJvdXRlcyIsIlVybE5vZGUiLCJpbnNlcnQiLCJ1cmxQYXRoIiwiX2luc2VydCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNtb29zaCIsIl9zbW9vc2giLCJwcmVmaXgiLCJjaGlsZHJlblBhdGhzIiwiY2hpbGRyZW4iLCJrZXlzIiwic29ydCIsInNsdWdOYW1lIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwicm91dGVzIiwibWFwIiwiYyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwicHVzaCIsInBsYWNlaG9sZGVyIiwiciIsInNsaWNlIiwiRXJyb3IiLCJ1bnNoaWZ0IiwidXJsUGF0aHMiLCJzbHVnTmFtZXMiLCJpc0NhdGNoQWxsIiwibGVuZ3RoIiwibmV4dFNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzZWdtZW50TmFtZSIsImlzT3B0aW9uYWwiLCJzdWJzdHJpbmciLCJoYW5kbGVTbHVnIiwicHJldmlvdXNTbHVnIiwibmV4dFNsdWciLCJmb3JFYWNoIiwic2x1ZyIsInJlcGxhY2UiLCJoYXMiLCJzZXQiLCJjb25zdHJ1Y3RvciIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    DecodeError: function() {\n        return DecodeError;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQWtCTjtBQUNBLFNBQVNrQixRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJeEIsT0FBT0MsY0FBYyxDQUFDc0IsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRcEIsU0FBUztJQUNiRyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtJQUNBQyxVQUFVO1FBQ04sT0FBT0E7SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsMEJBQTBCO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLG1CQUFtQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWhCLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLFNBQVNzQixFQUFFO0lBQ2hCLElBQUlD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QUFFO1lBQzdDVSxRQUFRQyxJQUFJLENBQUMsS0FBSzdELGVBQWVpRCxPQUFPO1FBQzVDO0lBQ0o7SUFDQSxPQUFPUztBQUNYO0FBQ0EsTUFBTXRELEtBQUssT0FBTzBELGdCQUFnQjtBQUNsQyxNQUFNekQsS0FBS0QsTUFBTTtJQUNiO0lBQ0E7SUFDQTtDQUNILENBQUMyRCxLQUFLLENBQUMsQ0FBQ0MsU0FBUyxPQUFPRixXQUFXLENBQUNFLE9BQU8sS0FBSztBQUNqRCxNQUFNMUQsb0JBQW9Ca0Q7QUFDMUI7QUFDQSxNQUFNakQsdUJBQXVCaUQ7QUFDN0I7QUFDQSxNQUFNaEQsMEJBQTBCZ0Q7SUFDNUJTLFlBQVlDLElBQUksQ0FBQztRQUNiLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3BELElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3dDLE9BQU8sR0FBRyxrQ0FBa0NXO0lBQ3JEO0FBQ0o7QUFDQSxNQUFNekQsMEJBQTBCK0M7SUFDNUJTLFlBQVlDLElBQUksRUFBRVgsT0FBTyxDQUFDO1FBQ3RCLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBRywwQ0FBMENXLE9BQU8sTUFBTVg7SUFDMUU7QUFDSjtBQUNBLE1BQU03QyxnQ0FBZ0M4QztJQUNsQ1MsYUFBYTtRQUNULEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1osT0FBTyxHQUFHO0lBQ25CO0FBQ0o7QUFDQSxTQUFTNUMsZUFBZXlELEtBQUs7SUFDekIsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQ2xCZixTQUFTYSxNQUFNYixPQUFPO1FBQ3RCZ0IsT0FBT0gsTUFBTUcsS0FBSztJQUN0QjtBQUNKLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcz9lN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgV0VCX1ZJVEFMUzogbnVsbCxcbiAgICBleGVjT25jZTogbnVsbCxcbiAgICBpc0Fic29sdXRlVXJsOiBudWxsLFxuICAgIGdldExvY2F0aW9uT3JpZ2luOiBudWxsLFxuICAgIGdldFVSTDogbnVsbCxcbiAgICBnZXREaXNwbGF5TmFtZTogbnVsbCxcbiAgICBpc1Jlc1NlbnQ6IG51bGwsXG4gICAgbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzOiBudWxsLFxuICAgIGxvYWRHZXRJbml0aWFsUHJvcHM6IG51bGwsXG4gICAgU1A6IG51bGwsXG4gICAgU1Q6IG51bGwsXG4gICAgRGVjb2RlRXJyb3I6IG51bGwsXG4gICAgTm9ybWFsaXplRXJyb3I6IG51bGwsXG4gICAgUGFnZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgTWlzc2luZ1N0YXRpY1BhZ2U6IG51bGwsXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgc3RyaW5naWZ5RXJyb3I6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgV0VCX1ZJVEFMUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJfVklUQUxTO1xuICAgIH0sXG4gICAgZXhlY09uY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXhlY09uY2U7XG4gICAgfSxcbiAgICBpc0Fic29sdXRlVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGVVcmw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbk9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2NhdGlvbk9yaWdpbjtcbiAgICB9LFxuICAgIGdldFVSTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRVUkw7XG4gICAgfSxcbiAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZTtcbiAgICB9LFxuICAgIGlzUmVzU2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1Jlc1NlbnQ7XG4gICAgfSxcbiAgICBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzO1xuICAgIH0sXG4gICAgbG9hZEdldEluaXRpYWxQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzO1xuICAgIH0sXG4gICAgU1A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1A7XG4gICAgfSxcbiAgICBTVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTVDtcbiAgICB9LFxuICAgIERlY29kZUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERlY29kZUVycm9yO1xuICAgIH0sXG4gICAgTm9ybWFsaXplRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTm9ybWFsaXplRXJyb3I7XG4gICAgfSxcbiAgICBQYWdlTm90Rm91bmRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYWdlTm90Rm91bmRFcnJvcjtcbiAgICB9LFxuICAgIE1pc3NpbmdTdGF0aWNQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1pc3NpbmdTdGF0aWNQYWdlO1xuICAgIH0sXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I7XG4gICAgfSxcbiAgICBzdHJpbmdpZnlFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgXCJDTFNcIixcbiAgICBcIkZDUFwiLFxuICAgIFwiRklEXCIsXG4gICAgXCJJTlBcIixcbiAgICBcIkxDUFwiLFxuICAgIFwiVFRGQlwiXG5dO1xuZnVuY3Rpb24gZXhlY09uY2UoZm4pIHtcbiAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG5jb25zdCBpc0Fic29sdXRlVXJsID0gKHVybCk9PkFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybCk7XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiVW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF07XG4gICAgcmV0dXJuIHVybE5vUXVlcnkvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcbiAgICAvLyB0aGVuIG5vcm1hbGl6ZSByZXBlYXRlZCBmb3J3YXJkIHNsYXNoZXNcbiAgICAucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIikgKyAodXJsUGFydHNbMV0gPyBcIj9cIiArIHVybFBhcnRzLnNsaWNlKDEpLmpvaW4oXCI/XCIpIDogXCJcIik7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YXIgX0FwcF9wcm90b3R5cGU7XG4gICAgICAgIGlmICgoX0FwcF9wcm90b3R5cGUgPSBBcHAucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX0FwcF9wcm90b3R5cGUuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1wiJyArIGdldERpc3BsYXlOYW1lKEFwcCkgKyAnLmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpO1xuICAgIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnXCInICsgZ2V0RGlzcGxheU5hbWUoQXBwKSArICcuZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIicgKyBwcm9wcyArICdcIiBpbnN0ZWFkLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyBnZXREaXNwbGF5TmFtZShBcHApICsgXCIgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gYGdldEluaXRpYWxQcm9wc2AuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5jb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IFNUID0gU1AgJiYgW1xuICAgIFwibWFya1wiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwiZ2V0RW50cmllc0J5TmFtZVwiXG5dLmV2ZXJ5KChtZXRob2QpPT50eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKTtcbmNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuY2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBQYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQYWdlTm90Rm91bmRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogXCIgKyBwYWdlO1xuICAgIH1cbn1cbmNsYXNzIE1pc3NpbmdTdGF0aWNQYWdlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhZ2UsIG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiBcIiArIHBhZ2UgKyBcIiBcIiArIG1lc3NhZ2U7XG4gICAgfVxufVxuY2xhc3MgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJDYW5ub3QgZmluZCB0aGUgbWlkZGxld2FyZSBtb2R1bGVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJXRUJfVklUQUxTIiwiZXhlY09uY2UiLCJpc0Fic29sdXRlVXJsIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJTUCIsIlNUIiwiRGVjb2RlRXJyb3IiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJNaWRkbGV3YXJlTm90Rm91bmRFcnJvciIsInN0cmluZ2lmeUVycm9yIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ1cmwiLCJ0ZXN0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsInBvcnQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiX0FwcF9wcm90b3R5cGUiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Dancing_Script\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-signature\",\"display\":\"swap\"}],\"variableName\":\"signature\"}":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.js","import":"Dancing_Script","arguments":[{"subsets":["latin"],"variable":"--font-signature","display":"swap"}],"variableName":"signature"} ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Dancing_Script_b75cb0', '__Dancing_Script_Fallback_b75cb0'\",\"fontStyle\":\"normal\"},\"className\":\"__className_b75cb0\",\"variable\":\"__variable_b75cb0\"};\n    if(true) {\n      // 1771342262873\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC5qc1wiLFwiaW1wb3J0XCI6XCJEYW5jaW5nX1NjcmlwdFwiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXSxcInZhcmlhYmxlXCI6XCItLWZvbnQtc2lnbmF0dXJlXCIsXCJkaXNwbGF5XCI6XCJzd2FwXCJ9XSxcInZhcmlhYmxlTmFtZVwiOlwic2lnbmF0dXJlXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsa0dBQWtHO0FBQzdILE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUFtSSxjQUFjLHNEQUFzRDtBQUNyTyxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/MjZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInX19EYW5jaW5nX1NjcmlwdF9iNzVjYjAnLCAnX19EYW5jaW5nX1NjcmlwdF9GYWxsYmFja19iNzVjYjAnXCIsXCJmb250U3R5bGVcIjpcIm5vcm1hbFwifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfYjc1Y2IwXCIsXCJ2YXJpYWJsZVwiOlwiX192YXJpYWJsZV9iNzVjYjBcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTc3MTM0MjI2Mjg3M1xuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9VU0VSL0Rvd25sb2Fkcy9wb3QvYnVzLXRyYW5zcG9ydC1hcHAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Dancing_Script\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-signature\",\"display\":\"swap\"}],\"variableName\":\"signature\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Manrope\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-body\",\"display\":\"swap\"}],\"variableName\":\"manrope\"}":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.js","import":"Manrope","arguments":[{"subsets":["latin"],"variable":"--font-body","display":"swap"}],"variableName":"manrope"} ***!
  \******************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Manrope_73ee6c', '__Manrope_Fallback_73ee6c'\",\"fontStyle\":\"normal\"},\"className\":\"__className_73ee6c\",\"variable\":\"__variable_73ee6c\"};\n    if(true) {\n      // 1771342262869\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC5qc1wiLFwiaW1wb3J0XCI6XCJNYW5yb3BlXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdLFwidmFyaWFibGVcIjpcIi0tZm9udC1ib2R5XCIsXCJkaXNwbGF5XCI6XCJzd2FwXCJ9XSxcInZhcmlhYmxlTmFtZVwiOlwibWFucm9wZVwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLG9GQUFvRjtBQUMvRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3TUFBbUksY0FBYyxzREFBc0Q7QUFDck8sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzPzYzMDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fTWFucm9wZV83M2VlNmMnLCAnX19NYW5yb3BlX0ZhbGxiYWNrXzczZWU2YydcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV83M2VlNmNcIixcInZhcmlhYmxlXCI6XCJfX3ZhcmlhYmxlXzczZWU2Y1wifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzcxMzQyMjYyODY5XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzL1VTRVIvRG93bmxvYWRzL3BvdC9idXMtdHJhbnNwb3J0LWFwcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Manrope\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-body\",\"display\":\"swap\"}],\"variableName\":\"manrope\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Space_Grotesk\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-heading\",\"display\":\"swap\"}],\"variableName\":\"spaceGrotesk\"}":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.js","import":"Space_Grotesk","arguments":[{"subsets":["latin"],"variable":"--font-heading","display":"swap"}],"variableName":"spaceGrotesk"} ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Space_Grotesk_dd5b2f', '__Space_Grotesk_Fallback_dd5b2f'\",\"fontStyle\":\"normal\"},\"className\":\"__className_dd5b2f\",\"variable\":\"__variable_dd5b2f\"};\n    if(true) {\n      // 1771342262865\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC5qc1wiLFwiaW1wb3J0XCI6XCJTcGFjZV9Hcm90ZXNrXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdLFwidmFyaWFibGVcIjpcIi0tZm9udC1oZWFkaW5nXCIsXCJkaXNwbGF5XCI6XCJzd2FwXCJ9XSxcInZhcmlhYmxlTmFtZVwiOlwic3BhY2VHcm90ZXNrXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsZ0dBQWdHO0FBQzNILE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUFtSSxjQUFjLHNEQUFzRDtBQUNyTyxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/YTM3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInX19TcGFjZV9Hcm90ZXNrX2RkNWIyZicsICdfX1NwYWNlX0dyb3Rlc2tfRmFsbGJhY2tfZGQ1YjJmJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2RkNWIyZlwiLFwidmFyaWFibGVcIjpcIl9fdmFyaWFibGVfZGQ1YjJmXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NzEzNDIyNjI4NjVcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvVVNFUi9Eb3dubG9hZHMvcG90L2J1cy10cmFuc3BvcnQtYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.js\",\"import\":\"Space_Grotesk\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-heading\",\"display\":\"swap\"}],\"variableName\":\"spaceGrotesk\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/core/Camera.js":
/*!*********************************************!*\
  !*** ./node_modules/ogl/src/core/Camera.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: function() { return /* binding */ Camera; }\n/* harmony export */ });\n/* harmony import */ var _Transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transform.js */ \"(app-pages-browser)/./node_modules/ogl/src/core/Transform.js\");\n/* harmony import */ var _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Mat4.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Mat4.js\");\n/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vec3.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Vec3.js\");\n\n\n\nconst tempMat4 = /* @__PURE__ */ new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst tempVec3a = /* @__PURE__ */ new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst tempVec3b = /* @__PURE__ */ new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nclass Camera extends _Transform_js__WEBPACK_IMPORTED_MODULE_2__.Transform {\n    perspective() {\n        let { near = this.near, far = this.far, fov = this.fov, aspect = this.aspect } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        Object.assign(this, {\n            near,\n            far,\n            fov,\n            aspect\n        });\n        this.projectionMatrix.fromPerspective({\n            fov: fov * (Math.PI / 180),\n            aspect,\n            near,\n            far\n        });\n        this.type = \"perspective\";\n        return this;\n    }\n    orthographic() {\n        let { near = this.near, far = this.far, left = this.left || -1, right = this.right || 1, bottom = this.bottom || -1, top = this.top || 1, zoom = this.zoom } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        Object.assign(this, {\n            near,\n            far,\n            left,\n            right,\n            bottom,\n            top,\n            zoom\n        });\n        left /= zoom;\n        right /= zoom;\n        bottom /= zoom;\n        top /= zoom;\n        this.projectionMatrix.fromOrthogonal({\n            left,\n            right,\n            bottom,\n            top,\n            near,\n            far\n        });\n        this.type = \"orthographic\";\n        return this;\n    }\n    updateMatrixWorld() {\n        super.updateMatrixWorld();\n        this.viewMatrix.inverse(this.worldMatrix);\n        this.worldMatrix.getTranslation(this.worldPosition);\n        // used for sorting\n        this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);\n        return this;\n    }\n    updateProjectionMatrix() {\n        if (this.type === \"perspective\") {\n            return this.perspective();\n        } else {\n            return this.orthographic();\n        }\n    }\n    lookAt(target) {\n        super.lookAt(target, true);\n        return this;\n    }\n    // Project 3D coordinate to 2D point\n    project(v) {\n        v.applyMatrix4(this.viewMatrix);\n        v.applyMatrix4(this.projectionMatrix);\n        return this;\n    }\n    // Unproject 2D point to 3D coordinate\n    unproject(v) {\n        v.applyMatrix4(tempMat4.inverse(this.projectionMatrix));\n        v.applyMatrix4(this.worldMatrix);\n        return this;\n    }\n    updateFrustum() {\n        if (!this.frustum) {\n            this.frustum = [\n                new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(),\n                new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(),\n                new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(),\n                new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(),\n                new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(),\n                new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()\n            ];\n        }\n        const m = this.projectionViewMatrix;\n        this.frustum[0].set(m[3] - m[0], m[7] - m[4], m[11] - m[8]).constant = m[15] - m[12]; // -x\n        this.frustum[1].set(m[3] + m[0], m[7] + m[4], m[11] + m[8]).constant = m[15] + m[12]; // +x\n        this.frustum[2].set(m[3] + m[1], m[7] + m[5], m[11] + m[9]).constant = m[15] + m[13]; // +y\n        this.frustum[3].set(m[3] - m[1], m[7] - m[5], m[11] - m[9]).constant = m[15] - m[13]; // -y\n        this.frustum[4].set(m[3] - m[2], m[7] - m[6], m[11] - m[10]).constant = m[15] - m[14]; // +z (far)\n        this.frustum[5].set(m[3] + m[2], m[7] + m[6], m[11] + m[10]).constant = m[15] + m[14]; // -z (near)\n        for(let i = 0; i < 6; i++){\n            const invLen = 1.0 / this.frustum[i].distance();\n            this.frustum[i].multiply(invLen);\n            this.frustum[i].constant *= invLen;\n        }\n    }\n    frustumIntersectsMesh(node) {\n        let worldMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node.worldMatrix;\n        // If no position attribute, treat as frustumCulled false\n        if (!node.geometry.attributes.position) return true;\n        if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity) node.geometry.computeBoundingSphere();\n        if (!node.geometry.bounds) return true;\n        const center = tempVec3a;\n        center.copy(node.geometry.bounds.center);\n        center.applyMatrix4(worldMatrix);\n        const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();\n        return this.frustumIntersectsSphere(center, radius);\n    }\n    frustumIntersectsSphere(center, radius) {\n        const normal = tempVec3b;\n        for(let i = 0; i < 6; i++){\n            const plane = this.frustum[i];\n            const distance = normal.copy(plane).dot(center) + plane.constant;\n            if (distance < -radius) return false;\n        }\n        return true;\n    }\n    constructor(gl, { near = 0.1, far = 100, fov = 45, aspect = 1, left, right, bottom, top, zoom = 1 } = {}){\n        super();\n        Object.assign(this, {\n            near,\n            far,\n            fov,\n            aspect,\n            left,\n            right,\n            bottom,\n            top,\n            zoom\n        });\n        this.projectionMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n        this.viewMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n        this.projectionViewMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n        this.worldPosition = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n        // Use orthographic if left/right set, else default to perspective camera\n        this.type = left || right ? \"orthographic\" : \"perspective\";\n        if (this.type === \"orthographic\") this.orthographic();\n        else this.perspective();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvQ2FtZXJhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkM7QUFDSjtBQUNBO0FBRXZDLE1BQU1HLFdBQVcsYUFBYSxHQUFHLElBQUlGLCtDQUFJQTtBQUN6QyxNQUFNRyxZQUFZLGFBQWEsR0FBRyxJQUFJRiwrQ0FBSUE7QUFDMUMsTUFBTUcsWUFBWSxhQUFhLEdBQUcsSUFBSUgsK0NBQUlBO0FBRW5DLE1BQU1JLGVBQWVOLG9EQUFTQTtJQWtCakNPLGNBQTZGO1lBQWpGLEVBQUVDLE9BQU8sSUFBSSxDQUFDQSxJQUFJLEVBQUVDLE1BQU0sSUFBSSxDQUFDQSxHQUFHLEVBQUVDLE1BQU0sSUFBSSxDQUFDQSxHQUFHLEVBQUVDLFNBQVMsSUFBSSxDQUFDQSxNQUFNLEVBQUUsR0FBMUUsaUVBQTZFLENBQUM7UUFDdEZDLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFBRUw7WUFBTUM7WUFBS0M7WUFBS0M7UUFBTztRQUM3QyxJQUFJLENBQUNHLGdCQUFnQixDQUFDQyxlQUFlLENBQUM7WUFBRUwsS0FBS0EsTUFBT00sQ0FBQUEsS0FBS0MsRUFBRSxHQUFHLEdBQUU7WUFBSU47WUFBUUg7WUFBTUM7UUFBSTtRQUN0RixJQUFJLENBQUNTLElBQUksR0FBRztRQUNaLE9BQU8sSUFBSTtJQUNmO0lBRUFDLGVBUVE7WUFSSyxFQUNUWCxPQUFPLElBQUksQ0FBQ0EsSUFBSSxFQUNoQkMsTUFBTSxJQUFJLENBQUNBLEdBQUcsRUFDZFcsT0FBTyxJQUFJLENBQUNBLElBQUksSUFBSSxDQUFDLENBQUMsRUFDdEJDLFFBQVEsSUFBSSxDQUFDQSxLQUFLLElBQUksQ0FBQyxFQUN2QkMsU0FBUyxJQUFJLENBQUNBLE1BQU0sSUFBSSxDQUFDLENBQUMsRUFDMUJDLE1BQU0sSUFBSSxDQUFDQSxHQUFHLElBQUksQ0FBQyxFQUNuQkMsT0FBTyxJQUFJLENBQUNBLElBQUksRUFDbkIsR0FSWSxp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TyxRQUFRLE9BQU87UUFDbkM7UUFDQSxPQUFPO0lBQ1g7SUE5SEFVLFlBQVlDLEVBQUUsRUFBRSxFQUFFMUQsT0FBTyxHQUFHLEVBQUVDLE1BQU0sR0FBRyxFQUFFQyxNQUFNLEVBQUUsRUFBRUMsU0FBUyxDQUFDLEVBQUVTLElBQUksRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN0RyxLQUFLO1FBRUxaLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFBRUw7WUFBTUM7WUFBS0M7WUFBS0M7WUFBUVM7WUFBTUM7WUFBT0M7WUFBUUM7WUFBS0M7UUFBSztRQUU3RSxJQUFJLENBQUNWLGdCQUFnQixHQUFHLElBQUliLCtDQUFJQTtRQUNoQyxJQUFJLENBQUMwQixVQUFVLEdBQUcsSUFBSTFCLCtDQUFJQTtRQUMxQixJQUFJLENBQUMrQixvQkFBb0IsR0FBRyxJQUFJL0IsK0NBQUlBO1FBQ3BDLElBQUksQ0FBQzhCLGFBQWEsR0FBRyxJQUFJN0IsK0NBQUlBO1FBRTdCLHlFQUF5RTtRQUN6RSxJQUFJLENBQUNnQixJQUFJLEdBQUdFLFFBQVFDLFFBQVEsaUJBQWlCO1FBRTdDLElBQUksSUFBSSxDQUFDSCxJQUFJLEtBQUssZ0JBQWdCLElBQUksQ0FBQ0MsWUFBWTthQUM5QyxJQUFJLENBQUNaLFdBQVc7SUFDekI7QUFnSEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvY29yZS9DYW1lcmEuanM/ZTEyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL1RyYW5zZm9ybS5qcyc7XG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSAnLi4vbWF0aC9NYXQ0LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuXG5jb25zdCB0ZW1wTWF0NCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWF0NCgpO1xuY29uc3QgdGVtcFZlYzNhID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWMzKCk7XG5jb25zdCB0ZW1wVmVjM2IgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlYzMoKTtcblxuZXhwb3J0IGNsYXNzIENhbWVyYSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoZ2wsIHsgbmVhciA9IDAuMSwgZmFyID0gMTAwLCBmb3YgPSA0NSwgYXNwZWN0ID0gMSwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6b29tID0gMSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgbmVhciwgZmFyLCBmb3YsIGFzcGVjdCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6b29tIH0pO1xuXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXQ0KCk7XG4gICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBNYXQ0KCk7XG4gICAgICAgIHRoaXMucHJvamVjdGlvblZpZXdNYXRyaXggPSBuZXcgTWF0NCgpO1xuICAgICAgICB0aGlzLndvcmxkUG9zaXRpb24gPSBuZXcgVmVjMygpO1xuXG4gICAgICAgIC8vIFVzZSBvcnRob2dyYXBoaWMgaWYgbGVmdC9yaWdodCBzZXQsIGVsc2UgZGVmYXVsdCB0byBwZXJzcGVjdGl2ZSBjYW1lcmFcbiAgICAgICAgdGhpcy50eXBlID0gbGVmdCB8fCByaWdodCA/ICdvcnRob2dyYXBoaWMnIDogJ3BlcnNwZWN0aXZlJztcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnb3J0aG9ncmFwaGljJykgdGhpcy5vcnRob2dyYXBoaWMoKTtcbiAgICAgICAgZWxzZSB0aGlzLnBlcnNwZWN0aXZlKCk7XG4gICAgfVxuXG4gICAgcGVyc3BlY3RpdmUoeyBuZWFyID0gdGhpcy5uZWFyLCBmYXIgPSB0aGlzLmZhciwgZm92ID0gdGhpcy5mb3YsIGFzcGVjdCA9IHRoaXMuYXNwZWN0IH0gPSB7fSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgbmVhciwgZmFyLCBmb3YsIGFzcGVjdCB9KTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4LmZyb21QZXJzcGVjdGl2ZSh7IGZvdjogZm92ICogKE1hdGguUEkgLyAxODApLCBhc3BlY3QsIG5lYXIsIGZhciB9KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BlcnNwZWN0aXZlJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3J0aG9ncmFwaGljKHtcbiAgICAgICAgbmVhciA9IHRoaXMubmVhcixcbiAgICAgICAgZmFyID0gdGhpcy5mYXIsXG4gICAgICAgIGxlZnQgPSB0aGlzLmxlZnQgfHwgLTEsXG4gICAgICAgIHJpZ2h0ID0gdGhpcy5yaWdodCB8fCAxLFxuICAgICAgICBib3R0b20gPSB0aGlzLmJvdHRvbSB8fCAtMSxcbiAgICAgICAgdG9wID0gdGhpcy50b3AgfHwgMSxcbiAgICAgICAgem9vbSA9IHRoaXMuem9vbSxcbiAgICB9ID0ge30pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IG5lYXIsIGZhciwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6b29tIH0pO1xuICAgICAgICBsZWZ0IC89IHpvb207XG4gICAgICAgIHJpZ2h0IC89IHpvb207XG4gICAgICAgIGJvdHRvbSAvPSB6b29tO1xuICAgICAgICB0b3AgLz0gem9vbTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4LmZyb21PcnRob2dvbmFsKHsgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgfSk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdvcnRob2dyYXBoaWMnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGVNYXRyaXhXb3JsZCgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgdGhpcy52aWV3TWF0cml4LmludmVyc2UodGhpcy53b3JsZE1hdHJpeCk7XG4gICAgICAgIHRoaXMud29ybGRNYXRyaXguZ2V0VHJhbnNsYXRpb24odGhpcy53b3JsZFBvc2l0aW9uKTtcblxuICAgICAgICAvLyB1c2VkIGZvciBzb3J0aW5nXG4gICAgICAgIHRoaXMucHJvamVjdGlvblZpZXdNYXRyaXgubXVsdGlwbHkodGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAncGVyc3BlY3RpdmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJzcGVjdGl2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3J0aG9ncmFwaGljKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb29rQXQodGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyLmxvb2tBdCh0YXJnZXQsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBQcm9qZWN0IDNEIGNvb3JkaW5hdGUgdG8gMkQgcG9pbnRcbiAgICBwcm9qZWN0KHYpIHtcbiAgICAgICAgdi5hcHBseU1hdHJpeDQodGhpcy52aWV3TWF0cml4KTtcbiAgICAgICAgdi5hcHBseU1hdHJpeDQodGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVW5wcm9qZWN0IDJEIHBvaW50IHRvIDNEIGNvb3JkaW5hdGVcbiAgICB1bnByb2plY3Qodikge1xuICAgICAgICB2LmFwcGx5TWF0cml4NCh0ZW1wTWF0NC5pbnZlcnNlKHRoaXMucHJvamVjdGlvbk1hdHJpeCkpO1xuICAgICAgICB2LmFwcGx5TWF0cml4NCh0aGlzLndvcmxkTWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlRnJ1c3R1bSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZydXN0dW0pIHtcbiAgICAgICAgICAgIHRoaXMuZnJ1c3R1bSA9IFtuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLnByb2plY3Rpb25WaWV3TWF0cml4O1xuICAgICAgICB0aGlzLmZydXN0dW1bMF0uc2V0KG1bM10gLSBtWzBdLCBtWzddIC0gbVs0XSwgbVsxMV0gLSBtWzhdKS5jb25zdGFudCA9IG1bMTVdIC0gbVsxMl07IC8vIC14XG4gICAgICAgIHRoaXMuZnJ1c3R1bVsxXS5zZXQobVszXSArIG1bMF0sIG1bN10gKyBtWzRdLCBtWzExXSArIG1bOF0pLmNvbnN0YW50ID0gbVsxNV0gKyBtWzEyXTsgLy8gK3hcbiAgICAgICAgdGhpcy5mcnVzdHVtWzJdLnNldChtWzNdICsgbVsxXSwgbVs3XSArIG1bNV0sIG1bMTFdICsgbVs5XSkuY29uc3RhbnQgPSBtWzE1XSArIG1bMTNdOyAvLyAreVxuICAgICAgICB0aGlzLmZydXN0dW1bM10uc2V0KG1bM10gLSBtWzFdLCBtWzddIC0gbVs1XSwgbVsxMV0gLSBtWzldKS5jb25zdGFudCA9IG1bMTVdIC0gbVsxM107IC8vIC15XG4gICAgICAgIHRoaXMuZnJ1c3R1bVs0XS5zZXQobVszXSAtIG1bMl0sIG1bN10gLSBtWzZdLCBtWzExXSAtIG1bMTBdKS5jb25zdGFudCA9IG1bMTVdIC0gbVsxNF07IC8vICt6IChmYXIpXG4gICAgICAgIHRoaXMuZnJ1c3R1bVs1XS5zZXQobVszXSArIG1bMl0sIG1bN10gKyBtWzZdLCBtWzExXSArIG1bMTBdKS5jb25zdGFudCA9IG1bMTVdICsgbVsxNF07IC8vIC16IChuZWFyKVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnZMZW4gPSAxLjAgLyB0aGlzLmZydXN0dW1baV0uZGlzdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZnJ1c3R1bVtpXS5tdWx0aXBseShpbnZMZW4pO1xuICAgICAgICAgICAgdGhpcy5mcnVzdHVtW2ldLmNvbnN0YW50ICo9IGludkxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZydXN0dW1JbnRlcnNlY3RzTWVzaChub2RlLCB3b3JsZE1hdHJpeCA9IG5vZGUud29ybGRNYXRyaXgpIHtcbiAgICAgICAgLy8gSWYgbm8gcG9zaXRpb24gYXR0cmlidXRlLCB0cmVhdCBhcyBmcnVzdHVtQ3VsbGVkIGZhbHNlXG4gICAgICAgIGlmICghbm9kZS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBpZiAoIW5vZGUuZ2VvbWV0cnkuYm91bmRzIHx8IG5vZGUuZ2VvbWV0cnkuYm91bmRzLnJhZGl1cyA9PT0gSW5maW5pdHkpIG5vZGUuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgICAgaWYgKCFub2RlLmdlb21ldHJ5LmJvdW5kcykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY29uc3QgY2VudGVyID0gdGVtcFZlYzNhO1xuICAgICAgICBjZW50ZXIuY29weShub2RlLmdlb21ldHJ5LmJvdW5kcy5jZW50ZXIpO1xuICAgICAgICBjZW50ZXIuYXBwbHlNYXRyaXg0KHdvcmxkTWF0cml4KTtcblxuICAgICAgICBjb25zdCByYWRpdXMgPSBub2RlLmdlb21ldHJ5LmJvdW5kcy5yYWRpdXMgKiB3b3JsZE1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZydXN0dW1JbnRlcnNlY3RzU3BoZXJlKGNlbnRlciwgcmFkaXVzKTtcbiAgICB9XG5cbiAgICBmcnVzdHVtSW50ZXJzZWN0c1NwaGVyZShjZW50ZXIsIHJhZGl1cykge1xuICAgICAgICBjb25zdCBub3JtYWwgPSB0ZW1wVmVjM2I7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBsYW5lID0gdGhpcy5mcnVzdHVtW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBub3JtYWwuY29weShwbGFuZSkuZG90KGNlbnRlcikgKyBwbGFuZS5jb25zdGFudDtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IC1yYWRpdXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtIiwiTWF0NCIsIlZlYzMiLCJ0ZW1wTWF0NCIsInRlbXBWZWMzYSIsInRlbXBWZWMzYiIsIkNhbWVyYSIsInBlcnNwZWN0aXZlIiwibmVhciIsImZhciIsImZvdiIsImFzcGVjdCIsIk9iamVjdCIsImFzc2lnbiIsInByb2plY3Rpb25NYXRyaXgiLCJmcm9tUGVyc3BlY3RpdmUiLCJNYXRoIiwiUEkiLCJ0eXBlIiwib3J0aG9ncmFwaGljIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwiem9vbSIsImZyb21PcnRob2dvbmFsIiwidXBkYXRlTWF0cml4V29ybGQiLCJ2aWV3TWF0cml4IiwiaW52ZXJzZSIsIndvcmxkTWF0cml4IiwiZ2V0VHJhbnNsYXRpb24iLCJ3b3JsZFBvc2l0aW9uIiwicHJvamVjdGlvblZpZXdNYXRyaXgiLCJtdWx0aXBseSIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJsb29rQXQiLCJ0YXJnZXQiLCJwcm9qZWN0IiwidiIsImFwcGx5TWF0cml4NCIsInVucHJvamVjdCIsInVwZGF0ZUZydXN0dW0iLCJmcnVzdHVtIiwibSIsInNldCIsImNvbnN0YW50IiwiaSIsImludkxlbiIsImRpc3RhbmNlIiwiZnJ1c3R1bUludGVyc2VjdHNNZXNoIiwibm9kZSIsImdlb21ldHJ5IiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiYm91bmRzIiwicmFkaXVzIiwiSW5maW5pdHkiLCJjb21wdXRlQm91bmRpbmdTcGhlcmUiLCJjZW50ZXIiLCJjb3B5IiwiZ2V0TWF4U2NhbGVPbkF4aXMiLCJmcnVzdHVtSW50ZXJzZWN0c1NwaGVyZSIsIm5vcm1hbCIsInBsYW5lIiwiZG90IiwiY29uc3RydWN0b3IiLCJnbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/core/Camera.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/core/Geometry.js":
/*!***********************************************!*\
  !*** ./node_modules/ogl/src/core/Geometry.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Geometry: function() { return /* binding */ Geometry; }\n/* harmony export */ });\n/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vec3.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Vec3.js\");\n// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n// TODO: fit in transform feedback\n\nconst tempVec3 = /* @__PURE__ */ new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nlet ID = 1;\nlet ATTR_ID = 1;\n// To stop inifinite warnings\nlet isBoundsWarned = false;\nclass Geometry {\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type = attr.type || (attr.data.constructor === Float32Array ? this.gl.FLOAT : attr.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === \"index\" ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n        attr.usage = attr.usage || this.gl.STATIC_DRAW;\n        if (!attr.buffer) {\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn(\"geometry has multiple instanced buffers of different length\");\n                return this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor);\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === \"index\") {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n    updateAttribute(attr) {\n        const isNewBuffer = !attr.buffer;\n        if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        if (isNewBuffer) {\n            this.gl.bufferData(attr.target, attr.data, attr.usage);\n        } else {\n            this.gl.bufferSubData(attr.target, 0, attr.data);\n        }\n        attr.needsUpdate = false;\n    }\n    setIndex(value) {\n        this.addAttribute(\"index\", value);\n    }\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, param)=>{\n            let { name, type } = param;\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(\"active attribute \".concat(name, \" not being supplied\"));\n                return;\n            }\n            const attr = this.attributes[name];\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n            const offset = numLoc === 1 ? 0 : numLoc * 4;\n            for(let i = 0; i < numLoc; i++){\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n    draw(param) {\n        let { program, mode = this.gl.TRIANGLES } = param;\n        var _this_attributes_index;\n        if (this.gl.renderer.currentGeometry !== \"\".concat(this.id, \"_\").concat(program.attributeOrder)) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = \"\".concat(this.id, \"_\").concat(program.attributeOrder);\n        }\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, param)=>{\n            let { name } = param;\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n        // For drawElements, offset needs to be multiple of type size\n        let indexBytesPerElement = 2;\n        if (((_this_attributes_index = this.attributes.index) === null || _this_attributes_index === void 0 ? void 0 : _this_attributes_index.type) === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * indexBytesPerElement, this.instancedCount);\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * indexBytesPerElement);\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n    getPosition() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        // if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr;\n        if (isBoundsWarned) return;\n        console.warn(\"No position buffer data found to compute bounds\");\n        return isBoundsWarned = true;\n    }\n    computeBoundingBox(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n        if (!this.bounds) {\n            this.bounds = {\n                min: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(),\n                max: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(),\n                center: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(),\n                scale: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(),\n                radius: Infinity\n            };\n        }\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n        min.set(+Infinity);\n        max.set(-Infinity);\n        // TODO: check size of position (eg triangle with Vec2)\n        for(let i = 0, l = array.length; i < l; i += stride){\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n    computeBoundingSphere(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n        if (!this.bounds) this.computeBoundingBox(attr);\n        let maxRadiusSq = 0;\n        for(let i = 0, l = array.length; i < l; i += stride){\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n    remove() {\n        for(let key in this.VAOs){\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n            delete this.VAOs[key];\n        }\n        for(let key in this.attributes){\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n    constructor(gl, attributes = {}){\n        if (!gl.canvas) console.error(\"gl not passed as first argument to Geometry\");\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n        this.drawRange = {\n            start: 0,\n            count: 0\n        };\n        this.instancedCount = 0;\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n        // create the buffers\n        for(let key in attributes){\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvR2VvbWV0cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxtQkFBbUI7QUFDbkIsSUFBSTtBQUNKLGtFQUFrRTtBQUNsRSwyQkFBMkI7QUFDM0Isb0RBQW9EO0FBQ3BELGdGQUFnRjtBQUNoRix5Q0FBeUM7QUFFekMsNkhBQTZIO0FBQzdILHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsd0RBQXdEO0FBQ3hELCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsSUFBSTtBQUVKLGtDQUFrQztBQUVLO0FBRXZDLE1BQU1DLFdBQVcsYUFBYSxHQUFHLElBQUlELCtDQUFJQTtBQUV6QyxJQUFJRSxLQUFLO0FBQ1QsSUFBSUMsVUFBVTtBQUVkLDZCQUE2QjtBQUM3QixJQUFJQyxpQkFBaUI7QUFFZCxNQUFNQztJQTBCVEMsYUFBYUMsR0FBRyxFQUFFQyxJQUFJLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxVQUFVLENBQUNGLElBQUksR0FBR0M7UUFFdkIsY0FBYztRQUNkQSxLQUFLRSxFQUFFLEdBQUdQLFdBQVcsa0NBQWtDO1FBQ3ZESyxLQUFLRyxJQUFJLEdBQUdILEtBQUtHLElBQUksSUFBSTtRQUN6QkgsS0FBS0ksSUFBSSxHQUNMSixLQUFLSSxJQUFJLElBQ1JKLENBQUFBLEtBQUtLLElBQUksQ0FBQ0MsV0FBVyxLQUFLQyxlQUNyQixJQUFJLENBQUNDLEVBQUUsQ0FBQ0MsS0FBSyxHQUNiVCxLQUFLSyxJQUFJLENBQUNDLFdBQVcsS0FBS0ksY0FDMUIsSUFBSSxDQUFDRixFQUFFLENBQUNHLGNBQWMsR0FDdEIsSUFBSSxDQUFDSCxFQUFFLENBQUNJLFlBQVksR0FBRyxjQUFjO1FBQy9DWixLQUFLYSxNQUFNLEdBQUdkLFFBQVEsVUFBVSxJQUFJLENBQUNTLEVBQUUsQ0FBQ00sb0JBQW9CLEdBQUcsSUFBSSxDQUFDTixFQUFFLENBQUNPLFlBQVk7UUFDbkZmLEtBQUtnQixVQUFVLEdB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T0FBTyxJQUFJLENBQUNFLFVBQVUsQ0FBRTtZQUM3QixJQUFJLENBQUNPLEVBQUUsQ0FBQzRGLFlBQVksQ0FBQyxJQUFJLENBQUNuRyxVQUFVLENBQUNGLElBQUksQ0FBQzRCLE1BQU07WUFDaEQsT0FBTyxJQUFJLENBQUMxQixVQUFVLENBQUNGLElBQUk7UUFDL0I7SUFDSjtJQXZRQU8sWUFBWUUsRUFBRSxFQUFFUCxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQzdCLElBQUksQ0FBQ08sR0FBRzZGLE1BQU0sRUFBRXRFLFFBQVF1RSxLQUFLLENBQUM7UUFDOUIsSUFBSSxDQUFDOUYsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ1AsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLEVBQUUsR0FBR1I7UUFFVixzREFBc0Q7UUFDdEQsSUFBSSxDQUFDMEQsSUFBSSxHQUFHLENBQUM7UUFFYixJQUFJLENBQUNqQixTQUFTLEdBQUc7WUFBRWEsT0FBTztZQUFHN0IsT0FBTztRQUFFO1FBQ3RDLElBQUksQ0FBQ1csY0FBYyxHQUFHO1FBRXRCLHdFQUF3RTtRQUN4RSxJQUFJLENBQUN0QixFQUFFLENBQUM4QyxRQUFRLENBQUNFLGVBQWUsQ0FBQztRQUNqQyxJQUFJLENBQUNoRCxFQUFFLENBQUM4QyxRQUFRLENBQUNnQixlQUFlLEdBQUc7UUFFbkMsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQzlCLE9BQU8sR0FBRyxJQUFJLENBQUNoQyxFQUFFLENBQUM4QyxRQUFRLENBQUNpRCxLQUFLO1FBRXJDLHFCQUFxQjtRQUNyQixJQUFLLElBQUl4RyxPQUFPRSxXQUFZO1lBQ3hCLElBQUksQ0FBQ0gsWUFBWSxDQUFDQyxLQUFLRSxVQUFVLENBQUNGLElBQUk7UUFDMUM7SUFDSjtBQWlQSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb2dsL3NyYy9jb3JlL0dlb21ldHJ5LmpzP2VlZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXR0cmlidXRlIHBhcmFtc1xuLy8ge1xuLy8gICAgIGRhdGEgLSB0eXBlZCBhcnJheSBlZyBVSW50MTZBcnJheSBmb3IgaW5kaWNlcywgRmxvYXQzMkFycmF5XG4vLyAgICAgc2l6ZSAtIGludCBkZWZhdWx0IDFcbi8vICAgICBpbnN0YW5jZWQgLSBkZWZhdWx0IG51bGwuIFBhc3MgZGl2aXNvciBhbW91bnRcbi8vICAgICB0eXBlIC0gZ2wgZW51bSBkZWZhdWx0IGdsLlVOU0lHTkVEX1NIT1JUIGZvciAnaW5kZXgnLCBnbC5GTE9BVCBmb3Igb3RoZXJzXG4vLyAgICAgbm9ybWFsaXplZCAtIGJvb2xlYW4gZGVmYXVsdCBmYWxzZVxuXG4vLyAgICAgYnVmZmVyIC0gZ2wgYnVmZmVyLCBpZiBidWZmZXIgZXhpc3RzLCBkb24ndCBuZWVkIHRvIHByb3ZpZGUgZGF0YSAtIGFsdGhvdWdoIG5lZWRzIHBvc2l0aW9uIGRhdGEgZm9yIGJvdW5kcyBjYWxjdWxhdGlvblxuLy8gICAgIHN0cmlkZSAtIGRlZmF1bHQgMCAtIGZvciB3aGVuIHBhc3NpbmcgaW4gYnVmZmVyXG4vLyAgICAgb2Zmc2V0IC0gZGVmYXVsdCAwIC0gZm9yIHdoZW4gcGFzc2luZyBpbiBidWZmZXJcbi8vICAgICBjb3VudCAtIGRlZmF1bHQgbnVsbCAtIGZvciB3aGVuIHBhc3NpbmcgaW4gYnVmZmVyXG4vLyAgICAgbWluIC0gYXJyYXkgLSBmb3Igd2hlbiBwYXNzaW5nIGluIGJ1ZmZlclxuLy8gICAgIG1heCAtIGFycmF5IC0gZm9yIHdoZW4gcGFzc2luZyBpbiBidWZmZXJcbi8vIH1cblxuLy8gVE9ETzogZml0IGluIHRyYW5zZm9ybSBmZWVkYmFja1xuXG5pbXBvcnQgeyBWZWMzIH0gZnJvbSAnLi4vbWF0aC9WZWMzLmpzJztcblxuY29uc3QgdGVtcFZlYzMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlYzMoKTtcblxubGV0IElEID0gMTtcbmxldCBBVFRSX0lEID0gMTtcblxuLy8gVG8gc3RvcCBpbmlmaW5pdGUgd2FybmluZ3NcbmxldCBpc0JvdW5kc1dhcm5lZCA9IGZhbHNlO1xuXG5leHBvcnQgY2xhc3MgR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKGdsLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICAgICAgaWYgKCFnbC5jYW52YXMpIGNvbnNvbGUuZXJyb3IoJ2dsIG5vdCBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQgdG8gR2VvbWV0cnknKTtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmlkID0gSUQrKztcblxuICAgICAgICAvLyBTdG9yZSBvbmUgVkFPIHBlciBwcm9ncmFtIGF0dHJpYnV0ZSBsb2NhdGlvbnMgb3JkZXJcbiAgICAgICAgdGhpcy5WQU9zID0ge307XG5cbiAgICAgICAgdGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogMCB9O1xuICAgICAgICB0aGlzLmluc3RhbmNlZENvdW50ID0gMDtcblxuICAgICAgICAvLyBVbmJpbmQgY3VycmVudCBWQU8gc28gdGhhdCBuZXcgYnVmZmVycyBkb24ndCBnZXQgYWRkZWQgdG8gYWN0aXZlIG1lc2hcbiAgICAgICAgdGhpcy5nbC5yZW5kZXJlci5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICAgIHRoaXMuZ2wucmVuZGVyZXIuY3VycmVudEdlb21ldHJ5ID0gbnVsbDtcblxuICAgICAgICAvLyBBbGlhcyBmb3Igc3RhdGUgc3RvcmUgdG8gYXZvaWQgcmVkdW5kYW50IGNhbGxzIGZvciBnbG9iYWwgc3RhdGVcbiAgICAgICAgdGhpcy5nbFN0YXRlID0gdGhpcy5nbC5yZW5kZXJlci5zdGF0ZTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGJ1ZmZlcnNcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZEF0dHJpYnV0ZShrZXksIGF0dHIpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tleV0gPSBhdHRyO1xuXG4gICAgICAgIC8vIFNldCBvcHRpb25zXG4gICAgICAgIGF0dHIuaWQgPSBBVFRSX0lEKys7IC8vIFRPRE86IGN1cnJlbnRseSB1bnVzZWQsIHJlbW92ZT9cbiAgICAgICAgYXR0ci5zaXplID0gYXR0ci5zaXplIHx8IDE7XG4gICAgICAgIGF0dHIudHlwZSA9XG4gICAgICAgICAgICBhdHRyLnR5cGUgfHxcbiAgICAgICAgICAgIChhdHRyLmRhdGEuY29uc3RydWN0b3IgPT09IEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgID8gdGhpcy5nbC5GTE9BVFxuICAgICAgICAgICAgICAgIDogYXR0ci5kYXRhLmNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheVxuICAgICAgICAgICAgICAgID8gdGhpcy5nbC5VTlNJR05FRF9TSE9SVFxuICAgICAgICAgICAgICAgIDogdGhpcy5nbC5VTlNJR05FRF9JTlQpOyAvLyBVaW50MzJBcnJheVxuICAgICAgICBhdHRyLnRhcmdldCA9IGtleSA9PT0gJ2luZGV4JyA/IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiB0aGlzLmdsLkFSUkFZX0JVRkZFUjtcbiAgICAgICAgYXR0ci5ub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkIHx8IGZhbHNlO1xuICAgICAgICBhdHRyLnN0cmlkZSA9IGF0dHIuc3RyaWRlIHx8IDA7XG4gICAgICAgIGF0dHIub2Zmc2V0ID0gYXR0ci5vZmZzZXQgfHwgMDtcbiAgICAgICAgYXR0ci5jb3VudCA9IGF0dHIuY291bnQgfHwgKGF0dHIuc3RyaWRlID8gYXR0ci5kYXRhLmJ5dGVMZW5ndGggLyBhdHRyLnN0cmlkZSA6IGF0dHIuZGF0YS5sZW5ndGggLyBhdHRyLnNpemUpO1xuICAgICAgICBhdHRyLmRpdmlzb3IgPSBhdHRyLmluc3RhbmNlZCB8fCAwO1xuICAgICAgICBhdHRyLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGF0dHIudXNhZ2UgPSBhdHRyLnVzYWdlIHx8IHRoaXMuZ2wuU1RBVElDX0RSQVc7XG5cbiAgICAgICAgaWYgKCFhdHRyLmJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gUHVzaCBkYXRhIHRvIGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZ2VvbWV0cnkgY291bnRzLiBJZiBpbmRleGVkLCBpZ25vcmUgcmVndWxhciBhdHRyaWJ1dGVzXG4gICAgICAgIGlmIChhdHRyLmRpdmlzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbnN0YW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VkQ291bnQgJiYgdGhpcy5pbnN0YW5jZWRDb3VudCAhPT0gYXR0ci5jb3VudCAqIGF0dHIuZGl2aXNvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZ2VvbWV0cnkgaGFzIG11bHRpcGxlIGluc3RhbmNlZCBidWZmZXJzIG9mIGRpZmZlcmVudCBsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuaW5zdGFuY2VkQ291bnQgPSBNYXRoLm1pbih0aGlzLmluc3RhbmNlZENvdW50LCBhdHRyLmNvdW50ICogYXR0ci5kaXZpc29yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlZENvdW50ID0gYXR0ci5jb3VudCAqIGF0dHIuZGl2aXNvcjtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbmRleCcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gYXR0ci5jb3VudDtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5hdHRyaWJ1dGVzLmluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IE1hdGgubWF4KHRoaXMuZHJhd1JhbmdlLmNvdW50LCBhdHRyLmNvdW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUF0dHJpYnV0ZShhdHRyKSB7XG4gICAgICAgIGNvbnN0IGlzTmV3QnVmZmVyID0gIWF0dHIuYnVmZmVyO1xuICAgICAgICBpZiAoaXNOZXdCdWZmZXIpIGF0dHIuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2xTdGF0ZS5ib3VuZEJ1ZmZlciAhPT0gYXR0ci5idWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcihhdHRyLnRhcmdldCwgYXR0ci5idWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5nbFN0YXRlLmJvdW5kQnVmZmVyID0gYXR0ci5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3QnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEoYXR0ci50YXJnZXQsIGF0dHIuZGF0YSwgYXR0ci51c2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsLmJ1ZmZlclN1YkRhdGEoYXR0ci50YXJnZXQsIDAsIGF0dHIuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ci5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCdpbmRleCcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXREcmF3UmFuZ2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG4gICAgfVxuXG4gICAgc2V0SW5zdGFuY2VkQ291bnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZWRDb3VudCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGNyZWF0ZVZBTyhwcm9ncmFtKSB7XG4gICAgICAgIHRoaXMuVkFPc1twcm9ncmFtLmF0dHJpYnV0ZU9yZGVyXSA9IHRoaXMuZ2wucmVuZGVyZXIuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgICAgICAgdGhpcy5nbC5yZW5kZXJlci5iaW5kVmVydGV4QXJyYXkodGhpcy5WQU9zW3Byb2dyYW0uYXR0cmlidXRlT3JkZXJdKTtcbiAgICAgICAgdGhpcy5iaW5kQXR0cmlidXRlcyhwcm9ncmFtKTtcbiAgICB9XG5cbiAgICBiaW5kQXR0cmlidXRlcyhwcm9ncmFtKSB7XG4gICAgICAgIC8vIExpbmsgYWxsIGF0dHJpYnV0ZXMgdG8gcHJvZ3JhbSB1c2luZyBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyXG4gICAgICAgIHByb2dyYW0uYXR0cmlidXRlTG9jYXRpb25zLmZvckVhY2goKGxvY2F0aW9uLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgZ2VvbWV0cnkgbWlzc2luZyBhIHJlcXVpcmVkIHNoYWRlciBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBhY3RpdmUgYXR0cmlidXRlICR7bmFtZX0gbm90IGJlaW5nIHN1cHBsaWVkYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhdHRyID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIoYXR0ci50YXJnZXQsIGF0dHIuYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuZ2xTdGF0ZS5ib3VuZEJ1ZmZlciA9IGF0dHIuYnVmZmVyO1xuXG4gICAgICAgICAgICAvLyBGb3IgbWF0cml4IGF0dHJpYnV0ZXMsIGJ1ZmZlciBuZWVkcyB0byBiZSBkZWZpbmVkIHBlciBjb2x1bW5cbiAgICAgICAgICAgIGxldCBudW1Mb2MgPSAxO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDM1Njc0KSBudW1Mb2MgPSAyOyAvLyBtYXQyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gMzU2NzUpIG51bUxvYyA9IDM7IC8vIG1hdDNcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAzNTY3NikgbnVtTG9jID0gNDsgLy8gbWF0NFxuXG4gICAgICAgICAgICBjb25zdCBzaXplID0gYXR0ci5zaXplIC8gbnVtTG9jO1xuICAgICAgICAgICAgY29uc3Qgc3RyaWRlID0gbnVtTG9jID09PSAxID8gMCA6IG51bUxvYyAqIG51bUxvYyAqIDQ7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBudW1Mb2MgPT09IDEgPyAwIDogbnVtTG9jICogNDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Mb2M7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbiArIGksIHNpemUsIGF0dHIudHlwZSwgYXR0ci5ub3JtYWxpemVkLCBhdHRyLnN0cmlkZSArIHN0cmlkZSwgYXR0ci5vZmZzZXQgKyBpICogb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uICsgaSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2VkIGF0dHJpYnV0ZXMsIGRpdmlzb3IgbmVlZHMgdG8gYmUgc2V0LlxuICAgICAgICAgICAgICAgIC8vIEZvciBmaXJlZm94LCBuZWVkIHRvIHNldCBiYWNrIHRvIDAgaWYgbm9uLWluc3RhbmNlZCBkcmF3biBhZnRlciBpbnN0YW5jZWQuIEVsc2Ugd29uJ3QgcmVuZGVyXG4gICAgICAgICAgICAgICAgdGhpcy5nbC5yZW5kZXJlci52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvY2F0aW9uICsgaSwgYXR0ci5kaXZpc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQmluZCBpbmRpY2VzIGlmIGdlb21ldHJ5IGluZGV4ZWRcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy5pbmRleCkgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYXR0cmlidXRlcy5pbmRleC5idWZmZXIpO1xuICAgIH1cblxuICAgIGRyYXcoeyBwcm9ncmFtLCBtb2RlID0gdGhpcy5nbC5UUklBTkdMRVMgfSkge1xuICAgICAgICBpZiAodGhpcy5nbC5yZW5kZXJlci5jdXJyZW50R2VvbWV0cnkgIT09IGAke3RoaXMuaWR9XyR7cHJvZ3JhbS5hdHRyaWJ1dGVPcmRlcn1gKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuVkFPc1twcm9ncmFtLmF0dHJpYnV0ZU9yZGVyXSkgdGhpcy5jcmVhdGVWQU8ocHJvZ3JhbSk7XG4gICAgICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLlZBT3NbcHJvZ3JhbS5hdHRyaWJ1dGVPcmRlcl0pO1xuICAgICAgICAgICAgdGhpcy5nbC5yZW5kZXJlci5jdXJyZW50R2VvbWV0cnkgPSBgJHt0aGlzLmlkfV8ke3Byb2dyYW0uYXR0cmlidXRlT3JkZXJ9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBhdHRyaWJ1dGVzIG5lZWQgdXBkYXRpbmdcbiAgICAgICAgcHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnMuZm9yRWFjaCgobG9jYXRpb24sIHsgbmFtZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHIubmVlZHNVcGRhdGUpIHRoaXMudXBkYXRlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGb3IgZHJhd0VsZW1lbnRzLCBvZmZzZXQgbmVlZHMgdG8gYmUgbXVsdGlwbGUgb2YgdHlwZSBzaXplXG4gICAgICAgIGxldCBpbmRleEJ5dGVzUGVyRWxlbWVudCA9IDI7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaW5kZXg/LnR5cGUgPT09IHRoaXMuZ2wuVU5TSUdORURfSU5UKSBpbmRleEJ5dGVzUGVyRWxlbWVudCA9IDQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLmRyYXdFbGVtZW50c0luc3RhbmNlZChcbiAgICAgICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UmFuZ2UuY291bnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5pbmRleC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuaW5kZXgub2Zmc2V0ICsgdGhpcy5kcmF3UmFuZ2Uuc3RhcnQgKiBpbmRleEJ5dGVzUGVyRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZWRDb3VudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wucmVuZGVyZXIuZHJhd0FycmF5c0luc3RhbmNlZChtb2RlLCB0aGlzLmRyYXdSYW5nZS5zdGFydCwgdGhpcy5kcmF3UmFuZ2UuY291bnQsIHRoaXMuaW5zdGFuY2VkQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzKFxuICAgICAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmluZGV4LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5pbmRleC5vZmZzZXQgKyB0aGlzLmRyYXdSYW5nZS5zdGFydCAqIGluZGV4Qnl0ZXNQZXJFbGVtZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5kcmF3QXJyYXlzKG1vZGUsIHRoaXMuZHJhd1JhbmdlLnN0YXJ0LCB0aGlzLmRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIHBvc2l0aW9uIGJ1ZmZlciwgb3IgbWluL21heCBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgYXR0ciA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgICAgLy8gaWYgKGF0dHIubWluKSByZXR1cm4gWy4uLmF0dHIubWluLCAuLi5hdHRyLm1heF07XG4gICAgICAgIGlmIChhdHRyLmRhdGEpIHJldHVybiBhdHRyO1xuICAgICAgICBpZiAoaXNCb3VuZHNXYXJuZWQpIHJldHVybjtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBwb3NpdGlvbiBidWZmZXIgZGF0YSBmb3VuZCB0byBjb21wdXRlIGJvdW5kcycpO1xuICAgICAgICByZXR1cm4gKGlzQm91bmRzV2FybmVkID0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94KGF0dHIpIHtcbiAgICAgICAgaWYgKCFhdHRyKSBhdHRyID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBhcnJheSA9IGF0dHIuZGF0YTtcbiAgICAgICAgLy8gRGF0YSBsb2FkZWQgc2hvdWxkbid0IGhhYXZlIHN0cmlkZSwgb25seSBidWZmZXJzXG4gICAgICAgIC8vIGNvbnN0IHN0cmlkZSA9IGF0dHIuc3RyaWRlID8gYXR0ci5zdHJpZGUgLyBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IGF0dHIuc2l6ZTtcbiAgICAgICAgY29uc3Qgc3RyaWRlID0gYXR0ci5zaXplO1xuXG4gICAgICAgIGlmICghdGhpcy5ib3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0ge1xuICAgICAgICAgICAgICAgIG1pbjogbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBtYXg6IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgY2VudGVyOiBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIHJhZGl1czogSW5maW5pdHksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5ib3VuZHMubWluO1xuICAgICAgICBjb25zdCBtYXggPSB0aGlzLmJvdW5kcy5tYXg7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuYm91bmRzLmNlbnRlcjtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmJvdW5kcy5zY2FsZTtcblxuICAgICAgICBtaW4uc2V0KCtJbmZpbml0eSk7XG4gICAgICAgIG1heC5zZXQoLUluZmluaXR5KTtcblxuICAgICAgICAvLyBUT0RPOiBjaGVjayBzaXplIG9mIHBvc2l0aW9uIChlZyB0cmlhbmdsZSB3aXRoIFZlYzIpXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBhcnJheVtpICsgMV07XG4gICAgICAgICAgICBjb25zdCB6ID0gYXJyYXlbaSArIDJdO1xuXG4gICAgICAgICAgICBtaW4ueCA9IE1hdGgubWluKHgsIG1pbi54KTtcbiAgICAgICAgICAgIG1pbi55ID0gTWF0aC5taW4oeSwgbWluLnkpO1xuICAgICAgICAgICAgbWluLnogPSBNYXRoLm1pbih6LCBtaW4ueik7XG5cbiAgICAgICAgICAgIG1heC54ID0gTWF0aC5tYXgoeCwgbWF4LngpO1xuICAgICAgICAgICAgbWF4LnkgPSBNYXRoLm1heCh5LCBtYXgueSk7XG4gICAgICAgICAgICBtYXgueiA9IE1hdGgubWF4KHosIG1heC56KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjYWxlLnN1YihtYXgsIG1pbik7XG4gICAgICAgIGNlbnRlci5hZGQobWluLCBtYXgpLmRpdmlkZSgyKTtcbiAgICB9XG5cbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmUoYXR0cikge1xuICAgICAgICBpZiAoIWF0dHIpIGF0dHIgPSB0aGlzLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gYXR0ci5kYXRhO1xuICAgICAgICAvLyBEYXRhIGxvYWRlZCBzaG91bGRuJ3QgaGFhdmUgc3RyaWRlLCBvbmx5IGJ1ZmZlcnNcbiAgICAgICAgLy8gY29uc3Qgc3RyaWRlID0gYXR0ci5zdHJpZGUgPyBhdHRyLnN0cmlkZSAvIGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogYXR0ci5zaXplO1xuICAgICAgICBjb25zdCBzdHJpZGUgPSBhdHRyLnNpemU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kcykgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goYXR0cik7XG5cbiAgICAgICAgbGV0IG1heFJhZGl1c1NxID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdGVtcFZlYzMuZnJvbUFycmF5KGFycmF5LCBpKTtcbiAgICAgICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIHRoaXMuYm91bmRzLmNlbnRlci5zcXVhcmVkRGlzdGFuY2UodGVtcFZlYzMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRzLnJhZGl1cyA9IE1hdGguc3FydChtYXhSYWRpdXNTcSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5WQU9zKSB7XG4gICAgICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLmRlbGV0ZVZlcnRleEFycmF5KHRoaXMuVkFPc1trZXldKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLlZBT3Nba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmF0dHJpYnV0ZXNba2V5XS5idWZmZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlZlYzMiLCJ0ZW1wVmVjMyIsIklEIiwiQVRUUl9JRCIsImlzQm91bmRzV2FybmVkIiwiR2VvbWV0cnkiLCJhZGRBdHRyaWJ1dGUiLCJrZXkiLCJhdHRyIiwiYXR0cmlidXRlcyIsImlkIiwic2l6ZSIsInR5cGUiLCJkYXRhIiwiY29uc3RydWN0b3IiLCJGbG9hdDMyQXJyYXkiLCJnbCIsIkZMT0FUIiwiVWludDE2QXJyYXkiLCJVTlNJR05FRF9TSE9SVCIsIlVOU0lHTkVEX0lOVCIsInRhcmdldCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiQVJSQVlfQlVGRkVSIiwibm9ybWFsaXplZCIsInN0cmlkZSIsIm9mZnNldCIsImNvdW50IiwiYnl0ZUxlbmd0aCIsImxlbmd0aCIsImRpdmlzb3IiLCJpbnN0YW5jZWQiLCJuZWVkc1VwZGF0ZSIsInVzYWdlIiwiU1RBVElDX0RSQVciLCJidWZmZXIiLCJ1cGRhdGVBdHRyaWJ1dGUiLCJpc0luc3RhbmNlZCIsImluc3RhbmNlZENvdW50IiwiY29uc29sZSIsIndhcm4iLCJNYXRoIiwibWluIiwiZHJhd1JhbmdlIiwiaW5kZXgiLCJtYXgiLCJpc05ld0J1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImdsU3RhdGUiLCJib3VuZEJ1ZmZlciIsImJpbmRCdWZmZXIiLCJidWZmZXJEYXRhIiwiYnVmZmVyU3ViRGF0YSIsInNldEluZGV4IiwidmFsdWUiLCJzZXREcmF3UmFuZ2UiLCJzdGFydCIsInNldEluc3RhbmNlZENvdW50IiwiY3JlYXRlVkFPIiwicHJvZ3JhbSIsIlZBT3MiLCJhdHRyaWJ1dGVPcmRlciIsInJlbmRlcmVyIiwiY3JlYXRlVmVydGV4QXJyYXkiLCJiaW5kVmVydGV4QXJyYXkiLCJiaW5kQXR0cmlidXRlcyIsImF0dHJpYnV0ZUxvY2F0aW9ucyIsImZvckVhY2giLCJsb2NhdGlvbiIsIm5hbWUiLCJudW1Mb2MiLCJpIiwidmVydGV4QXR0cmliUG9pbnRlciIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliRGl2aXNvciIsImRyYXciLCJtb2RlIiwiVFJJQU5HTEVTIiwiY3VycmVudEdlb21ldHJ5IiwiaW5kZXhCeXRlc1BlckVsZW1lbnQiLCJkcmF3RWxlbWVudHNJbnN0YW5jZWQiLCJkcmF3QXJyYXlzSW5zdGFuY2VkIiwiZHJhd0VsZW1lbnRzIiwiZHJhd0FycmF5cyIsImdldFBvc2l0aW9uIiwicG9zaXRpb24iLCJjb21wdXRlQm91bmRpbmdCb3giLCJhcnJheSIsImJvdW5kcyIsImNlbnRlciIsInNjYWxlIiwicmFkaXVzIiwiSW5maW5pdHkiLCJzZXQiLCJsIiwieCIsInkiLCJ6Iiwic3ViIiwiYWRkIiwiZGl2aWRlIiwiY29tcHV0ZUJvdW5kaW5nU3BoZXJlIiwibWF4UmFkaXVzU3EiLCJmcm9tQXJyYXkiLCJzcXVhcmVkRGlzdGFuY2UiLCJzcXJ0IiwicmVtb3ZlIiwiZGVsZXRlVmVydGV4QXJyYXkiLCJkZWxldGVCdWZmZXIiLCJjYW52YXMiLCJlcnJvciIsInN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/core/Geometry.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/core/Mesh.js":
/*!*******************************************!*\
  !*** ./node_modules/ogl/src/core/Mesh.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mesh: function() { return /* binding */ Mesh; }\n/* harmony export */ });\n/* harmony import */ var _Transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform.js */ \"(app-pages-browser)/./node_modules/ogl/src/core/Transform.js\");\n/* harmony import */ var _math_Mat3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Mat3.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Mat3.js\");\n/* harmony import */ var _math_Mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Mat4.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Mat4.js\");\n\n\n\nlet ID = 0;\nclass Mesh extends _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform {\n    onBeforeRender(f) {\n        this.beforeRenderCallbacks.push(f);\n        return this;\n    }\n    onAfterRender(f) {\n        this.afterRenderCallbacks.push(f);\n        return this;\n    }\n    draw() {\n        let { camera } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (camera) {\n            // Add empty matrix uniforms to program if unset\n            if (!this.program.uniforms.modelMatrix) {\n                Object.assign(this.program.uniforms, {\n                    modelMatrix: {\n                        value: null\n                    },\n                    viewMatrix: {\n                        value: null\n                    },\n                    modelViewMatrix: {\n                        value: null\n                    },\n                    normalMatrix: {\n                        value: null\n                    },\n                    projectionMatrix: {\n                        value: null\n                    },\n                    cameraPosition: {\n                        value: null\n                    }\n                });\n            }\n            // Set the matrix uniforms\n            this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n            this.program.uniforms.cameraPosition.value = camera.worldPosition;\n            this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n            this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n            this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n            this.program.uniforms.modelMatrix.value = this.worldMatrix;\n            this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n            this.program.uniforms.normalMatrix.value = this.normalMatrix;\n        }\n        this.beforeRenderCallbacks.forEach((f)=>f && f({\n                mesh: this,\n                camera\n            }));\n        // determine if faces need to be flipped - when mesh scaled negatively\n        let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n        this.program.use({\n            flipFaces\n        });\n        this.geometry.draw({\n            mode: this.mode,\n            program: this.program\n        });\n        this.afterRenderCallbacks.forEach((f)=>f && f({\n                mesh: this,\n                camera\n            }));\n    }\n    constructor(gl, { geometry, program, mode = gl.TRIANGLES, frustumCulled = true, renderOrder = 0 } = {}){\n        super();\n        if (!gl.canvas) console.error(\"gl not passed as first argument to Mesh\");\n        this.gl = gl;\n        this.id = ID++;\n        this.geometry = geometry;\n        this.program = program;\n        this.mode = mode;\n        // Used to skip frustum culling\n        this.frustumCulled = frustumCulled;\n        // Override sorting to force an order\n        this.renderOrder = renderOrder;\n        this.modelViewMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n        this.normalMatrix = new _math_Mat3_js__WEBPACK_IMPORTED_MODULE_2__.Mat3();\n        this.beforeRenderCallbacks = [];\n        this.afterRenderCallbacks = [];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvTWVzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJDO0FBQ0o7QUFDQTtBQUV2QyxJQUFJRyxLQUFLO0FBRUYsTUFBTUMsYUFBYUosb0RBQVNBO0lBcUIvQkssZUFBZUMsQ0FBQyxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0MsSUFBSSxDQUFDRjtRQUNoQyxPQUFPLElBQUk7SUFDZjtJQUVBRyxjQUFjSCxDQUFDLEVBQUU7UUFDYixJQUFJLENBQUNJLG9CQUFvQixDQUFDRixJQUFJLENBQUNGO1FBQy9CLE9BQU8sSUFBSTtJQUNmO0lBRUFLLE9BQXNCO1lBQWpCLEVBQUVDLE1BQU0sRUFBRSxHQUFWLGlFQUFhLENBQUM7UUFDZixJQUFJQSxRQUFRO1lBQ1IsZ0RBQWdEO1lBQ2hELElBQUksQ0FBQyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDQyxXQUFXLEVBQUU7Z0JBQ3BDQyxPQUFPQyxNQUFNLENBQUMsSUFBSSxDQUFDSixPQUFPLENBQUNDLFFBQVEsRUFBRTtvQkFDakNDLGFBQWE7d0JBQUVHLE9BQU87b0JBQUs7b0JBQzNCQyxZQUFZO3dCQUFFRCxPQUFPO29CQUFLO29CQUMxQkUsaUJBQWlCO3dCQUFFRixPQUFPO29CQUFLO29CQUMvQkcsY0FBYzt3QkFBRUgsT0FBTztvQkFBSztvQkFDNUJJLGtCQUFrQjt3QkFBRUosT0FBTztvQkFBSztvQkFDaENLLGdCQUFnQjt3QkFBRUwsT0FBTztvQkFBSztnQkFDbEM7WUFDSjtZQUVBLDBCQUEwQjtZQUMxQixJQUFJLENBQUNMLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDUSxnQkFBZ0IsQ0FBQ0osS0FBSyxHQUFHTixPQUFPVSxnQkFBZ0I7WUFDdEUsSUFBSSxDQUFDVCxPQUFPLENBQUNDLFFBQVEsQ0FBQ1MsY0FBYyxDQUFDTCxLQUFLLEdBQUdOLE9BQU9ZLGFBQWE7WUFDakUsSUFBSSxDQUFDWCxPQUFPLENBQUNDLFFBQVEsQ0FBQ0ssVUFBVSxDQUFDRCxLQUFLLEdBQUdOLE9BQU9PLFVBQVU7WUFDMUQsSUFBSSxDQUFDQyxlQUFlLENBQUNLLFFBQVEsQ0FBQ2IsT0FBT08sVUFBVSxFQUFFLElBQUksQ0FBQ08sV0FBVztZQUNqRSxJQUFJLENBQUNMLFlBQVksQ0FBQ00sZUFBZSxDQUFDLElBQUksQ0FBQ1AsZUFBZTtZQUN0RCxJQUFJLENBQUNQLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDQyxXQUFXLENBQUNHLEtBQUssR0FBRyxJQUFJLENBQUNRLFdBQVc7WUFDMUQsSUFBSSxDQUFDYixPQUFPLENBQUNDLFFBQVEsQ0FBQ00sZUFBZSxDQUFDRixLQUFLLEdBQUcsSUFBSSxDQUFDRSxlQUFlO1lBQ2xFLElBQUksQ0FBQ1AsT0FBTyxDQUFDQyxRQUFRLENBQUNPLFlBQVksQ0FBQ0gsS0FBSyxHQUFHLElBQUksQ0FBQ0csWUFBWTtRQUNoRTtRQUNBLElBQUksQ0FBQ2QscUJBQXFCLENBQUNxQixPQUFPLENBQUMsQ0FBQ3RCLElBQU1BLEtBQUtBLEVBQUU7Z0JBQUV1QixNQUFNLElBQUk7Z0JBQUVqQjtZQUFPO1FBRXRFLHNFQUFzRTtRQUN0RSxJQUFJa0IsWUFBWSxJQUFJLENBQUNqQixPQUFPLENBQUNrQixRQUFRLElBQUksSUFBSSxDQUFDTCxXQUFXLENBQUNNLFdBQVcsS0FBSztRQUMxRSxJQUFJLENBQUNuQixPQUFPLENBQUNvQixHQUFHLENBQUM7WUFBRUg7UUFBVTtRQUM3QixJQUFJLENBQUNJLFFBQVEsQ0FBQ3ZCLElBQUksQ0FBQztZQUFFd0IsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFBRXRCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQUM7UUFDNUQsSUFBSSxDQUFDSCxvQkFBb0IsQ0FBQ2tCLE9BQU8sQ0FBQyxDQUFDdEIsSUFBTUEsS0FBS0EsRUFBRTtnQkFBRXVCLE1BQU0sSUFBSTtnQkFBRWpCO1lBQU87SUFDekU7SUE3REF3QixZQUFZQyxFQUFFLEVBQUUsRUFBRUgsUUFBUSxFQUFFckIsT0FBTyxFQUFFc0IsT0FBT0UsR0FBR0MsU0FBUyxFQUFFQyxnQkFBZ0IsSUFBSSxFQUFFQyxjQUFjLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3BHLEtBQUs7UUFDTCxJQUFJLENBQUNILEdBQUdJLE1BQU0sRUFBRUMsUUFBUUMsS0FBSyxDQUFDO1FBQzlCLElBQUksQ0FBQ04sRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ08sRUFBRSxHQUFHekM7UUFDVixJQUFJLENBQUMrQixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ3JCLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNzQixJQUFJLEdBQUdBO1FBRVosK0JBQStCO1FBQy9CLElBQUksQ0FBQ0ksYUFBYSxHQUFHQTtRQUVyQixxQ0FBcUM7UUFDckMsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ3BCLGVBQWUsR0FBRyxJQUFJbEIsK0NBQUlBO1FBQy9CLElBQUksQ0FBQ21CLFlBQVksR0FBRyxJQUFJcEIsK0NBQUlBO1FBQzVCLElBQUksQ0FBQ00scUJBQXFCLEdBQUcsRUFBRTtRQUMvQixJQUFJLENBQUNHLG9CQUFvQixHQUFHLEVBQUU7SUFDbEM7QUE0Q0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvY29yZS9NZXNoLmpzPzI5ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnLi9UcmFuc2Zvcm0uanMnO1xuaW1wb3J0IHsgTWF0MyB9IGZyb20gJy4uL21hdGgvTWF0My5qcyc7XG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSAnLi4vbWF0aC9NYXQ0LmpzJztcblxubGV0IElEID0gMDtcblxuZXhwb3J0IGNsYXNzIE1lc2ggZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGdsLCB7IGdlb21ldHJ5LCBwcm9ncmFtLCBtb2RlID0gZ2wuVFJJQU5HTEVTLCBmcnVzdHVtQ3VsbGVkID0gdHJ1ZSwgcmVuZGVyT3JkZXIgPSAwIH0gPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWdsLmNhbnZhcykgY29uc29sZS5lcnJvcignZ2wgbm90IHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudCB0byBNZXNoJyk7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5pZCA9IElEKys7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcblxuICAgICAgICAvLyBVc2VkIHRvIHNraXAgZnJ1c3R1bSBjdWxsaW5nXG4gICAgICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IGZydXN0dW1DdWxsZWQ7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgc29ydGluZyB0byBmb3JjZSBhbiBvcmRlclxuICAgICAgICB0aGlzLnJlbmRlck9yZGVyID0gcmVuZGVyT3JkZXI7XG4gICAgICAgIHRoaXMubW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdDQoKTtcbiAgICAgICAgdGhpcy5ub3JtYWxNYXRyaXggPSBuZXcgTWF0MygpO1xuICAgICAgICB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmFmdGVyUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gICAgfVxuXG4gICAgb25CZWZvcmVSZW5kZXIoZikge1xuICAgICAgICB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcy5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvbkFmdGVyUmVuZGVyKGYpIHtcbiAgICAgICAgdGhpcy5hZnRlclJlbmRlckNhbGxiYWNrcy5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkcmF3KHsgY2FtZXJhIH0gPSB7fSkge1xuICAgICAgICBpZiAoY2FtZXJhKSB7XG4gICAgICAgICAgICAvLyBBZGQgZW1wdHkgbWF0cml4IHVuaWZvcm1zIHRvIHByb2dyYW0gaWYgdW5zZXRcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9ncmFtLnVuaWZvcm1zLm1vZGVsTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnByb2dyYW0udW5pZm9ybXMsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxNYXRyaXg6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgdmlld01hdHJpeDogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBtb2RlbFZpZXdNYXRyaXg6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsTWF0cml4OiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhUG9zaXRpb246IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBtYXRyaXggdW5pZm9ybXNcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LnZhbHVlID0gY2FtZXJhLnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0udW5pZm9ybXMuY2FtZXJhUG9zaXRpb24udmFsdWUgPSBjYW1lcmEud29ybGRQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS51bmlmb3Jtcy52aWV3TWF0cml4LnZhbHVlID0gY2FtZXJhLnZpZXdNYXRyaXg7XG4gICAgICAgICAgICB0aGlzLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseShjYW1lcmEudmlld01hdHJpeCwgdGhpcy53b3JsZE1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgodGhpcy5tb2RlbFZpZXdNYXRyaXgpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLnVuaWZvcm1zLm1vZGVsTWF0cml4LnZhbHVlID0gdGhpcy53b3JsZE1hdHJpeDtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS51bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgudmFsdWUgPSB0aGlzLm1vZGVsVmlld01hdHJpeDtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS51bmlmb3Jtcy5ub3JtYWxNYXRyaXgudmFsdWUgPSB0aGlzLm5vcm1hbE1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcy5mb3JFYWNoKChmKSA9PiBmICYmIGYoeyBtZXNoOiB0aGlzLCBjYW1lcmEgfSkpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiBmYWNlcyBuZWVkIHRvIGJlIGZsaXBwZWQgLSB3aGVuIG1lc2ggc2NhbGVkIG5lZ2F0aXZlbHlcbiAgICAgICAgbGV0IGZsaXBGYWNlcyA9IHRoaXMucHJvZ3JhbS5jdWxsRmFjZSAmJiB0aGlzLndvcmxkTWF0cml4LmRldGVybWluYW50KCkgPCAwO1xuICAgICAgICB0aGlzLnByb2dyYW0udXNlKHsgZmxpcEZhY2VzIH0pO1xuICAgICAgICB0aGlzLmdlb21ldHJ5LmRyYXcoeyBtb2RlOiB0aGlzLm1vZGUsIHByb2dyYW06IHRoaXMucHJvZ3JhbSB9KTtcbiAgICAgICAgdGhpcy5hZnRlclJlbmRlckNhbGxiYWNrcy5mb3JFYWNoKChmKSA9PiBmICYmIGYoeyBtZXNoOiB0aGlzLCBjYW1lcmEgfSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJUcmFuc2Zvcm0iLCJNYXQzIiwiTWF0NCIsIklEIiwiTWVzaCIsIm9uQmVmb3JlUmVuZGVyIiwiZiIsImJlZm9yZVJlbmRlckNhbGxiYWNrcyIsInB1c2giLCJvbkFmdGVyUmVuZGVyIiwiYWZ0ZXJSZW5kZXJDYWxsYmFja3MiLCJkcmF3IiwiY2FtZXJhIiwicHJvZ3JhbSIsInVuaWZvcm1zIiwibW9kZWxNYXRyaXgiLCJPYmplY3QiLCJhc3NpZ24iLCJ2YWx1ZSIsInZpZXdNYXRyaXgiLCJtb2RlbFZpZXdNYXRyaXgiLCJub3JtYWxNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwiY2FtZXJhUG9zaXRpb24iLCJ3b3JsZFBvc2l0aW9uIiwibXVsdGlwbHkiLCJ3b3JsZE1hdHJpeCIsImdldE5vcm1hbE1hdHJpeCIsImZvckVhY2giLCJtZXNoIiwiZmxpcEZhY2VzIiwiY3VsbEZhY2UiLCJkZXRlcm1pbmFudCIsInVzZSIsImdlb21ldHJ5IiwibW9kZSIsImNvbnN0cnVjdG9yIiwiZ2wiLCJUUklBTkdMRVMiLCJmcnVzdHVtQ3VsbGVkIiwicmVuZGVyT3JkZXIiLCJjYW52YXMiLCJjb25zb2xlIiwiZXJyb3IiLCJpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/core/Mesh.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/core/Program.js":
/*!**********************************************!*\
  !*** ./node_modules/ogl/src/core/Program.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Program: function() { return /* binding */ Program; }\n/* harmony export */ });\n// TODO: upload empty texture if null ? maybe not\n// TODO: upload identity matrix if null ?\n// TODO: sampler Cube\nlet ID = 1;\n// cache of typed arrays used to flatten uniform arrays\nconst arrayCacheF32 = {};\nclass Program {\n    setShaders(param) {\n        let { vertex, fragment } = param;\n        if (vertex) {\n            // compile vertex shader and log errors\n            this.gl.shaderSource(this.vertexShader, vertex);\n            this.gl.compileShader(this.vertexShader);\n            if (this.gl.getShaderInfoLog(this.vertexShader) !== \"\") {\n                console.warn(\"\".concat(this.gl.getShaderInfoLog(this.vertexShader), \"\\nVertex Shader\\n\").concat(addLineNumbers(vertex)));\n            }\n        }\n        if (fragment) {\n            // compile fragment shader and log errors\n            this.gl.shaderSource(this.fragmentShader, fragment);\n            this.gl.compileShader(this.fragmentShader);\n            if (this.gl.getShaderInfoLog(this.fragmentShader) !== \"\") {\n                console.warn(\"\".concat(this.gl.getShaderInfoLog(this.fragmentShader), \"\\nFragment Shader\\n\").concat(addLineNumbers(fragment)));\n            }\n        }\n        // compile program and log errors\n        this.gl.linkProgram(this.program);\n        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n            return console.warn(this.gl.getProgramInfoLog(this.program));\n        }\n        // Get active uniform locations\n        this.uniformLocations = new Map();\n        let numUniforms = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);\n        for(let uIndex = 0; uIndex < numUniforms; uIndex++){\n            let uniform = this.gl.getActiveUniform(this.program, uIndex);\n            this.uniformLocations.set(uniform, this.gl.getUniformLocation(this.program, uniform.name));\n            // split uniforms' names to separate array and struct declarations\n            const split = uniform.name.match(/(\\w+)/g);\n            uniform.uniformName = split[0];\n            uniform.nameComponents = split.slice(1);\n        }\n        // Get active attribute locations\n        this.attributeLocations = new Map();\n        const locations = [];\n        const numAttribs = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);\n        for(let aIndex = 0; aIndex < numAttribs; aIndex++){\n            const attribute = this.gl.getActiveAttrib(this.program, aIndex);\n            const location = this.gl.getAttribLocation(this.program, attribute.name);\n            // Ignore special built-in inputs. eg gl_VertexID, gl_InstanceID\n            if (location === -1) continue;\n            locations[location] = attribute.name;\n            this.attributeLocations.set(attribute, location);\n        }\n        this.attributeOrder = locations.join(\"\");\n    }\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        this.blendFunc.src = src;\n        this.blendFunc.dst = dst;\n        this.blendFunc.srcAlpha = srcAlpha;\n        this.blendFunc.dstAlpha = dstAlpha;\n        if (src) this.transparent = true;\n    }\n    setBlendEquation(modeRGB, modeAlpha) {\n        this.blendEquation.modeRGB = modeRGB;\n        this.blendEquation.modeAlpha = modeAlpha;\n    }\n    setStencilFunc(func, ref, mask) {\n        this.stencilRef = ref;\n        this.stencilFunc.func = func;\n        this.stencilFunc.ref = ref;\n        this.stencilFunc.mask = mask;\n    }\n    setStencilOp(stencilFail, depthFail, depthPass) {\n        this.stencilOp.stencilFail = stencilFail;\n        this.stencilOp.depthFail = depthFail;\n        this.stencilOp.depthPass = depthPass;\n    }\n    applyState() {\n        if (this.depthTest) this.gl.renderer.enable(this.gl.DEPTH_TEST);\n        else this.gl.renderer.disable(this.gl.DEPTH_TEST);\n        if (this.cullFace) this.gl.renderer.enable(this.gl.CULL_FACE);\n        else this.gl.renderer.disable(this.gl.CULL_FACE);\n        if (this.blendFunc.src) this.gl.renderer.enable(this.gl.BLEND);\n        else this.gl.renderer.disable(this.gl.BLEND);\n        if (this.cullFace) this.gl.renderer.setCullFace(this.cullFace);\n        this.gl.renderer.setFrontFace(this.frontFace);\n        this.gl.renderer.setDepthMask(this.depthWrite);\n        this.gl.renderer.setDepthFunc(this.depthFunc);\n        if (this.blendFunc.src) this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha);\n        this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);\n        if (this.stencilFunc.func || this.stencilOp.stencilFail) this.gl.renderer.enable(this.gl.STENCIL_TEST);\n        else this.gl.renderer.disable(this.gl.STENCIL_TEST);\n        this.gl.renderer.setStencilFunc(this.stencilFunc.func, this.stencilFunc.ref, this.stencilFunc.mask);\n        this.gl.renderer.setStencilOp(this.stencilOp.stencilFail, this.stencilOp.depthFail, this.stencilOp.depthPass);\n    }\n    use() {\n        let { flipFaces = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        let textureUnit = -1;\n        const programActive = this.gl.renderer.state.currentProgram === this.id;\n        // Avoid gl call if program already in use\n        if (!programActive) {\n            this.gl.useProgram(this.program);\n            this.gl.renderer.state.currentProgram = this.id;\n        }\n        // Set only the active uniforms found in the shader\n        this.uniformLocations.forEach((location, activeUniform)=>{\n            let uniform = this.uniforms[activeUniform.uniformName];\n            for (const component of activeUniform.nameComponents){\n                if (!uniform) break;\n                if (component in uniform) {\n                    uniform = uniform[component];\n                } else if (Array.isArray(uniform.value)) {\n                    break;\n                } else {\n                    uniform = undefined;\n                    break;\n                }\n            }\n            if (!uniform) {\n                return warn(\"Active uniform \".concat(activeUniform.name, \" has not been supplied\"));\n            }\n            if (uniform && uniform.value === undefined) {\n                return warn(\"\".concat(activeUniform.name, \" uniform is missing a value parameter\"));\n            }\n            if (uniform.value.texture) {\n                textureUnit = textureUnit + 1;\n                // Check if texture needs to be updated\n                uniform.value.update(textureUnit);\n                return setUniform(this.gl, activeUniform.type, location, textureUnit);\n            }\n            // For texture arrays, set uniform as an array of texture units instead of just one\n            if (uniform.value.length && uniform.value[0].texture) {\n                const textureUnits = [];\n                uniform.value.forEach((value)=>{\n                    textureUnit = textureUnit + 1;\n                    value.update(textureUnit);\n                    textureUnits.push(textureUnit);\n                });\n                return setUniform(this.gl, activeUniform.type, location, textureUnits);\n            }\n            setUniform(this.gl, activeUniform.type, location, uniform.value);\n        });\n        this.applyState();\n        if (flipFaces) this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);\n    }\n    remove() {\n        this.gl.deleteProgram(this.program);\n    }\n    constructor(gl, { vertex, fragment, uniforms = {}, transparent = false, cullFace = gl.BACK, frontFace = gl.CCW, depthTest = true, depthWrite = true, depthFunc = gl.LEQUAL } = {}){\n        if (!gl.canvas) console.error(\"gl not passed as first argument to Program\");\n        this.gl = gl;\n        this.uniforms = uniforms;\n        this.id = ID++;\n        if (!vertex) console.warn(\"vertex shader not supplied\");\n        if (!fragment) console.warn(\"fragment shader not supplied\");\n        // Store program state\n        this.transparent = transparent;\n        this.cullFace = cullFace;\n        this.frontFace = frontFace;\n        this.depthTest = depthTest;\n        this.depthWrite = depthWrite;\n        this.depthFunc = depthFunc;\n        this.blendFunc = {};\n        this.blendEquation = {};\n        this.stencilFunc = {};\n        this.stencilOp = {};\n        // set default blendFunc if transparent flagged\n        if (this.transparent && !this.blendFunc.src) {\n            if (this.gl.renderer.premultipliedAlpha) this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);\n            else this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        }\n        // Create empty shaders and attach to program\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        this.program = gl.createProgram();\n        gl.attachShader(this.program, this.vertexShader);\n        gl.attachShader(this.program, this.fragmentShader);\n        // Compile shaders with source\n        this.setShaders({\n            vertex,\n            fragment\n        });\n    }\n}\nfunction setUniform(gl, type, location, value) {\n    value = value.length ? flatten(value) : value;\n    const setValue = gl.renderer.state.uniformLocations.get(location);\n    // Avoid redundant uniform commands\n    if (value.length) {\n        if (setValue === undefined || setValue.length !== value.length) {\n            // clone array to store as cache\n            gl.renderer.state.uniformLocations.set(location, value.slice(0));\n        } else {\n            if (arraysEqual(setValue, value)) return;\n            // Update cached array values\n            setValue.set ? setValue.set(value) : setArray(setValue, value);\n            gl.renderer.state.uniformLocations.set(location, setValue);\n        }\n    } else {\n        if (setValue === value) return;\n        gl.renderer.state.uniformLocations.set(location, value);\n    }\n    switch(type){\n        case 5126:\n            return value.length ? gl.uniform1fv(location, value) : gl.uniform1f(location, value); // FLOAT\n        case 35664:\n            return gl.uniform2fv(location, value); // FLOAT_VEC2\n        case 35665:\n            return gl.uniform3fv(location, value); // FLOAT_VEC3\n        case 35666:\n            return gl.uniform4fv(location, value); // FLOAT_VEC4\n        case 35670:\n        case 5124:\n        case 35678:\n        case 36306:\n        case 35680:\n        case 36289:\n            return value.length ? gl.uniform1iv(location, value) : gl.uniform1i(location, value); // SAMPLER_CUBE\n        case 35671:\n        case 35667:\n            return gl.uniform2iv(location, value); // INT_VEC2\n        case 35672:\n        case 35668:\n            return gl.uniform3iv(location, value); // INT_VEC3\n        case 35673:\n        case 35669:\n            return gl.uniform4iv(location, value); // INT_VEC4\n        case 35674:\n            return gl.uniformMatrix2fv(location, false, value); // FLOAT_MAT2\n        case 35675:\n            return gl.uniformMatrix3fv(location, false, value); // FLOAT_MAT3\n        case 35676:\n            return gl.uniformMatrix4fv(location, false, value); // FLOAT_MAT4\n    }\n}\nfunction addLineNumbers(string) {\n    let lines = string.split(\"\\n\");\n    for(let i = 0; i < lines.length; i++){\n        lines[i] = i + 1 + \": \" + lines[i];\n    }\n    return lines.join(\"\\n\");\n}\nfunction flatten(a) {\n    const arrayLen = a.length;\n    const valueLen = a[0].length;\n    if (valueLen === undefined) return a;\n    const length = arrayLen * valueLen;\n    let value = arrayCacheF32[length];\n    if (!value) arrayCacheF32[length] = value = new Float32Array(length);\n    for(let i = 0; i < arrayLen; i++)value.set(a[i], i * valueLen);\n    return value;\n}\nfunction arraysEqual(a, b) {\n    if (a.length !== b.length) return false;\n    for(let i = 0, l = a.length; i < l; i++){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\nfunction setArray(a, b) {\n    for(let i = 0, l = a.length; i < l; i++){\n        a[i] = b[i];\n    }\n}\nlet warnCount = 0;\nfunction warn(message) {\n    if (warnCount > 100) return;\n    console.warn(message);\n    warnCount++;\n    if (warnCount > 100) console.warn(\"More than 100 program warnings - stopping logs.\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvUHJvZ3JhbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxxQkFBcUI7QUFFckIsSUFBSUEsS0FBSztBQUVULHVEQUF1RDtBQUN2RCxNQUFNQyxnQkFBZ0IsQ0FBQztBQUVoQixNQUFNQztJQXFEVEMsV0FBVyxLQUFvQixFQUFFO1lBQXRCLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQXBCO1FBQ1AsSUFBSUQsUUFBUTtZQUNSLHVDQUF1QztZQUN2QyxJQUFJLENBQUNFLEVBQUUsQ0FBQ0MsWUFBWSxDQUFDLElBQUksQ0FBQ0MsWUFBWSxFQUFFSjtZQUN4QyxJQUFJLENBQUNFLEVBQUUsQ0FBQ0csYUFBYSxDQUFDLElBQUksQ0FBQ0QsWUFBWTtZQUN2QyxJQUFJLElBQUksQ0FBQ0YsRUFBRSxDQUFDSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNGLFlBQVksTUFBTSxJQUFJO2dCQUNwREcsUUFBUUMsSUFBSSxDQUFDLEdBQWtFQyxPQUEvRCxJQUFJLENBQUNQLEVBQUUsQ0FBQ0ksZ0JBQWdCLENBQUMsSUFBSSxDQUFDRixZQUFZLEdBQUUscUJBQTBDLE9BQXZCSyxlQUFlVDtZQUNsRztRQUNKO1FBRUEsSUFBSUMsVUFBVTtZQUNWLHlDQUF5QztZQUN6QyxJQUFJLENBQUNDLEVBQUUsQ0FBQ0MsWUFBWSxDQUFDLElBQUksQ0FBQ08sY0FBYyxFQUFFVDtZQUMxQyxJQUFJLENBQUNDLEVBQUUsQ0FBQ0csYUFBYSxDQUFDLElBQUksQ0FBQ0ssY0FBYztZQUN6QyxJQUFJLElBQUksQ0FBQ1IsRUFBRSxDQUFDSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNJLGNBQWMsTUFBTSxJQUFJO2dCQUN0REgsUUFBUUMsSUFBSSxDQUFDLEdBQXNFQyxPQUFuRSxJQUFJLENBQUNQLEVBQUUsQ0FBQ0ksZ0JBQWdCLENBQUMsSUFBSSxDQUFDSSxjQUFjLEdB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QWEsQ0FBQ3dHLE9BQU8sR0FBR04sUUFBUSxJQUFJbUQsYUFBYTdDO0lBQzdELElBQUssSUFBSXlDLElBQUksR0FBR0EsSUFBSUUsVUFBVUYsSUFBSy9DLE1BQU14RSxHQUFHLENBQUN3SCxDQUFDLENBQUNELEVBQUUsRUFBRUEsSUFBSUc7SUFDdkQsT0FBT2xEO0FBQ1g7QUFFQSxTQUFTOEIsWUFBWWtCLENBQUMsRUFBRUksQ0FBQztJQUNyQixJQUFJSixFQUFFMUMsTUFBTSxLQUFLOEMsRUFBRTlDLE1BQU0sRUFBRSxPQUFPO0lBQ2xDLElBQUssSUFBSXlDLElBQUksR0FBR00sSUFBSUwsRUFBRTFDLE1BQU0sRUFBRXlDLElBQUlNLEdBQUdOLElBQUs7UUFDdEMsSUFBSUMsQ0FBQyxDQUFDRCxFQUFFLEtBQUtLLENBQUMsQ0FBQ0wsRUFBRSxFQUFFLE9BQU87SUFDOUI7SUFDQSxPQUFPO0FBQ1g7QUFFQSxTQUFTaEIsU0FBU2lCLENBQUMsRUFBRUksQ0FBQztJQUNsQixJQUFLLElBQUlMLElBQUksR0FBR00sSUFBSUwsRUFBRTFDLE1BQU0sRUFBRXlDLElBQUlNLEdBQUdOLElBQUs7UUFDdENDLENBQUMsQ0FBQ0QsRUFBRSxHQUFHSyxDQUFDLENBQUNMLEVBQUU7SUFDZjtBQUNKO0FBRUEsSUFBSU8sWUFBWTtBQUNoQixTQUFTN0ksS0FBSzhJLE9BQU87SUFDakIsSUFBSUQsWUFBWSxLQUFLO0lBQ3JCOUksUUFBUUMsSUFBSSxDQUFDOEk7SUFDYkQ7SUFDQSxJQUFJQSxZQUFZLEtBQUs5SSxRQUFRQyxJQUFJLENBQUM7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvY29yZS9Qcm9ncmFtLmpzPzVmNTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogdXBsb2FkIGVtcHR5IHRleHR1cmUgaWYgbnVsbCA/IG1heWJlIG5vdFxuLy8gVE9ETzogdXBsb2FkIGlkZW50aXR5IG1hdHJpeCBpZiBudWxsID9cbi8vIFRPRE86IHNhbXBsZXIgQ3ViZVxuXG5sZXQgSUQgPSAxO1xuXG4vLyBjYWNoZSBvZiB0eXBlZCBhcnJheXMgdXNlZCB0byBmbGF0dGVuIHVuaWZvcm0gYXJyYXlzXG5jb25zdCBhcnJheUNhY2hlRjMyID0ge307XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmFtIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgZ2wsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgIGZyYWdtZW50LFxuICAgICAgICAgICAgdW5pZm9ybXMgPSB7fSxcblxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgPSBmYWxzZSxcbiAgICAgICAgICAgIGN1bGxGYWNlID0gZ2wuQkFDSyxcbiAgICAgICAgICAgIGZyb250RmFjZSA9IGdsLkNDVyxcbiAgICAgICAgICAgIGRlcHRoVGVzdCA9IHRydWUsXG4gICAgICAgICAgICBkZXB0aFdyaXRlID0gdHJ1ZSxcbiAgICAgICAgICAgIGRlcHRoRnVuYyA9IGdsLkxFUVVBTCxcbiAgICAgICAgfSA9IHt9XG4gICAgKSB7XG4gICAgICAgIGlmICghZ2wuY2FudmFzKSBjb25zb2xlLmVycm9yKCdnbCBub3QgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50IHRvIFByb2dyYW0nKTtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgICAgIHRoaXMuaWQgPSBJRCsrO1xuXG4gICAgICAgIGlmICghdmVydGV4KSBjb25zb2xlLndhcm4oJ3ZlcnRleCBzaGFkZXIgbm90IHN1cHBsaWVkJyk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIGNvbnNvbGUud2FybignZnJhZ21lbnQgc2hhZGVyIG5vdCBzdXBwbGllZCcpO1xuXG4gICAgICAgIC8vIFN0b3JlIHByb2dyYW0gc3RhdGVcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IHRyYW5zcGFyZW50O1xuICAgICAgICB0aGlzLmN1bGxGYWNlID0gY3VsbEZhY2U7XG4gICAgICAgIHRoaXMuZnJvbnRGYWNlID0gZnJvbnRGYWNlO1xuICAgICAgICB0aGlzLmRlcHRoVGVzdCA9IGRlcHRoVGVzdDtcbiAgICAgICAgdGhpcy5kZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcbiAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG4gICAgICAgIHRoaXMuYmxlbmRGdW5jID0ge307XG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IHt9O1xuICAgICAgICB0aGlzLnN0ZW5jaWxGdW5jID0ge307XG4gICAgICAgIHRoaXMuc3RlbmNpbE9wID0ge31cblxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBibGVuZEZ1bmMgaWYgdHJhbnNwYXJlbnQgZmxhZ2dlZFxuICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudCAmJiAhdGhpcy5ibGVuZEZ1bmMuc3JjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nbC5yZW5kZXJlci5wcmVtdWx0aXBsaWVkQWxwaGEpIHRoaXMuc2V0QmxlbmRGdW5jKHRoaXMuZ2wuT05FLCB0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLnNldEJsZW5kRnVuYyh0aGlzLmdsLlNSQ19BTFBIQSwgdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBlbXB0eSBzaGFkZXJzIGFuZCBhdHRhY2ggdG8gcHJvZ3JhbVxuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHRoaXMudmVydGV4U2hhZGVyKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5mcmFnbWVudFNoYWRlcik7XG5cbiAgICAgICAgLy8gQ29tcGlsZSBzaGFkZXJzIHdpdGggc291cmNlXG4gICAgICAgIHRoaXMuc2V0U2hhZGVycyh7IHZlcnRleCwgZnJhZ21lbnQgfSk7XG4gICAgfVxuXG4gICAgc2V0U2hhZGVycyh7IHZlcnRleCwgZnJhZ21lbnQgfSkge1xuICAgICAgICBpZiAodmVydGV4KSB7XG4gICAgICAgICAgICAvLyBjb21waWxlIHZlcnRleCBzaGFkZXIgYW5kIGxvZyBlcnJvcnNcbiAgICAgICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHRoaXMudmVydGV4U2hhZGVyLCB2ZXJ0ZXgpO1xuICAgICAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdsLmdldFNoYWRlckluZm9Mb2codGhpcy52ZXJ0ZXhTaGFkZXIpICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHt0aGlzLmdsLmdldFNoYWRlckluZm9Mb2codGhpcy52ZXJ0ZXhTaGFkZXIpfVxcblZlcnRleCBTaGFkZXJcXG4ke2FkZExpbmVOdW1iZXJzKHZlcnRleCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyIGFuZCBsb2cgZXJyb3JzXG4gICAgICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZSh0aGlzLmZyYWdtZW50U2hhZGVyLCBmcmFnbWVudCk7XG4gICAgICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIodGhpcy5mcmFnbWVudFNoYWRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHRoaXMuZnJhZ21lbnRTaGFkZXIpICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHt0aGlzLmdsLmdldFNoYWRlckluZm9Mb2codGhpcy5mcmFnbWVudFNoYWRlcil9XFxuRnJhZ21lbnQgU2hhZGVyXFxuJHthZGRMaW5lTnVtYmVycyhmcmFnbWVudCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21waWxlIHByb2dyYW0gYW5kIGxvZyBlcnJvcnNcbiAgICAgICAgdGhpcy5nbC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICBpZiAoIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKHRoaXMuZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5wcm9ncmFtKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYWN0aXZlIHVuaWZvcm0gbG9jYXRpb25zXG4gICAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IG51bVVuaWZvcm1zID0gdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgICAgICBmb3IgKGxldCB1SW5kZXggPSAwOyB1SW5kZXggPCBudW1Vbmlmb3JtczsgdUluZGV4KyspIHtcbiAgICAgICAgICAgIGxldCB1bmlmb3JtID0gdGhpcy5nbC5nZXRBY3RpdmVVbmlmb3JtKHRoaXMucHJvZ3JhbSwgdUluZGV4KTtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9ucy5zZXQodW5pZm9ybSwgdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCB1bmlmb3JtLm5hbWUpKTtcblxuICAgICAgICAgICAgLy8gc3BsaXQgdW5pZm9ybXMnIG5hbWVzIHRvIHNlcGFyYXRlIGFycmF5IGFuZCBzdHJ1Y3QgZGVjbGFyYXRpb25zXG4gICAgICAgICAgICBjb25zdCBzcGxpdCA9IHVuaWZvcm0ubmFtZS5tYXRjaCgvKFxcdyspL2cpO1xuXG4gICAgICAgICAgICB1bmlmb3JtLnVuaWZvcm1OYW1lID0gc3BsaXRbMF07XG4gICAgICAgICAgICB1bmlmb3JtLm5hbWVDb21wb25lbnRzID0gc3BsaXQuc2xpY2UoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYWN0aXZlIGF0dHJpYnV0ZSBsb2NhdGlvbnNcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVMb2NhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBudW1BdHRyaWJzID0gdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gICAgICAgIGZvciAobGV0IGFJbmRleCA9IDA7IGFJbmRleCA8IG51bUF0dHJpYnM7IGFJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmdsLmdldEFjdGl2ZUF0dHJpYih0aGlzLnByb2dyYW0sIGFJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAvLyBJZ25vcmUgc3BlY2lhbCBidWlsdC1pbiBpbnB1dHMuIGVnIGdsX1ZlcnRleElELCBnbF9JbnN0YW5jZUlEXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IC0xKSBjb250aW51ZTtcbiAgICAgICAgICAgIGxvY2F0aW9uc1tsb2NhdGlvbl0gPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTG9jYXRpb25zLnNldChhdHRyaWJ1dGUsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9yZGVyID0gbG9jYXRpb25zLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHNldEJsZW5kRnVuYyhzcmMsIGRzdCwgc3JjQWxwaGEsIGRzdEFscGhhKSB7XG4gICAgICAgIHRoaXMuYmxlbmRGdW5jLnNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5ibGVuZEZ1bmMuZHN0ID0gZHN0O1xuICAgICAgICB0aGlzLmJsZW5kRnVuYy5zcmNBbHBoYSA9IHNyY0FscGhhO1xuICAgICAgICB0aGlzLmJsZW5kRnVuYy5kc3RBbHBoYSA9IGRzdEFscGhhO1xuICAgICAgICBpZiAoc3JjKSB0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZXRCbGVuZEVxdWF0aW9uKG1vZGVSR0IsIG1vZGVBbHBoYSkge1xuICAgICAgICB0aGlzLmJsZW5kRXF1YXRpb24ubW9kZVJHQiA9IG1vZGVSR0I7XG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbi5tb2RlQWxwaGEgPSBtb2RlQWxwaGE7XG4gICAgfVxuXG4gICAgc2V0U3RlbmNpbEZ1bmMoZnVuYywgcmVmLCBtYXNrKSB7XG4gICAgICAgIHRoaXMuc3RlbmNpbFJlZiA9IHJlZjtcbiAgICAgICAgdGhpcy5zdGVuY2lsRnVuYy5mdW5jID0gZnVuYztcbiAgICAgICAgdGhpcy5zdGVuY2lsRnVuYy5yZWYgPSByZWY7XG4gICAgICAgIHRoaXMuc3RlbmNpbEZ1bmMubWFzayA9IG1hc2s7XG4gICAgfVxuXG4gICAgc2V0U3RlbmNpbE9wKHN0ZW5jaWxGYWlsLCBkZXB0aEZhaWwsIGRlcHRoUGFzcykge1xuICAgICAgICB0aGlzLnN0ZW5jaWxPcC5zdGVuY2lsRmFpbCA9IHN0ZW5jaWxGYWlsO1xuICAgICAgICB0aGlzLnN0ZW5jaWxPcC5kZXB0aEZhaWwgPSBkZXB0aEZhaWw7XG4gICAgICAgIHRoaXMuc3RlbmNpbE9wLmRlcHRoUGFzcyA9IGRlcHRoUGFzcztcbiAgICB9XG5cbiAgICBhcHBseVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5kZXB0aFRlc3QpIHRoaXMuZ2wucmVuZGVyZXIuZW5hYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIGVsc2UgdGhpcy5nbC5yZW5kZXJlci5kaXNhYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VsbEZhY2UpIHRoaXMuZ2wucmVuZGVyZXIuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgZWxzZSB0aGlzLmdsLnJlbmRlcmVyLmRpc2FibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xuXG4gICAgICAgIGlmICh0aGlzLmJsZW5kRnVuYy5zcmMpIHRoaXMuZ2wucmVuZGVyZXIuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgICAgICBlbHNlIHRoaXMuZ2wucmVuZGVyZXIuZGlzYWJsZSh0aGlzLmdsLkJMRU5EKTtcblxuICAgICAgICBpZiAodGhpcy5jdWxsRmFjZSkgdGhpcy5nbC5yZW5kZXJlci5zZXRDdWxsRmFjZSh0aGlzLmN1bGxGYWNlKTtcbiAgICAgICAgdGhpcy5nbC5yZW5kZXJlci5zZXRGcm9udEZhY2UodGhpcy5mcm9udEZhY2UpO1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLnNldERlcHRoTWFzayh0aGlzLmRlcHRoV3JpdGUpO1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLnNldERlcHRoRnVuYyh0aGlzLmRlcHRoRnVuYyk7XG4gICAgICAgIGlmICh0aGlzLmJsZW5kRnVuYy5zcmMpIHRoaXMuZ2wucmVuZGVyZXIuc2V0QmxlbmRGdW5jKHRoaXMuYmxlbmRGdW5jLnNyYywgdGhpcy5ibGVuZEZ1bmMuZHN0LCB0aGlzLmJsZW5kRnVuYy5zcmNBbHBoYSwgdGhpcy5ibGVuZEZ1bmMuZHN0QWxwaGEpO1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLnNldEJsZW5kRXF1YXRpb24odGhpcy5ibGVuZEVxdWF0aW9uLm1vZGVSR0IsIHRoaXMuYmxlbmRFcXVhdGlvbi5tb2RlQWxwaGEpO1xuXG4gICAgICAgIGlmKHRoaXMuc3RlbmNpbEZ1bmMuZnVuYyB8fCB0aGlzLnN0ZW5jaWxPcC5zdGVuY2lsRmFpbCkgdGhpcy5nbC5yZW5kZXJlci5lbmFibGUodGhpcy5nbC5TVEVOQ0lMX1RFU1QpXG4gICAgICAgICAgICBlbHNlIHRoaXMuZ2wucmVuZGVyZXIuZGlzYWJsZSh0aGlzLmdsLlNURU5DSUxfVEVTVClcblxuICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLnNldFN0ZW5jaWxGdW5jKHRoaXMuc3RlbmNpbEZ1bmMuZnVuYywgdGhpcy5zdGVuY2lsRnVuYy5yZWYsIHRoaXMuc3RlbmNpbEZ1bmMubWFzaylcbiAgICAgICAgdGhpcy5nbC5yZW5kZXJlci5zZXRTdGVuY2lsT3AodGhpcy5zdGVuY2lsT3Auc3RlbmNpbEZhaWwsIHRoaXMuc3RlbmNpbE9wLmRlcHRoRmFpbCwgdGhpcy5zdGVuY2lsT3AuZGVwdGhQYXNzKVxuXG4gICAgfVxuXG4gICAgdXNlKHsgZmxpcEZhY2VzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIGxldCB0ZXh0dXJlVW5pdCA9IC0xO1xuICAgICAgICBjb25zdCBwcm9ncmFtQWN0aXZlID0gdGhpcy5nbC5yZW5kZXJlci5zdGF0ZS5jdXJyZW50UHJvZ3JhbSA9PT0gdGhpcy5pZDtcblxuICAgICAgICAvLyBBdm9pZCBnbCBjYWxsIGlmIHByb2dyYW0gYWxyZWFkeSBpbiB1c2VcbiAgICAgICAgaWYgKCFwcm9ncmFtQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgICAgICAgIHRoaXMuZ2wucmVuZGVyZXIuc3RhdGUuY3VycmVudFByb2dyYW0gPSB0aGlzLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IG9ubHkgdGhlIGFjdGl2ZSB1bmlmb3JtcyBmb3VuZCBpbiB0aGUgc2hhZGVyXG4gICAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9ucy5mb3JFYWNoKChsb2NhdGlvbiwgYWN0aXZlVW5pZm9ybSkgPT4ge1xuICAgICAgICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW2FjdGl2ZVVuaWZvcm0udW5pZm9ybU5hbWVdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBhY3RpdmVVbmlmb3JtLm5hbWVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlmb3JtKSBicmVhaztcblxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgaW4gdW5pZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtID0gdW5pZm9ybVtjb21wb25lbnRdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1bmlmb3JtLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YXJuKGBBY3RpdmUgdW5pZm9ybSAke2FjdGl2ZVVuaWZvcm0ubmFtZX0gaGFzIG5vdCBiZWVuIHN1cHBsaWVkYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1bmlmb3JtICYmIHVuaWZvcm0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YXJuKGAke2FjdGl2ZVVuaWZvcm0ubmFtZX0gdW5pZm9ybSBpcyBtaXNzaW5nIGEgdmFsdWUgcGFyYW1ldGVyYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1bmlmb3JtLnZhbHVlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0ICsgMTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRleHR1cmUgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHVuaWZvcm0udmFsdWUudXBkYXRlKHRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0VW5pZm9ybSh0aGlzLmdsLCBhY3RpdmVVbmlmb3JtLnR5cGUsIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciB0ZXh0dXJlIGFycmF5cywgc2V0IHVuaWZvcm0gYXMgYW4gYXJyYXkgb2YgdGV4dHVyZSB1bml0cyBpbnN0ZWFkIG9mIGp1c3Qgb25lXG4gICAgICAgICAgICBpZiAodW5pZm9ybS52YWx1ZS5sZW5ndGggJiYgdW5pZm9ybS52YWx1ZVswXS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZVVuaXRzID0gW107XG4gICAgICAgICAgICAgICAgdW5pZm9ybS52YWx1ZS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudXBkYXRlKHRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVVuaXRzLnB1c2godGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFVuaWZvcm0odGhpcy5nbCwgYWN0aXZlVW5pZm9ybS50eXBlLCBsb2NhdGlvbiwgdGV4dHVyZVVuaXRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VW5pZm9ybSh0aGlzLmdsLCBhY3RpdmVVbmlmb3JtLnR5cGUsIGxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hcHBseVN0YXRlKCk7XG4gICAgICAgIGlmIChmbGlwRmFjZXMpIHRoaXMuZ2wucmVuZGVyZXIuc2V0RnJvbnRGYWNlKHRoaXMuZnJvbnRGYWNlID09PSB0aGlzLmdsLkNDVyA/IHRoaXMuZ2wuQ1cgOiB0aGlzLmdsLkNDVyk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKCkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldFVuaWZvcm0oZ2wsIHR5cGUsIGxvY2F0aW9uLCB2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUubGVuZ3RoID8gZmxhdHRlbih2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IGdsLnJlbmRlcmVyLnN0YXRlLnVuaWZvcm1Mb2NhdGlvbnMuZ2V0KGxvY2F0aW9uKTtcblxuICAgIC8vIEF2b2lkIHJlZHVuZGFudCB1bmlmb3JtIGNvbW1hbmRzXG4gICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoc2V0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzZXRWYWx1ZS5sZW5ndGggIT09IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gY2xvbmUgYXJyYXkgdG8gc3RvcmUgYXMgY2FjaGVcbiAgICAgICAgICAgIGdsLnJlbmRlcmVyLnN0YXRlLnVuaWZvcm1Mb2NhdGlvbnMuc2V0KGxvY2F0aW9uLCB2YWx1ZS5zbGljZSgwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlzRXF1YWwoc2V0VmFsdWUsIHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2FjaGVkIGFycmF5IHZhbHVlc1xuICAgICAgICAgICAgc2V0VmFsdWUuc2V0ID8gc2V0VmFsdWUuc2V0KHZhbHVlKSA6IHNldEFycmF5KHNldFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBnbC5yZW5kZXJlci5zdGF0ZS51bmlmb3JtTG9jYXRpb25zLnNldChsb2NhdGlvbiwgc2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNldFZhbHVlID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICBnbC5yZW5kZXJlci5zdGF0ZS51bmlmb3JtTG9jYXRpb25zLnNldChsb2NhdGlvbiwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDUxMjY6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID8gZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdmFsdWUpIDogZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7IC8vIEZMT0FUXG4gICAgICAgIGNhc2UgMzU2NjQ6XG4gICAgICAgICAgICByZXR1cm4gZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpOyAvLyBGTE9BVF9WRUMyXG4gICAgICAgIGNhc2UgMzU2NjU6XG4gICAgICAgICAgICByZXR1cm4gZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdmFsdWUpOyAvLyBGTE9BVF9WRUMzXG4gICAgICAgIGNhc2UgMzU2NjY6XG4gICAgICAgICAgICByZXR1cm4gZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpOyAvLyBGTE9BVF9WRUM0XG4gICAgICAgIGNhc2UgMzU2NzA6IC8vIEJPT0xcbiAgICAgICAgY2FzZSA1MTI0OiAvLyBJTlRcbiAgICAgICAgY2FzZSAzNTY3ODogLy8gU0FNUExFUl8yRFxuICAgICAgICBjYXNlIDM2MzA2OiAvLyBVX1NBTVBMRVJfMkRcbiAgICAgICAgY2FzZSAzNTY4MDogLy8gU0FNUExFUl9DVUJFXG4gICAgICAgIGNhc2UgMzYyODk6IC8vIFNBTVBMRVJfMkRfQVJSQVlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSkgOiBnbC51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlKTsgLy8gU0FNUExFUl9DVUJFXG4gICAgICAgIGNhc2UgMzU2NzE6IC8vIEJPT0xfVkVDMlxuICAgICAgICBjYXNlIDM1NjY3OlxuICAgICAgICAgICAgcmV0dXJuIGdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHZhbHVlKTsgLy8gSU5UX1ZFQzJcbiAgICAgICAgY2FzZSAzNTY3MjogLy8gQk9PTF9WRUMzXG4gICAgICAgIGNhc2UgMzU2Njg6XG4gICAgICAgICAgICByZXR1cm4gZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdmFsdWUpOyAvLyBJTlRfVkVDM1xuICAgICAgICBjYXNlIDM1NjczOiAvLyBCT09MX1ZFQzRcbiAgICAgICAgY2FzZSAzNTY2OTpcbiAgICAgICAgICAgIHJldHVybiBnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2YWx1ZSk7IC8vIElOVF9WRUM0XG4gICAgICAgIGNhc2UgMzU2NzQ6XG4gICAgICAgICAgICByZXR1cm4gZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTsgLy8gRkxPQVRfTUFUMlxuICAgICAgICBjYXNlIDM1Njc1OlxuICAgICAgICAgICAgcmV0dXJuIGdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7IC8vIEZMT0FUX01BVDNcbiAgICAgICAgY2FzZSAzNTY3NjpcbiAgICAgICAgICAgIHJldHVybiBnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpOyAvLyBGTE9BVF9NQVQ0XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRMaW5lTnVtYmVycyhzdHJpbmcpIHtcbiAgICBsZXQgbGluZXMgPSBzdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZXNbaV0gPSBpICsgMSArICc6ICcgKyBsaW5lc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuKGEpIHtcbiAgICBjb25zdCBhcnJheUxlbiA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IHZhbHVlTGVuID0gYVswXS5sZW5ndGg7XG4gICAgaWYgKHZhbHVlTGVuID09PSB1bmRlZmluZWQpIHJldHVybiBhO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5TGVuICogdmFsdWVMZW47XG4gICAgbGV0IHZhbHVlID0gYXJyYXlDYWNoZUYzMltsZW5ndGhdO1xuICAgIGlmICghdmFsdWUpIGFycmF5Q2FjaGVGMzJbbGVuZ3RoXSA9IHZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlMZW47IGkrKykgdmFsdWUuc2V0KGFbaV0sIGkgKiB2YWx1ZUxlbik7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldEFycmF5KGEsIGIpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGFbaV0gPSBiW2ldO1xuICAgIH1cbn1cblxubGV0IHdhcm5Db3VudCA9IDA7XG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICBpZiAod2FybkNvdW50ID4gMTAwKSByZXR1cm47XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHdhcm5Db3VudCsrO1xuICAgIGlmICh3YXJuQ291bnQgPiAxMDApIGNvbnNvbGUud2FybignTW9yZSB0aGFuIDEwMCBwcm9ncmFtIHdhcm5pbmdzIC0gc3RvcHBpbmcgbG9ncy4nKTtcbn1cbiJdLCJuYW1lcyI6WyJJRCIsImFycmF5Q2FjaGVGMzIiLCJQcm9ncmFtIiwic2V0U2hhZGVycyIsInZlcnRleCIsImZyYWdtZW50IiwiZ2wiLCJzaGFkZXJTb3VyY2UiLCJ2ZXJ0ZXhTaGFkZXIiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVySW5mb0xvZyIsImNvbnNvbGUiLCJ3YXJuIiwiYWRkTGluZU51bWJlcnMiLCJmcmFnbWVudFNoYWRlciIsImxpbmtQcm9ncmFtIiwicHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwidW5pZm9ybUxvY2F0aW9ucyIsIk1hcCIsIm51bVVuaWZvcm1zIiwiQUNUSVZFX1VOSUZPUk1TIiwidUluZGV4IiwidW5pZm9ybSIsImdldEFjdGl2ZVVuaWZvcm0iLCJzZXQiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJuYW1lIiwic3BsaXQiLCJtYXRjaCIsInVuaWZvcm1OYW1lIiwibmFtZUNvbXBvbmVudHMiLCJzbGljZSIsImF0dHJpYnV0ZUxvY2F0aW9ucyIsImxvY2F0aW9ucyIsIm51bUF0dHJpYnMiLCJBQ1RJVkVfQVRUUklCVVRFUyIsImFJbmRleCIsImF0dHJpYnV0ZSIsImdldEFjdGl2ZUF0dHJpYiIsImxvY2F0aW9uIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJhdHRyaWJ1dGVPcmRlciIsImpvaW4iLCJzZXRCbGVuZEZ1bmMiLCJzcmMiLCJkc3QiLCJzcmNBbHBoYSIsImRzdEFscGhhIiwiYmxlbmRGdW5jIiwidHJhbnNwYXJlbnQiLCJzZXRCbGVuZEVxdWF0aW9uIiwibW9kZVJHQiIsIm1vZGVBbHBoYSIsImJsZW5kRXF1YXRpb24iLCJzZXRTdGVuY2lsRnVuYyIsImZ1bmMiLCJyZWYiLCJtYXNrIiwic3RlbmNpbFJlZiIsInN0ZW5jaWxGdW5jIiwic2V0U3RlbmNpbE9wIiwic3RlbmNpbEZhaWwiLCJkZXB0aEZhaWwiLCJkZXB0aFBhc3MiLCJzdGVuY2lsT3AiLCJhcHBseVN0YXRlIiwiZGVwdGhUZXN0IiwicmVuZGVyZXIiLCJlbmFibGUiLCJERVBUSF9URVNUIiwiZGlzYWJsZSIsImN1bGxGYWNlIiwiQ1VMTF9GQUNFIiwiQkxFTkQiLCJzZXRDdWxsRmFjZSIsInNldEZyb250RmFjZSIsImZyb250RmFjZSIsInNldERlcHRoTWFzayIsImRlcHRoV3JpdGUiLCJzZXREZXB0aEZ1bmMiLCJkZXB0aEZ1bmMiLCJTVEVOQ0lMX1RFU1QiLCJ1c2UiLCJmbGlwRmFjZXMiLCJ0ZXh0dXJlVW5pdCIsInByb2dyYW1BY3RpdmUiLCJzdGF0ZSIsImN1cnJlbnRQcm9ncmFtIiwiaWQiLCJ1c2VQcm9ncmFtIiwiZm9yRWFjaCIsImFjdGl2ZVVuaWZvcm0iLCJ1bmlmb3JtcyIsImNvbXBvbmVudCIsIkFycmF5IiwiaXNBcnJheSIsInZhbHVlIiwidW5kZWZpbmVkIiwidGV4dHVyZSIsInVwZGF0ZSIsInNldFVuaWZvcm0iLCJ0eXBlIiwibGVuZ3RoIiwidGV4dHVyZVVuaXRzIiwicHVzaCIsIkNDVyIsIkNXIiwicmVtb3ZlIiwiZGVsZXRlUHJvZ3JhbSIsImNvbnN0cnVjdG9yIiwiQkFDSyIsIkxFUVVBTCIsImNhbnZhcyIsImVycm9yIiwicHJlbXVsdGlwbGllZEFscGhhIiwiT05FIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsIlNSQ19BTFBIQSIsImNyZWF0ZVNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJGUkFHTUVOVF9TSEFERVIiLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwiZmxhdHRlbiIsInNldFZhbHVlIiwiZ2V0IiwiYXJyYXlzRXF1YWwiLCJzZXRBcnJheSIsInVuaWZvcm0xZnYiLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtMmZ2IiwidW5pZm9ybTNmdiIsInVuaWZvcm00ZnYiLCJ1bmlmb3JtMWl2IiwidW5pZm9ybTFpIiwidW5pZm9ybTJpdiIsInVuaWZvcm0zaXYiLCJ1bmlmb3JtNGl2IiwidW5pZm9ybU1hdHJpeDJmdiIsInVuaWZvcm1NYXRyaXgzZnYiLCJ1bmlmb3JtTWF0cml4NGZ2Iiwic3RyaW5nIiwibGluZXMiLCJpIiwiYSIsImFycmF5TGVuIiwidmFsdWVMZW4iLCJGbG9hdDMyQXJyYXkiLCJiIiwibCIsIndhcm5Db3VudCIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/core/Program.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/core/Renderer.js":
/*!***********************************************!*\
  !*** ./node_modules/ogl/src/core/Renderer.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; }\n/* harmony export */ });\n/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vec3.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Vec3.js\");\n\n// TODO: Handle context loss https://www.khronos.org/webgl/wiki/HandlingContextLost\n// Not automatic - devs to use these methods manually\n// gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n// gl.clearColor( r, g, b, a );\n// gl.stencilMask( stencilMask );\n// gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n// gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n// gl.clearStencil( stencil );\nconst tempVec3 = /* @__PURE__ */ new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nlet ID = 1;\nclass Renderer {\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n        this.gl.canvas.width = width * this.dpr;\n        this.gl.canvas.height = height * this.dpr;\n        if (!this.gl.canvas.style) return;\n        Object.assign(this.gl.canvas.style, {\n            width: width + \"px\",\n            height: height + \"px\"\n        });\n    }\n    setViewport(width, height) {\n        let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n        if (this.state.viewport.width === width && this.state.viewport.height === height) return;\n        this.state.viewport.width = width;\n        this.state.viewport.height = height;\n        this.state.viewport.x = x;\n        this.state.viewport.y = y;\n        this.gl.viewport(x, y, width, height);\n    }\n    setScissor(width, height) {\n        let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n        this.gl.scissor(x, y, width, height);\n    }\n    enable(id) {\n        if (this.state[id] === true) return;\n        this.gl.enable(id);\n        this.state[id] = true;\n    }\n    disable(id) {\n        if (this.state[id] === false) return;\n        this.gl.disable(id);\n        this.state[id] = false;\n    }\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        if (this.state.blendFunc.src === src && this.state.blendFunc.dst === dst && this.state.blendFunc.srcAlpha === srcAlpha && this.state.blendFunc.dstAlpha === dstAlpha) return;\n        this.state.blendFunc.src = src;\n        this.state.blendFunc.dst = dst;\n        this.state.blendFunc.srcAlpha = srcAlpha;\n        this.state.blendFunc.dstAlpha = dstAlpha;\n        if (srcAlpha !== undefined) this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);\n        else this.gl.blendFunc(src, dst);\n    }\n    setBlendEquation(modeRGB, modeAlpha) {\n        modeRGB = modeRGB || this.gl.FUNC_ADD;\n        if (this.state.blendEquation.modeRGB === modeRGB && this.state.blendEquation.modeAlpha === modeAlpha) return;\n        this.state.blendEquation.modeRGB = modeRGB;\n        this.state.blendEquation.modeAlpha = modeAlpha;\n        if (modeAlpha !== undefined) this.gl.blendEquationSeparate(modeRGB, modeAlpha);\n        else this.gl.blendEquation(modeRGB);\n    }\n    setCullFace(value) {\n        if (this.state.cullFace === value) return;\n        this.state.cullFace = value;\n        this.gl.cullFace(value);\n    }\n    setFrontFace(value) {\n        if (this.state.frontFace === value) return;\n        this.state.frontFace = value;\n        this.gl.frontFace(value);\n    }\n    setDepthMask(value) {\n        if (this.state.depthMask === value) return;\n        this.state.depthMask = value;\n        this.gl.depthMask(value);\n    }\n    setDepthFunc(value) {\n        if (this.state.depthFunc === value) return;\n        this.state.depthFunc = value;\n        this.gl.depthFunc(value);\n    }\n    setStencilMask(value) {\n        if (this.state.stencilMask === value) return;\n        this.state.stencilMask = value;\n        this.gl.stencilMask(value);\n    }\n    setStencilFunc(func, ref, mask) {\n        if (this.state.stencilFunc === func && this.state.stencilRef === ref && this.state.stencilFuncMask === mask) return;\n        this.state.stencilFunc = func || this.gl.ALWAYS;\n        this.state.stencilRef = ref || 0;\n        this.state.stencilFuncMask = mask || 0;\n        this.gl.stencilFunc(func || this.gl.ALWAYS, ref || 0, mask || 0);\n    }\n    setStencilOp(stencilFail, depthFail, depthPass) {\n        if (this.state.stencilFail === stencilFail && this.state.stencilDepthFail === depthFail && this.state.stencilDepthPass === depthPass) return;\n        this.state.stencilFail = stencilFail;\n        this.state.stencilDepthFail = depthFail;\n        this.state.stencilDepthPass = depthPass;\n        this.gl.stencilOp(stencilFail, depthFail, depthPass);\n    }\n    activeTexture(value) {\n        if (this.state.activeTextureUnit === value) return;\n        this.state.activeTextureUnit = value;\n        this.gl.activeTexture(this.gl.TEXTURE0 + value);\n    }\n    bindFramebuffer() {\n        let { target = this.gl.FRAMEBUFFER, buffer = null } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (this.state.framebuffer === buffer) return;\n        this.state.framebuffer = buffer;\n        this.gl.bindFramebuffer(target, buffer);\n    }\n    getExtension(extension, webgl2Func, extFunc) {\n        // if webgl2 function supported, return func bound to gl context\n        if (webgl2Func && this.gl[webgl2Func]) return this.gl[webgl2Func].bind(this.gl);\n        // fetch extension once only\n        if (!this.extensions[extension]) {\n            this.extensions[extension] = this.gl.getExtension(extension);\n        }\n        // return extension if no function requested\n        if (!webgl2Func) return this.extensions[extension];\n        // Return null if extension not supported\n        if (!this.extensions[extension]) return null;\n        // return extension function, bound to extension\n        return this.extensions[extension][extFunc].bind(this.extensions[extension]);\n    }\n    sortOpaque(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else if (a.zDepth !== b.zDepth) {\n            return a.zDepth - b.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n    sortTransparent(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        }\n        if (a.zDepth !== b.zDepth) {\n            return b.zDepth - a.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n    sortUI(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else {\n            return b.id - a.id;\n        }\n    }\n    getRenderList(param) {\n        let { scene, camera, frustumCull, sort } = param;\n        let renderList = [];\n        if (camera && frustumCull) camera.updateFrustum();\n        // Get visible\n        scene.traverse((node)=>{\n            if (!node.visible) return true;\n            if (!node.draw) return;\n            if (frustumCull && node.frustumCulled && camera) {\n                if (!camera.frustumIntersectsMesh(node)) return;\n            }\n            renderList.push(node);\n        });\n        if (sort) {\n            const opaque = [];\n            const transparent = []; // depthTest true\n            const ui = []; // depthTest false\n            renderList.forEach((node)=>{\n                // Split into the 3 render groups\n                if (!node.program.transparent) {\n                    opaque.push(node);\n                } else if (node.program.depthTest) {\n                    transparent.push(node);\n                } else {\n                    ui.push(node);\n                }\n                node.zDepth = 0;\n                // Only calculate z-depth if renderOrder unset and depthTest is true\n                if (node.renderOrder !== 0 || !node.program.depthTest || !camera) return;\n                // update z-depth\n                node.worldMatrix.getTranslation(tempVec3);\n                tempVec3.applyMatrix4(camera.projectionViewMatrix);\n                node.zDepth = tempVec3.z;\n            });\n            opaque.sort(this.sortOpaque);\n            transparent.sort(this.sortTransparent);\n            ui.sort(this.sortUI);\n            renderList = opaque.concat(transparent, ui);\n        }\n        return renderList;\n    }\n    render(param) {\n        let { scene, camera, target = null, update = true, sort = true, frustumCull = true, clear } = param;\n        if (target === null) {\n            // make sure no render target bound so draws to canvas\n            this.bindFramebuffer();\n            this.setViewport(this.width * this.dpr, this.height * this.dpr);\n        } else {\n            // bind supplied render target and update viewport\n            this.bindFramebuffer(target);\n            this.setViewport(target.width, target.height);\n        }\n        if (clear || this.autoClear && clear !== false) {\n            // Ensure depth buffer writing is enabled so it can be cleared\n            if (this.depth && (!target || target.depth)) {\n                this.enable(this.gl.DEPTH_TEST);\n                this.setDepthMask(true);\n            }\n            // Same for stencil\n            if (this.stencil || !target || target.stencil) {\n                this.enable(this.gl.STENCIL_TEST);\n                this.setStencilMask(0xff);\n            }\n            this.gl.clear((this.color ? this.gl.COLOR_BUFFER_BIT : 0) | (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));\n        }\n        // updates all scene graph matrices\n        if (update) scene.updateMatrixWorld();\n        // Update camera separately, in case not in scene graph\n        if (camera) camera.updateMatrixWorld();\n        // Get render list - entails culling and sorting\n        const renderList = this.getRenderList({\n            scene,\n            camera,\n            frustumCull,\n            sort\n        });\n        renderList.forEach((node)=>{\n            node.draw({\n                camera\n            });\n        });\n    }\n    constructor({ canvas = document.createElement(\"canvas\"), width = 300, height = 150, dpr = 1, alpha = false, depth = true, stencil = false, antialias = false, premultipliedAlpha = false, preserveDrawingBuffer = false, powerPreference = \"default\", autoClear = true, webgl = 2 } = {}){\n        const attributes = {\n            alpha,\n            depth,\n            stencil,\n            antialias,\n            premultipliedAlpha,\n            preserveDrawingBuffer,\n            powerPreference\n        };\n        this.dpr = dpr;\n        this.alpha = alpha;\n        this.color = true;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.premultipliedAlpha = premultipliedAlpha;\n        this.autoClear = autoClear;\n        this.id = ID++;\n        // Attempt WebGL2 unless forced to 1, if not supported fallback to WebGL1\n        if (webgl === 2) this.gl = canvas.getContext(\"webgl2\", attributes);\n        this.isWebgl2 = !!this.gl;\n        if (!this.gl) this.gl = canvas.getContext(\"webgl\", attributes);\n        if (!this.gl) console.error(\"unable to create webgl context\");\n        // Attach renderer to gl so that all classes have access to internal state functions\n        this.gl.renderer = this;\n        // initialise size values\n        this.setSize(width, height);\n        // gl state stores to avoid redundant calls on methods used internally\n        this.state = {};\n        this.state.blendFunc = {\n            src: this.gl.ONE,\n            dst: this.gl.ZERO\n        };\n        this.state.blendEquation = {\n            modeRGB: this.gl.FUNC_ADD\n        };\n        this.state.cullFace = false;\n        this.state.frontFace = this.gl.CCW;\n        this.state.depthMask = true;\n        this.state.depthFunc = this.gl.LEQUAL;\n        this.state.premultiplyAlpha = false;\n        this.state.flipY = false;\n        this.state.unpackAlignment = 4;\n        this.state.framebuffer = null;\n        this.state.viewport = {\n            x: 0,\n            y: 0,\n            width: null,\n            height: null\n        };\n        this.state.textureUnits = [];\n        this.state.activeTextureUnit = 0;\n        this.state.boundBuffer = null;\n        this.state.uniformLocations = new Map();\n        this.state.currentProgram = null;\n        // store requested extensions\n        this.extensions = {};\n        // Initialise extra format types\n        if (this.isWebgl2) {\n            this.getExtension(\"EXT_color_buffer_float\");\n            this.getExtension(\"OES_texture_float_linear\");\n        } else {\n            this.getExtension(\"OES_texture_float\");\n            this.getExtension(\"OES_texture_float_linear\");\n            this.getExtension(\"OES_texture_half_float\");\n            this.getExtension(\"OES_texture_half_float_linear\");\n            this.getExtension(\"OES_element_index_uint\");\n            this.getExtension(\"OES_standard_derivatives\");\n            this.getExtension(\"EXT_sRGB\");\n            this.getExtension(\"WEBGL_depth_texture\");\n            this.getExtension(\"WEBGL_draw_buffers\");\n        }\n        this.getExtension(\"WEBGL_compressed_texture_astc\");\n        this.getExtension(\"EXT_texture_compression_bptc\");\n        this.getExtension(\"WEBGL_compressed_texture_s3tc\");\n        this.getExtension(\"WEBGL_compressed_texture_etc1\");\n        this.getExtension(\"WEBGL_compressed_texture_pvrtc\");\n        this.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");\n        // Create method aliases using extension (WebGL1) or native if available (WebGL2)\n        this.vertexAttribDivisor = this.getExtension(\"ANGLE_instanced_arrays\", \"vertexAttribDivisor\", \"vertexAttribDivisorANGLE\");\n        this.drawArraysInstanced = this.getExtension(\"ANGLE_instanced_arrays\", \"drawArraysInstanced\", \"drawArraysInstancedANGLE\");\n        this.drawElementsInstanced = this.getExtension(\"ANGLE_instanced_arrays\", \"drawElementsInstanced\", \"drawElementsInstancedANGLE\");\n        this.createVertexArray = this.getExtension(\"OES_vertex_array_object\", \"createVertexArray\", \"createVertexArrayOES\");\n        this.bindVertexArray = this.getExtension(\"OES_vertex_array_object\", \"bindVertexArray\", \"bindVertexArrayOES\");\n        this.deleteVertexArray = this.getExtension(\"OES_vertex_array_object\", \"deleteVertexArray\", \"deleteVertexArrayOES\");\n        this.drawBuffers = this.getExtension(\"WEBGL_draw_buffers\", \"drawBuffers\", \"drawBuffersWEBGL\");\n        // Store device parameters\n        this.parameters = {};\n        this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n        this.parameters.maxAnisotropy = this.getExtension(\"EXT_texture_filter_anisotropic\") ? this.gl.getParameter(this.getExtension(\"EXT_texture_filter_anisotropic\").MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvUmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFFdkMsbUZBQW1GO0FBRW5GLHFEQUFxRDtBQUNyRCw4REFBOEQ7QUFDOUQsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQywwREFBMEQ7QUFDMUQsMkRBQTJEO0FBQzNELDhCQUE4QjtBQUU5QixNQUFNQyxXQUFXLGFBQWEsR0FBRyxJQUFJRCwrQ0FBSUE7QUFDekMsSUFBSUUsS0FBSztBQUVGLE1BQU1DO0lBbUdUQyxRQUFRQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFFZCxJQUFJLENBQUNDLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDSCxLQUFLLEdBQUdBLFFBQVEsSUFBSSxDQUFDSSxHQUFHO1FBQ3ZDLElBQUksQ0FBQ0YsRUFBRSxDQUFDQyxNQUFNLENBQUNGLE1BQU0sR0FBR0EsU0FBUyxJQUFJLENBQUNHLEdBQUc7UUFFekMsSUFBSSxDQUFDLElBQUksQ0FBQ0YsRUFBRSxDQUFDQyxNQUFNLENBQUNFLEtBQUssRUFBRTtRQUMzQkMsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ0wsRUFBRSxDQUFDQyxNQUFNLENBQUNFLEtBQUssRUFBRTtZQUNoQ0wsT0FBT0EsUUFBUTtZQUNmQyxRQUFRQSxTQUFTO1FBQ3JCO0lBQ0o7SUFFQU8sWUFBWVIsS0FBSyxFQUFFQyxNQUFNLEVBQWdCO1lBQWRRLElBQUFBLGlFQUFJLEdBQUdDLElBQUFBLGlFQUFJO1FBQ2xDLElBQUksSUFBSSxDQUFDQyxLQUFLLENBQUNDLFFBQVEsQ0FBQ1osS0FBSyxLQUFLQSxTQUFTLElBQUksQ0FBQ1csS0FBSyxDQUFDQyxRQUFRLENBQUNYLE1BQU0sS0FBS0EsUUFBUTtRQUNsRixJQUFJLENBQUNVLEtBQUssQ0FBQ0MsUUFBUSxDQUFDWixLQUFL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VUFBVSxDQUFDSSxhQUFhLEdBQUcsSUFBSSxDQUFDMUYsWUFBWSxDQUFDLG9DQUM1QyxJQUFJLENBQUNoRSxFQUFFLENBQUN3SixZQUFZLENBQUMsSUFBSSxDQUFDeEYsWUFBWSxDQUFDLGtDQUFrQzJGLDhCQUE4QixJQUN2RztJQUNWO0FBOFJKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvUmVuZGVyZXIuanM/MWVjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWMzIH0gZnJvbSAnLi4vbWF0aC9WZWMzLmpzJztcblxuLy8gVE9ETzogSGFuZGxlIGNvbnRleHQgbG9zcyBodHRwczovL3d3dy5raHJvbm9zLm9yZy93ZWJnbC93aWtpL0hhbmRsaW5nQ29udGV4dExvc3RcblxuLy8gTm90IGF1dG9tYXRpYyAtIGRldnMgdG8gdXNlIHRoZXNlIG1ldGhvZHMgbWFudWFsbHlcbi8vIGdsLmNvbG9yTWFzayggY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrICk7XG4vLyBnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG4vLyBnbC5zdGVuY2lsTWFzayggc3RlbmNpbE1hc2sgKTtcbi8vIGdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcbi8vIGdsLnN0ZW5jaWxPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XG4vLyBnbC5jbGVhclN0ZW5jaWwoIHN0ZW5jaWwgKTtcblxuY29uc3QgdGVtcFZlYzMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlYzMoKTtcbmxldCBJRCA9IDE7XG5cbmV4cG9ydCBjbGFzcyBSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgd2lkdGggPSAzMDAsXG4gICAgICAgIGhlaWdodCA9IDE1MCxcbiAgICAgICAgZHByID0gMSxcbiAgICAgICAgYWxwaGEgPSBmYWxzZSxcbiAgICAgICAgZGVwdGggPSB0cnVlLFxuICAgICAgICBzdGVuY2lsID0gZmFsc2UsXG4gICAgICAgIGFudGlhbGlhcyA9IGZhbHNlLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGEgPSBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2UsXG4gICAgICAgIHBvd2VyUHJlZmVyZW5jZSA9ICdkZWZhdWx0JyxcbiAgICAgICAgYXV0b0NsZWFyID0gdHJ1ZSxcbiAgICAgICAgd2ViZ2wgPSAyLFxuICAgIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0geyBhbHBoYSwgZGVwdGgsIHN0ZW5jaWwsIGFudGlhbGlhcywgcHJlbXVsdGlwbGllZEFscGhhLCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIsIHBvd2VyUHJlZmVyZW5jZSB9O1xuICAgICAgICB0aGlzLmRwciA9IGRwcjtcbiAgICAgICAgdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgICAgICB0aGlzLmNvbG9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLnN0ZW5jaWwgPSBzdGVuY2lsO1xuICAgICAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcbiAgICAgICAgdGhpcy5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG4gICAgICAgIHRoaXMuaWQgPSBJRCsrO1xuXG4gICAgICAgIC8vIEF0dGVtcHQgV2ViR0wyIHVubGVzcyBmb3JjZWQgdG8gMSwgaWYgbm90IHN1cHBvcnRlZCBmYWxsYmFjayB0byBXZWJHTDFcbiAgICAgICAgaWYgKHdlYmdsID09PSAyKSB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmlzV2ViZ2wyID0gISF0aGlzLmdsO1xuICAgICAgICBpZiAoIXRoaXMuZ2wpIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKCF0aGlzLmdsKSBjb25zb2xlLmVycm9yKCd1bmFibGUgdG8gY3JlYXRlIHdlYmdsIGNvbnRleHQnKTtcblxuICAgICAgICAvLyBBdHRhY2ggcmVuZGVyZXIgdG8gZ2wgc28gdGhhdCBhbGwgY2xhc3NlcyBoYXZlIGFjY2VzcyB0byBpbnRlcm5hbCBzdGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgdGhpcy5nbC5yZW5kZXJlciA9IHRoaXM7XG5cbiAgICAgICAgLy8gaW5pdGlhbGlzZSBzaXplIHZhbHVlc1xuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gZ2wgc3RhdGUgc3RvcmVzIHRvIGF2b2lkIHJlZHVuZGFudCBjYWxscyBvbiBtZXRob2RzIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIHRoaXMuc3RhdGUuYmxlbmRGdW5jID0geyBzcmM6IHRoaXMuZ2wuT05FLCBkc3Q6IHRoaXMuZ2wuWkVSTyB9O1xuICAgICAgICB0aGlzLnN0YXRlLmJsZW5kRXF1YXRpb24gPSB7IG1vZGVSR0I6IHRoaXMuZ2wuRlVOQ19BREQgfTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jdWxsRmFjZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlLmZyb250RmFjZSA9IHRoaXMuZ2wuQ0NXO1xuICAgICAgICB0aGlzLnN0YXRlLmRlcHRoTWFzayA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZGVwdGhGdW5jID0gdGhpcy5nbC5MRVFVQUw7XG4gICAgICAgIHRoaXMuc3RhdGUucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlLmZsaXBZID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUudW5wYWNrQWxpZ25tZW50ID0gNDtcbiAgICAgICAgdGhpcy5zdGF0ZS5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUudmlld3BvcnQgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwgfTtcbiAgICAgICAgdGhpcy5zdGF0ZS50ZXh0dXJlVW5pdHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZS5hY3RpdmVUZXh0dXJlVW5pdCA9IDA7XG4gICAgICAgIHRoaXMuc3RhdGUuYm91bmRCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlLnVuaWZvcm1Mb2NhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFByb2dyYW0gPSBudWxsO1xuXG4gICAgICAgIC8vIHN0b3JlIHJlcXVlc3RlZCBleHRlbnNpb25zXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgICAgIC8vIEluaXRpYWxpc2UgZXh0cmEgZm9ybWF0IHR5cGVzXG4gICAgICAgIGlmICh0aGlzLmlzV2ViZ2wyKSB7XG4gICAgICAgICAgICB0aGlzLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG4gICAgICAgICAgICB0aGlzLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyk7XG4gICAgICAgICAgICB0aGlzLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyk7XG4gICAgICAgICAgICB0aGlzLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpO1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpO1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ0VYVF9zUkdCJyk7XG4gICAgICAgICAgICB0aGlzLmdldEV4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpO1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YycpO1xuICAgICAgICB0aGlzLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0YycpO1xuICAgICAgICB0aGlzLmdldEV4dGVuc2lvbignV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKTtcbiAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyk7XG4gICAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcbiAgICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcblxuICAgICAgICAvLyBDcmVhdGUgbWV0aG9kIGFsaWFzZXMgdXNpbmcgZXh0ZW5zaW9uIChXZWJHTDEpIG9yIG5hdGl2ZSBpZiBhdmFpbGFibGUgKFdlYkdMMilcbiAgICAgICAgdGhpcy52ZXJ0ZXhBdHRyaWJEaXZpc29yID0gdGhpcy5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnLCAndmVydGV4QXR0cmliRGl2aXNvcicsICd2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUnKTtcbiAgICAgICAgdGhpcy5kcmF3QXJyYXlzSW5zdGFuY2VkID0gdGhpcy5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnLCAnZHJhd0FycmF5c0luc3RhbmNlZCcsICdkcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUnKTtcbiAgICAgICAgdGhpcy5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSB0aGlzLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycsICdkcmF3RWxlbWVudHNJbnN0YW5jZWQnLCAnZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUnKTtcbiAgICAgICAgdGhpcy5jcmVhdGVWZXJ0ZXhBcnJheSA9IHRoaXMuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcsICdjcmVhdGVWZXJ0ZXhBcnJheScsICdjcmVhdGVWZXJ0ZXhBcnJheU9FUycpO1xuICAgICAgICB0aGlzLmJpbmRWZXJ0ZXhBcnJheSA9IHRoaXMuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcsICdiaW5kVmVydGV4QXJyYXknLCAnYmluZFZlcnRleEFycmF5T0VTJyk7XG4gICAgICAgIHRoaXMuZGVsZXRlVmVydGV4QXJyYXkgPSB0aGlzLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCAnZGVsZXRlVmVydGV4QXJyYXknLCAnZGVsZXRlVmVydGV4QXJyYXlPRVMnKTtcbiAgICAgICAgdGhpcy5kcmF3QnVmZmVycyA9IHRoaXMuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnLCAnZHJhd0J1ZmZlcnMnLCAnZHJhd0J1ZmZlcnNXRUJHTCcpO1xuXG4gICAgICAgIC8vIFN0b3JlIGRldmljZSBwYXJhbWV0ZXJzXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMubWF4VGV4dHVyZVVuaXRzID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5tYXhBbmlzb3Ryb3B5ID0gdGhpcy5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpXG4gICAgICAgICAgICA/IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKS5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5nbC5jYW52YXMud2lkdGggPSB3aWR0aCAqIHRoaXMuZHByO1xuICAgICAgICB0aGlzLmdsLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmRwcjtcblxuICAgICAgICBpZiAoIXRoaXMuZ2wuY2FudmFzLnN0eWxlKSByZXR1cm47XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5nbC5jYW52YXMuc3R5bGUsIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCArICdweCcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFZpZXdwb3J0KHdpZHRoLCBoZWlnaHQsIHggPSAwLCB5ID0gMCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aWV3cG9ydC53aWR0aCA9PT0gd2lkdGggJiYgdGhpcy5zdGF0ZS52aWV3cG9ydC5oZWlnaHQgPT09IGhlaWdodCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLnZpZXdwb3J0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuc3RhdGUudmlld3BvcnQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnN0YXRlLnZpZXdwb3J0LnggPSB4O1xuICAgICAgICB0aGlzLnN0YXRlLnZpZXdwb3J0LnkgPSB5O1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHNldFNjaXNzb3Iod2lkdGgsIGhlaWdodCwgeCA9IDAsIHkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBlbmFibGUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbaWRdID09PSB0cnVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKGlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZVtpZF0gPSB0cnVlO1xuICAgIH1cblxuICAgIGRpc2FibGUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbaWRdID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmdsLmRpc2FibGUoaWQpO1xuICAgICAgICB0aGlzLnN0YXRlW2lkXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldEJsZW5kRnVuYyhzcmMsIGRzdCwgc3JjQWxwaGEsIGRzdEFscGhhKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYmxlbmRGdW5jLnNyYyA9PT0gc3JjICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmJsZW5kRnVuYy5kc3QgPT09IGRzdCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZEZ1bmMuc3JjQWxwaGEgPT09IHNyY0FscGhhICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmJsZW5kRnVuYy5kc3RBbHBoYSA9PT0gZHN0QWxwaGFcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLmJsZW5kRnVuYy5zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuc3RhdGUuYmxlbmRGdW5jLmRzdCA9IGRzdDtcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZEZ1bmMuc3JjQWxwaGEgPSBzcmNBbHBoYTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZEZ1bmMuZHN0QWxwaGEgPSBkc3RBbHBoYTtcbiAgICAgICAgaWYgKHNyY0FscGhhICE9PSB1bmRlZmluZWQpIHRoaXMuZ2wuYmxlbmRGdW5jU2VwYXJhdGUoc3JjLCBkc3QsIHNyY0FscGhhLCBkc3RBbHBoYSk7XG4gICAgICAgIGVsc2UgdGhpcy5nbC5ibGVuZEZ1bmMoc3JjLCBkc3QpO1xuICAgIH1cblxuICAgIHNldEJsZW5kRXF1YXRpb24obW9kZVJHQiwgbW9kZUFscGhhKSB7XG4gICAgICAgIG1vZGVSR0IgPSBtb2RlUkdCIHx8IHRoaXMuZ2wuRlVOQ19BREQ7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmJsZW5kRXF1YXRpb24ubW9kZVJHQiA9PT0gbW9kZVJHQiAmJiB0aGlzLnN0YXRlLmJsZW5kRXF1YXRpb24ubW9kZUFscGhhID09PSBtb2RlQWxwaGEpIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZEVxdWF0aW9uLm1vZGVSR0IgPSBtb2RlUkdCO1xuICAgICAgICB0aGlzLnN0YXRlLmJsZW5kRXF1YXRpb24ubW9kZUFscGhhID0gbW9kZUFscGhhO1xuICAgICAgICBpZiAobW9kZUFscGhhICE9PSB1bmRlZmluZWQpIHRoaXMuZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKG1vZGVSR0IsIG1vZGVBbHBoYSk7XG4gICAgICAgIGVsc2UgdGhpcy5nbC5ibGVuZEVxdWF0aW9uKG1vZGVSR0IpO1xuICAgIH1cblxuICAgIHNldEN1bGxGYWNlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmN1bGxGYWNlID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLmN1bGxGYWNlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2wuY3VsbEZhY2UodmFsdWUpO1xuICAgIH1cblxuICAgIHNldEZyb250RmFjZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5mcm9udEZhY2UgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUuZnJvbnRGYWNlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2wuZnJvbnRGYWNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXREZXB0aE1hc2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGVwdGhNYXNrID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLmRlcHRoTWFzayA9IHZhbHVlO1xuICAgICAgICB0aGlzLmdsLmRlcHRoTWFzayh2YWx1ZSk7XG4gICAgfVxuXG4gICAgc2V0RGVwdGhGdW5jKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRlcHRoRnVuYyA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5kZXB0aEZ1bmMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbC5kZXB0aEZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIHNldFN0ZW5jaWxNYXNrKHZhbHVlKSB7XG4gICAgICAgIGlmKHRoaXMuc3RhdGUuc3RlbmNpbE1hc2sgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUuc3RlbmNpbE1hc2sgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbC5zdGVuY2lsTWFzayh2YWx1ZSlcbiAgICB9XG5cbiAgICBzZXRTdGVuY2lsRnVuYyhmdW5jLCByZWYsIG1hc2spIHtcblxuICAgICAgICBpZigodGhpcy5zdGF0ZS5zdGVuY2lsRnVuYyA9PT0gZnVuYykgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLnN0ZW5jaWxSZWYgPT09IHJlZikgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLnN0ZW5jaWxGdW5jTWFzayA9PT0gbWFzaylcbiAgICAgICAgKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5zdGVuY2lsRnVuYyA9IGZ1bmMgfHwgdGhpcy5nbC5BTFdBWVM7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RlbmNpbFJlZiA9IHJlZiB8fCAwO1xuICAgICAgICB0aGlzLnN0YXRlLnN0ZW5jaWxGdW5jTWFzayA9IG1hc2sgfHwgMDtcblxuICAgICAgICB0aGlzLmdsLnN0ZW5jaWxGdW5jKGZ1bmMgfHwgdGhpcy5nbC5BTFdBWVMsIHJlZiB8fCAwLCBtYXNrIHx8IDApO1xuICAgIH1cblxuICAgIHNldFN0ZW5jaWxPcChzdGVuY2lsRmFpbCwgZGVwdGhGYWlsLCBkZXB0aFBhc3MpIHtcblxuICAgICAgICBpZih0aGlzLnN0YXRlLnN0ZW5jaWxGYWlsID09PSBzdGVuY2lsRmFpbCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGVuY2lsRGVwdGhGYWlsID09PSBkZXB0aEZhaWwgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RlbmNpbERlcHRoUGFzcyA9PT0gZGVwdGhQYXNzXG4gICAgICAgICkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuc3RhdGUuc3RlbmNpbEZhaWwgPSBzdGVuY2lsRmFpbDtcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGVuY2lsRGVwdGhGYWlsID0gZGVwdGhGYWlsO1xuICAgICAgICB0aGlzLnN0YXRlLnN0ZW5jaWxEZXB0aFBhc3MgPSBkZXB0aFBhc3M7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmdsLnN0ZW5jaWxPcChzdGVuY2lsRmFpbCwgZGVwdGhGYWlsLCBkZXB0aFBhc3MpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBhY3RpdmVUZXh0dXJlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2ZVRleHR1cmVVbml0ID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLmFjdGl2ZVRleHR1cmVVbml0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgdmFsdWUpO1xuICAgIH1cblxuICAgIGJpbmRGcmFtZWJ1ZmZlcih7IHRhcmdldCA9IHRoaXMuZ2wuRlJBTUVCVUZGRVIsIGJ1ZmZlciA9IG51bGwgfSA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmZyYW1lYnVmZmVyID09PSBidWZmZXIpIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5mcmFtZWJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBidWZmZXIpO1xuICAgIH1cblxuICAgIGdldEV4dGVuc2lvbihleHRlbnNpb24sIHdlYmdsMkZ1bmMsIGV4dEZ1bmMpIHtcbiAgICAgICAgLy8gaWYgd2ViZ2wyIGZ1bmN0aW9uIHN1cHBvcnRlZCwgcmV0dXJuIGZ1bmMgYm91bmQgdG8gZ2wgY29udGV4dFxuICAgICAgICBpZiAod2ViZ2wyRnVuYyAmJiB0aGlzLmdsW3dlYmdsMkZ1bmNdKSByZXR1cm4gdGhpcy5nbFt3ZWJnbDJGdW5jXS5iaW5kKHRoaXMuZ2wpO1xuXG4gICAgICAgIC8vIGZldGNoIGV4dGVuc2lvbiBvbmNlIG9ubHlcbiAgICAgICAgaWYgKCF0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXSkge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zW2V4dGVuc2lvbl0gPSB0aGlzLmdsLmdldEV4dGVuc2lvbihleHRlbnNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGV4dGVuc2lvbiBpZiBubyBmdW5jdGlvbiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKCF3ZWJnbDJGdW5jKSByZXR1cm4gdGhpcy5leHRlbnNpb25zW2V4dGVuc2lvbl07XG5cbiAgICAgICAgLy8gUmV0dXJuIG51bGwgaWYgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKCF0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gcmV0dXJuIGV4dGVuc2lvbiBmdW5jdGlvbiwgYm91bmQgdG8gZXh0ZW5zaW9uXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXVtleHRGdW5jXS5iaW5kKHRoaXMuZXh0ZW5zaW9uc1tleHRlbnNpb25dKTtcbiAgICB9XG5cbiAgICBzb3J0T3BhcXVlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChhLnByb2dyYW0uaWQgIT09IGIucHJvZ3JhbS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJvZ3JhbS5pZCAtIGIucHJvZ3JhbS5pZDtcbiAgICAgICAgfSBlbHNlIGlmIChhLnpEZXB0aCAhPT0gYi56RGVwdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnpEZXB0aCAtIGIuekRlcHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc29ydFRyYW5zcGFyZW50KGEsIGIpIHtcbiAgICAgICAgaWYgKGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS56RGVwdGggIT09IGIuekRlcHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gYi56RGVwdGggLSBhLnpEZXB0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNvcnRVSShhLCBiKSB7XG4gICAgICAgIGlmIChhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5wcm9ncmFtLmlkICE9PSBiLnByb2dyYW0uaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnByb2dyYW0uaWQgLSBiLnByb2dyYW0uaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYi5pZCAtIGEuaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSZW5kZXJMaXN0KHsgc2NlbmUsIGNhbWVyYSwgZnJ1c3R1bUN1bGwsIHNvcnQgfSkge1xuICAgICAgICBsZXQgcmVuZGVyTGlzdCA9IFtdO1xuXG4gICAgICAgIGlmIChjYW1lcmEgJiYgZnJ1c3R1bUN1bGwpIGNhbWVyYS51cGRhdGVGcnVzdHVtKCk7XG5cbiAgICAgICAgLy8gR2V0IHZpc2libGVcbiAgICAgICAgc2NlbmUudHJhdmVyc2UoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZS52aXNpYmxlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZS5kcmF3KSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChmcnVzdHVtQ3VsbCAmJiBub2RlLmZydXN0dW1DdWxsZWQgJiYgY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW1lcmEuZnJ1c3R1bUludGVyc2VjdHNNZXNoKG5vZGUpKSByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlckxpc3QucHVzaChub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wYXF1ZSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwYXJlbnQgPSBbXTsgLy8gZGVwdGhUZXN0IHRydWVcbiAgICAgICAgICAgIGNvbnN0IHVpID0gW107IC8vIGRlcHRoVGVzdCBmYWxzZVxuXG4gICAgICAgICAgICByZW5kZXJMaXN0LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBpbnRvIHRoZSAzIHJlbmRlciBncm91cHNcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUucHJvZ3JhbS50cmFuc3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvcGFxdWUucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUucHJvZ3JhbS5kZXB0aFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1aS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUuekRlcHRoID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgY2FsY3VsYXRlIHotZGVwdGggaWYgcmVuZGVyT3JkZXIgdW5zZXQgYW5kIGRlcHRoVGVzdCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucmVuZGVyT3JkZXIgIT09IDAgfHwgIW5vZGUucHJvZ3JhbS5kZXB0aFRlc3QgfHwgIWNhbWVyYSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHotZGVwdGhcbiAgICAgICAgICAgICAgICBub2RlLndvcmxkTWF0cml4LmdldFRyYW5zbGF0aW9uKHRlbXBWZWMzKTtcbiAgICAgICAgICAgICAgICB0ZW1wVmVjMy5hcHBseU1hdHJpeDQoY2FtZXJhLnByb2plY3Rpb25WaWV3TWF0cml4KTtcbiAgICAgICAgICAgICAgICBub2RlLnpEZXB0aCA9IHRlbXBWZWMzLno7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3BhcXVlLnNvcnQodGhpcy5zb3J0T3BhcXVlKTtcbiAgICAgICAgICAgIHRyYW5zcGFyZW50LnNvcnQodGhpcy5zb3J0VHJhbnNwYXJlbnQpO1xuICAgICAgICAgICAgdWkuc29ydCh0aGlzLnNvcnRVSSk7XG5cbiAgICAgICAgICAgIHJlbmRlckxpc3QgPSBvcGFxdWUuY29uY2F0KHRyYW5zcGFyZW50LCB1aSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyTGlzdDtcbiAgICB9XG5cbiAgICByZW5kZXIoeyBzY2VuZSwgY2FtZXJhLCB0YXJnZXQgPSBudWxsLCB1cGRhdGUgPSB0cnVlLCBzb3J0ID0gdHJ1ZSwgZnJ1c3R1bUN1bGwgPSB0cnVlLCBjbGVhciB9KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBubyByZW5kZXIgdGFyZ2V0IGJvdW5kIHNvIGRyYXdzIHRvIGNhbnZhc1xuICAgICAgICAgICAgdGhpcy5iaW5kRnJhbWVidWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnQodGhpcy53aWR0aCAqIHRoaXMuZHByLCB0aGlzLmhlaWdodCAqIHRoaXMuZHByKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJpbmQgc3VwcGxpZWQgcmVuZGVyIHRhcmdldCBhbmQgdXBkYXRlIHZpZXdwb3J0XG4gICAgICAgICAgICB0aGlzLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCh0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsZWFyIHx8ICh0aGlzLmF1dG9DbGVhciAmJiBjbGVhciAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZFxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGggJiYgKCF0YXJnZXQgfHwgdGFyZ2V0LmRlcHRoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREZXB0aE1hc2sodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhbWUgZm9yIHN0ZW5jaWxcbiAgICAgICAgICAgIGlmKHRoaXMuc3RlbmNpbCB8fCAoIXRhcmdldCB8fCB0YXJnZXQuc3RlbmNpbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSh0aGlzLmdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGVuY2lsTWFzaygweGZmKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmdsLmNsZWFyKFxuICAgICAgICAgICAgICAgICh0aGlzLmNvbG9yID8gdGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5kZXB0aCA/IHRoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVCA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3RlbmNpbCA/IHRoaXMuZ2wuU1RFTkNJTF9CVUZGRVJfQklUIDogMClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGVzIGFsbCBzY2VuZSBncmFwaCBtYXRyaWNlc1xuICAgICAgICBpZiAodXBkYXRlKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgc2VwYXJhdGVseSwgaW4gY2FzZSBub3QgaW4gc2NlbmUgZ3JhcGhcbiAgICAgICAgaWYgKGNhbWVyYSkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgICAgLy8gR2V0IHJlbmRlciBsaXN0IC0gZW50YWlscyBjdWxsaW5nIGFuZCBzb3J0aW5nXG4gICAgICAgIGNvbnN0IHJlbmRlckxpc3QgPSB0aGlzLmdldFJlbmRlckxpc3QoeyBzY2VuZSwgY2FtZXJhLCBmcnVzdHVtQ3VsbCwgc29ydCB9KTtcblxuICAgICAgICByZW5kZXJMaXN0LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUuZHJhdyh7IGNhbWVyYSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlZlYzMiLCJ0ZW1wVmVjMyIsIklEIiwiUmVuZGVyZXIiLCJzZXRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJnbCIsImNhbnZhcyIsImRwciIsInN0eWxlIiwiT2JqZWN0IiwiYXNzaWduIiwic2V0Vmlld3BvcnQiLCJ4IiwieSIsInN0YXRlIiwidmlld3BvcnQiLCJzZXRTY2lzc29yIiwic2Npc3NvciIsImVuYWJsZSIsImlkIiwiZGlzYWJsZSIsInNldEJsZW5kRnVuYyIsInNyYyIsImRzdCIsInNyY0FscGhhIiwiZHN0QWxwaGEiLCJibGVuZEZ1bmMiLCJ1bmRlZmluZWQiLCJibGVuZEZ1bmNTZXBhcmF0ZSIsInNldEJsZW5kRXF1YXRpb24iLCJtb2RlUkdCIiwibW9kZUFscGhhIiwiRlVOQ19BREQiLCJibGVuZEVxdWF0aW9uIiwiYmxlbmRFcXVhdGlvblNlcGFyYXRlIiwic2V0Q3VsbEZhY2UiLCJ2YWx1ZSIsImN1bGxGYWNlIiwic2V0RnJvbnRGYWNlIiwiZnJvbnRGYWNlIiwic2V0RGVwdGhNYXNrIiwiZGVwdGhNYXNrIiwic2V0RGVwdGhGdW5jIiwiZGVwdGhGdW5jIiwic2V0U3RlbmNpbE1hc2siLCJzdGVuY2lsTWFzayIsInNldFN0ZW5jaWxGdW5jIiwiZnVuYyIsInJlZiIsIm1hc2siLCJzdGVuY2lsRnVuYyIsInN0ZW5jaWxSZWYiLCJzdGVuY2lsRnVuY01hc2siLCJBTFdBWVMiLCJzZXRTdGVuY2lsT3AiLCJzdGVuY2lsRmFpbCIsImRlcHRoRmFpbCIsImRlcHRoUGFzcyIsInN0ZW5jaWxEZXB0aEZhaWwiLCJzdGVuY2lsRGVwdGhQYXNzIiwic3RlbmNpbE9wIiwiYWN0aXZlVGV4dHVyZSIsImFjdGl2ZVRleHR1cmVVbml0IiwiVEVYVFVSRTAiLCJiaW5kRnJhbWVidWZmZXIiLCJ0YXJnZXQiLCJGUkFNRUJVRkZFUiIsImJ1ZmZlciIsImZyYW1lYnVmZmVyIiwiZ2V0RXh0ZW5zaW9uIiwiZXh0ZW5zaW9uIiwid2ViZ2wyRnVuYyIsImV4dEZ1bmMiLCJiaW5kIiwiZXh0ZW5zaW9ucyIsInNvcnRPcGFxdWUiLCJhIiwiYiIsInJlbmRlck9yZGVyIiwicHJvZ3JhbSIsInpEZXB0aCIsInNvcnRUcmFuc3BhcmVudCIsInNvcnRVSSIsImdldFJlbmRlckxpc3QiLCJzY2VuZSIsImNhbWVyYSIsImZydXN0dW1DdWxsIiwic29ydCIsInJlbmRlckxpc3QiLCJ1cGRhdGVGcnVzdHVtIiwidHJhdmVyc2UiLCJub2RlIiwidmlzaWJsZSIsImRyYXciLCJmcnVzdHVtQ3VsbGVkIiwiZnJ1c3R1bUludGVyc2VjdHNNZXNoIiwicHVzaCIsIm9wYXF1ZSIsInRyYW5zcGFyZW50IiwidWkiLCJmb3JFYWNoIiwiZGVwdGhUZXN0Iiwid29ybGRNYXRyaXgiLCJnZXRUcmFuc2xhdGlvbiIsImFwcGx5TWF0cml4NCIsInByb2plY3Rpb25WaWV3TWF0cml4IiwieiIsImNvbmNhdCIsInJlbmRlciIsInVwZGF0ZSIsImNsZWFyIiwiYXV0b0NsZWFyIiwiZGVwdGgiLCJERVBUSF9URVNUIiwic3RlbmNpbCIsIlNURU5DSUxfVEVTVCIsImNvbG9yIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJTVEVOQ0lMX0JVRkZFUl9CSVQiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsImNvbnN0cnVjdG9yIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYWxwaGEiLCJhbnRpYWxpYXMiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJwb3dlclByZWZlcmVuY2UiLCJ3ZWJnbCIsImF0dHJpYnV0ZXMiLCJnZXRDb250ZXh0IiwiaXNXZWJnbDIiLCJjb25zb2xlIiwiZXJyb3IiLCJyZW5kZXJlciIsIk9ORSIsIlpFUk8iLCJDQ1ciLCJMRVFVQUwiLCJwcmVtdWx0aXBseUFscGhhIiwiZmxpcFkiLCJ1bnBhY2tBbGlnbm1lbnQiLCJ0ZXh0dXJlVW5pdHMiLCJib3VuZEJ1ZmZlciIsInVuaWZvcm1Mb2NhdGlvbnMiLCJNYXAiLCJjdXJyZW50UHJvZ3JhbSIsInZlcnRleEF0dHJpYkRpdmlzb3IiLCJkcmF3QXJyYXlzSW5zdGFuY2VkIiwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkIiwiY3JlYXRlVmVydGV4QXJyYXkiLCJiaW5kVmVydGV4QXJyYXkiLCJkZWxldGVWZXJ0ZXhBcnJheSIsImRyYXdCdWZmZXJzIiwicGFyYW1ldGVycyIsIm1heFRleHR1cmVVbml0cyIsImdldFBhcmFtZXRlciIsIk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIiwibWF4QW5pc290cm9weSIsIk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/core/Renderer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/core/Transform.js":
/*!************************************************!*\
  !*** ./node_modules/ogl/src/core/Transform.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: function() { return /* binding */ Transform; }\n/* harmony export */ });\n/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vec3.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Vec3.js\");\n/* harmony import */ var _math_Quat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Quat.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Quat.js\");\n/* harmony import */ var _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Mat4.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Mat4.js\");\n/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Euler.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Euler.js\");\n\n\n\n\nclass Transform {\n    setParent(parent) {\n        let notifyParent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (this.parent && parent !== this.parent) this.parent.removeChild(this, false);\n        this.parent = parent;\n        if (notifyParent && parent) parent.addChild(this, false);\n    }\n    addChild(child) {\n        let notifyChild = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (!~this.children.indexOf(child)) this.children.push(child);\n        if (notifyChild) child.setParent(this, false);\n    }\n    removeChild(child) {\n        let notifyChild = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (!!~this.children.indexOf(child)) this.children.splice(this.children.indexOf(child), 1);\n        if (notifyChild) child.setParent(null, false);\n    }\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate) this.updateMatrix();\n        if (this.worldMatrixNeedsUpdate || force) {\n            if (this.parent === null) this.worldMatrix.copy(this.matrix);\n            else this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix);\n            this.worldMatrixNeedsUpdate = false;\n            force = true;\n        }\n        for(let i = 0, l = this.children.length; i < l; i++){\n            this.children[i].updateMatrixWorld(force);\n        }\n    }\n    updateMatrix() {\n        this.matrix.compose(this.quaternion, this.position, this.scale);\n        this.worldMatrixNeedsUpdate = true;\n    }\n    traverse(callback) {\n        // Return true in callback to stop traversing children\n        if (callback(this)) return;\n        for(let i = 0, l = this.children.length; i < l; i++){\n            this.children[i].traverse(callback);\n        }\n    }\n    decompose() {\n        this.matrix.decompose(this.quaternion._target, this.position, this.scale);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n    lookAt(target) {\n        let invert = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (invert) this.matrix.lookAt(this.position, target, this.up);\n        else this.matrix.lookAt(target, this.position, this.up);\n        this.matrix.getRotation(this.quaternion._target);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n    constructor(){\n        this.parent = null;\n        this.children = [];\n        this.visible = true;\n        this.matrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n        this.worldMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n        this.matrixAutoUpdate = true;\n        this.worldMatrixNeedsUpdate = false;\n        this.position = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n        this.quaternion = new _math_Quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\n        this.scale = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(1);\n        this.rotation = new _math_Euler_js__WEBPACK_IMPORTED_MODULE_3__.Euler();\n        this.up = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(0, 1, 0);\n        this.rotation._target.onChange = ()=>this.quaternion.fromEuler(this.rotation, true);\n        this.quaternion._target.onChange = ()=>this.rotation.fromQuaternion(this.quaternion, undefined, true);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvVHJhbnNmb3JtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ0E7QUFDQTtBQUNFO0FBRWxDLE1BQU1JO0lBcUJUQyxVQUFVQyxNQUFNLEVBQXVCO1lBQXJCQyxlQUFBQSxpRUFBZTtRQUM3QixJQUFJLElBQUksQ0FBQ0QsTUFBTSxJQUFJQSxXQUFXLElBQUksQ0FBQ0EsTUFBTSxFQUFFLElBQUksQ0FBQ0EsTUFBTSxDQUFDRSxXQUFXLENBQUMsSUFBSSxFQUFFO1FBQ3pFLElBQUksQ0FBQ0YsTUFBTSxHQUFHQTtRQUNkLElBQUlDLGdCQUFnQkQsUUFBUUEsT0FBT0csUUFBUSxDQUFDLElBQUksRUFBRTtJQUN0RDtJQUVBQSxTQUFTQyxLQUFLLEVBQXNCO1lBQXBCQyxjQUFBQSxpRUFBYztRQUMxQixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDSCxRQUFRLElBQUksQ0FBQ0UsUUFBUSxDQUFDRSxJQUFJLENBQUNKO1FBQ3ZELElBQUlDLGFBQWFELE1BQU1MLFNBQVMsQ0FBQyxJQUFJLEVBQUU7SUFDM0M7SUFFQUcsWUFBWUUsS0FBSyxFQUFzQjtZQUFwQkMsY0FBQUEsaUVBQWM7UUFDN0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDSCxRQUFRLElBQUksQ0FBQ0UsUUFBUSxDQUFDRyxNQUFNLENBQUMsSUFBSSxDQUFDSCxRQUFRLENBQUNDLE9BQU8sQ0FBQ0gsUUFBUTtRQUN4RixJQUFJQyxhQUFhRCxNQUFNTCxTQUFTLENBQUMsTUFBTTtJQUMzQztJQUVBVyxrQkFBa0JDLEtBQUssRUFBRTtRQUNyQixJQUFJLElBQUksQ0FBQ0MsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDQyxZQUFZO1FBQzVDLElBQUksSUFBSSxDQUFDQyxzQkFBc0IsSUFBSUgsT0FBTztZQUN0QyxJQUFJLElBQUks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SUFBSSxDQUFDUCxVQUFVLENBQUNNLE9BQU8sQ0FBQ1UsUUFBUSxHQUFHLElBQU0sSUFBSSxDQUFDVCxRQUFRLENBQUNDLGNBQWMsQ0FBQyxJQUFJLENBQUNSLFVBQVUsRUFBRWtCLFdBQVc7SUFDdEc7QUF3REoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvY29yZS9UcmFuc2Zvcm0uanM/MDgzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWMzIH0gZnJvbSAnLi4vbWF0aC9WZWMzLmpzJztcbmltcG9ydCB7IFF1YXQgfSBmcm9tICcuLi9tYXRoL1F1YXQuanMnO1xuaW1wb3J0IHsgTWF0NCB9IGZyb20gJy4uL21hdGgvTWF0NC5qcyc7XG5pbXBvcnQgeyBFdWxlciB9IGZyb20gJy4uL21hdGgvRXVsZXIuanMnO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0NCgpO1xuICAgICAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdDQoKTtcbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53b3JsZE1hdHJpeE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0KCk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjMygxKTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuICAgICAgICB0aGlzLnVwID0gbmV3IFZlYzMoMCwgMSwgMCk7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbi5fdGFyZ2V0Lm9uQ2hhbmdlID0gKCkgPT4gdGhpcy5xdWF0ZXJuaW9uLmZyb21FdWxlcih0aGlzLnJvdGF0aW9uLCB0cnVlKTtcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLl90YXJnZXQub25DaGFuZ2UgPSAoKSA9PiB0aGlzLnJvdGF0aW9uLmZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9XG5cbiAgICBzZXRQYXJlbnQocGFyZW50LCBub3RpZnlQYXJlbnQgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiBwYXJlbnQgIT09IHRoaXMucGFyZW50KSB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAobm90aWZ5UGFyZW50ICYmIHBhcmVudCkgcGFyZW50LmFkZENoaWxkKHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBhZGRDaGlsZChjaGlsZCwgbm90aWZ5Q2hpbGQgPSB0cnVlKSB7XG4gICAgICAgIGlmICghfnRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCkpIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIGlmIChub3RpZnlDaGlsZCkgY2hpbGQuc2V0UGFyZW50KHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZW1vdmVDaGlsZChjaGlsZCwgbm90aWZ5Q2hpbGQgPSB0cnVlKSB7XG4gICAgICAgIGlmICghIX50aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpKSB0aGlzLmNoaWxkcmVuLnNwbGljZSh0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpLCAxKTtcbiAgICAgICAgaWYgKG5vdGlmeUNoaWxkKSBjaGlsZC5zZXRQYXJlbnQobnVsbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG4gICAgICAgIGlmICh0aGlzLm1hdHJpeEF1dG9VcGRhdGUpIHRoaXMudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIGlmICh0aGlzLndvcmxkTWF0cml4TmVlZHNVcGRhdGUgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkgdGhpcy53b3JsZE1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy53b3JsZE1hdHJpeC5tdWx0aXBseSh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgICAgICAgdGhpcy53b3JsZE1hdHJpeE5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZU1hdHJpeCgpIHtcbiAgICAgICAgdGhpcy5tYXRyaXguY29tcG9zZSh0aGlzLnF1YXRlcm5pb24sIHRoaXMucG9zaXRpb24sIHRoaXMuc2NhbGUpO1xuICAgICAgICB0aGlzLndvcmxkTWF0cml4TmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRyYXZlcnNlKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFJldHVybiB0cnVlIGluIGNhbGxiYWNrIHRvIHN0b3AgdHJhdmVyc2luZyBjaGlsZHJlblxuICAgICAgICBpZiAoY2FsbGJhY2sodGhpcykpIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS50cmF2ZXJzZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNvbXBvc2UoKSB7XG4gICAgICAgIHRoaXMubWF0cml4LmRlY29tcG9zZSh0aGlzLnF1YXRlcm5pb24uX3RhcmdldCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5zY2FsZSk7XG4gICAgICAgIHRoaXMucm90YXRpb24uZnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB9XG5cbiAgICBsb29rQXQodGFyZ2V0LCBpbnZlcnQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoaW52ZXJ0KSB0aGlzLm1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB0aGlzLnVwKTtcbiAgICAgICAgZWxzZSB0aGlzLm1hdHJpeC5sb29rQXQodGFyZ2V0LCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy5tYXRyaXguZ2V0Um90YXRpb24odGhpcy5xdWF0ZXJuaW9uLl90YXJnZXQpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uLmZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlZlYzMiLCJRdWF0IiwiTWF0NCIsIkV1bGVyIiwiVHJhbnNmb3JtIiwic2V0UGFyZW50IiwicGFyZW50Iiwibm90aWZ5UGFyZW50IiwicmVtb3ZlQ2hpbGQiLCJhZGRDaGlsZCIsImNoaWxkIiwibm90aWZ5Q2hpbGQiLCJjaGlsZHJlbiIsImluZGV4T2YiLCJwdXNoIiwic3BsaWNlIiwidXBkYXRlTWF0cml4V29ybGQiLCJmb3JjZSIsIm1hdHJpeEF1dG9VcGRhdGUiLCJ1cGRhdGVNYXRyaXgiLCJ3b3JsZE1hdHJpeE5lZWRzVXBkYXRlIiwid29ybGRNYXRyaXgiLCJjb3B5IiwibWF0cml4IiwibXVsdGlwbHkiLCJpIiwibCIsImxlbmd0aCIsImNvbXBvc2UiLCJxdWF0ZXJuaW9uIiwicG9zaXRpb24iLCJzY2FsZSIsInRyYXZlcnNlIiwiY2FsbGJhY2siLCJkZWNvbXBvc2UiLCJfdGFyZ2V0Iiwicm90YXRpb24iLCJmcm9tUXVhdGVybmlvbiIsImxvb2tBdCIsInRhcmdldCIsImludmVydCIsInVwIiwiZ2V0Um90YXRpb24iLCJjb25zdHJ1Y3RvciIsInZpc2libGUiLCJvbkNoYW5nZSIsImZyb21FdWxlciIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/core/Transform.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/Euler.js":
/*!********************************************!*\
  !*** ./node_modules/ogl/src/math/Euler.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Euler: function() { return /* binding */ Euler; }\n/* harmony export */ });\n/* harmony import */ var _functions_EulerFunc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions/EulerFunc.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/functions/EulerFunc.js\");\n/* harmony import */ var _Mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mat4.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/Mat4.js\");\n\n\nconst tmpMat4 = /* @__PURE__ */ new _Mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nclass Euler extends Array {\n    get x() {\n        return this[0];\n    }\n    get y() {\n        return this[1];\n    }\n    get z() {\n        return this[2];\n    }\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n    set(x) {\n        let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : x;\n        if (x.length) return this.copy(x);\n        this._target[0] = x;\n        this._target[1] = y;\n        this._target[2] = z;\n        this.onChange();\n        return this;\n    }\n    copy(v) {\n        this._target[0] = v[0];\n        this._target[1] = v[1];\n        this._target[2] = v[2];\n        this.onChange();\n        return this;\n    }\n    reorder(order) {\n        this._target.order = order;\n        this.onChange();\n        return this;\n    }\n    fromRotationMatrix(m) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.order;\n        _functions_EulerFunc_js__WEBPACK_IMPORTED_MODULE_1__.fromRotationMatrix(this._target, m, order);\n        this.onChange();\n        return this;\n    }\n    fromQuaternion(q) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.order, isInternal = arguments.length > 2 ? arguments[2] : void 0;\n        tmpMat4.fromQuaternion(q);\n        this._target.fromRotationMatrix(tmpMat4, order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n    fromArray(a) {\n        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        return this;\n    }\n    toArray() {\n        let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n    constructor(x = 0, y = x, z = x, order = \"YXZ\"){\n        super(x, y, z);\n        this.order = order;\n        this.onChange = ()=>{};\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = [\n            \"0\",\n            \"1\",\n            \"2\"\n        ];\n        return new Proxy(this, {\n            set (target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            }\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvRXVsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNEO0FBQ3JCO0FBRWpDLE1BQU1FLFVBQVUsYUFBYSxHQUFHLElBQUlELDBDQUFJQTtBQUVqQyxNQUFNRSxjQUFjQztJQW9CdkIsSUFBSUMsSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEVBQUU7SUFDbEI7SUFFQSxJQUFJQyxJQUFJO1FBQ0osT0FBTyxJQUFJLENBQUMsRUFBRTtJQUNsQjtJQUVBLElBQUlDLElBQUk7UUFDSixPQUFPLElBQUksQ0FBQyxFQUFFO0lBQ2xCO0lBRUEsSUFBSUYsRUFBRUcsQ0FBQyxFQUFFO1FBQ0wsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxHQUFHRDtRQUNsQixJQUFJLENBQUNFLFFBQVE7SUFDakI7SUFFQSxJQUFJSixFQUFFRSxDQUFDLEVBQUU7UUFDTCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLEdBQUdEO1FBQ2xCLElBQUksQ0FBQ0UsUUFBUTtJQUNqQjtJQUVBLElBQUlILEVBQUVDLENBQUMsRUFBRTtRQUNMLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsR0FBR0Q7UUFDbEIsSUFBSSxDQUFDRSxRQUFRO0lBQ2pCO0lBRUFDLElBQUlOLENBQUMsRUFBZ0I7WUFBZEMsSUFBQUEsaUVBQUlELEdBQUdFLElBQUFBLGlFQUFJRjtRQUNkLElBQUlBLEVBQUVPLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDUjtRQUMvQixJQUFJLENBQUNJLE9BQU8sQ0FBQyxFQUFFLEdBQUdKO1FBQ2xCLElBQUksQ0FBQ0ksT0FBTyxDQUFDLEVBQUUsR0FBR0g7UUFDbEIsSUFBSSxDQUFDRyxPQUFPLENBQUMsRUFBRSxHQUFHRjtRQUNsQixJQUFJLENBQUNHLFFBQVE7UUFDYixPQUFPLElBQUk7SUFDZjtJQUVBRyxLQUFLTCxDQUFDLEVBQUU7UUFDSixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUU7UUFDdEIsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUMsRUFBRTtRQUN0QixJQUFJLENBQUNFLFFBQVE7UUFDYixPQUFPLElBQUk7SUFDZjtJQUVBSSxRQUFRQyxLQUFLLEVBQUU7UUFDWCxJQUFJLENBQUNOLE9BQU8sQ0FBQ00sS0FBSyxHQUFHQTtRQUNyQixJQUFJLENBQUNMLFFBQVE7UUFDYixPQUFPLElBQUk7SUFDZjtJQUVBTSxtQkFBbUJDLENBQUMsRUFBc0I7WUFBcEJGLFFBQUFBLGlFQUFRLElBQUksQ0FBQ0EsS0FBSztRQUNwQ2YsdUVBQTRCLENBQUMsSUFBSSxDQUFDUyxPQUFPLEVBQUVRLEdBQUdGO1FBQzlDLElBQUksQ0FBQ0wsUUFBUTtRQUNiLE9BQU8sSUFBSTtJQUNmO0lBRUFRLGVBQWVDLENBQUMsRUFBa0M7WUFBaENKLFFBQUFBLGlFQUFRLElBQUksQ0FBQ0EsS0FBSyxFQUFFSztRQUNsQ2xCLFFBQVFnQixjQUFjLENBQUNDO1FBQ3ZCLElBQUksQ0FBQ1YsT0FBTyxDQUFDTyxrQkFBa0IsQ0FBQ2QsU0FBU2E7UUFDekMsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0ssWUFBWSxJQUFJLENBQUNWLFFBQVE7UUFDOUIsT0FBTyxJQUFJO0lBQ2Y7SUFFQVcsVUFBVUMsQ0FBQyxFQUFTO1lBQVBDLElBQUFBLGlFQUFJO1FBQ2IsSUFBSSxDQUFDZCxPQUFPLENBQUMsRUFBRSxHQUFHYSxDQUFDLENBQUNDLEVBQUU7UUFDdEIsSUFBSSxDQUFDZCxPQUFPLENBQUMsRUFBRSxHQUFHYSxDQUFDLENBQUNDLElBQUksRUFBRTtRQUMxQixJQUFJLENBQUNkLE9BQU8sQ0FBQyxFQUFFLEdBQUdhLENBQUMsQ0FBQ0MsSUFBSSxFQUFFO1FBQzFCLE9BQU8sSUFBSTtJQUNmO0lBRUFDLFVBQXVCO1lBQWZGLElBQUFBLGlFQUFJLEVBQUUsRUFBRUMsSUFBQUEsaUVBQUk7UUFDaEJELENBQUMsQ0FBQ0MsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2RELENBQUMsQ0FBQ0MsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUU7UUFDbEJELENBQUMsQ0FBQ0MsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUU7UUFDbEIsT0FBT0Q7SUFDWDtJQS9GQUcsWUFBWXBCLElBQUksQ0FBQyxFQUFFQyxJQUFJRCxDQUFDLEVBQUVFLElBQUlGLENBQUMsRUFBRVUsUUFBUSxLQUFLLENBQUU7UUFDNUMsS0FBSyxDQUFDVixHQUFHQyxHQUFHQztRQUNaLElBQUksQ0FBQ1EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0wsUUFBUSxHQUFHLEtBQU87UUFFdkIseUVBQXlFO1FBQ3pFLElBQUksQ0FBQ0QsT0FBTyxHQUFHLElBQUk7UUFFbkIsNkVBQTZFO1FBQzdFLE1BQU1pQixlQUFlO1lBQUM7WUFBSztZQUFLO1NBQUk7UUFDcEMsT0FBTyxJQUFJQyxNQUFNLElBQUksRUFBRTtZQUNuQmhCLEtBQUlpQixNQUFNLEVBQUVDLFFBQVE7Z0JBQ2hCLE1BQU1DLFVBQVVDLFFBQVFwQixHQUFHLElBQUlxQjtnQkFDL0IsSUFBSUYsV0FBV0osYUFBYU8sUUFBUSxDQUFDSixXQUFXRCxPQUFPbEIsUUFBUTtnQkFDL0QsT0FBT29CO1lBQ1g7UUFDSjtJQUNKO0FBK0VKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvRXVsZXIuanM/N2NmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFdWxlckZ1bmMgZnJvbSAnLi9mdW5jdGlvbnMvRXVsZXJGdW5jLmpzJztcbmltcG9ydCB7IE1hdDQgfSBmcm9tICcuL01hdDQuanMnO1xuXG5jb25zdCB0bXBNYXQ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXQ0KCk7XG5cbmV4cG9ydCBjbGFzcyBFdWxlciBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IHgsIHogPSB4LCBvcmRlciA9ICdZWFonKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHopO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7fTtcblxuICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZSB0byBwcm94eSB0YXJnZXQgdG8gYXZvaWQgdHJpZ2dlcmluZyBvbkNoYW5nZSBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgcHJveHkgdG8gdHJpZ2dlciBvbkNoYW5nZSB3aGVuIGFycmF5IGVsZW1lbnRzIGFyZSBlZGl0ZWQgZGlyZWN0bHlcbiAgICAgICAgY29uc3QgdHJpZ2dlclByb3BzID0gWycwJywgJzEnLCAnMiddO1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIHNldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IFJlZmxlY3Quc2V0KC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgdHJpZ2dlclByb3BzLmluY2x1ZGVzKHByb3BlcnR5KSkgdGFyZ2V0Lm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF07XG4gICAgfVxuXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzFdO1xuICAgIH1cblxuICAgIGdldCB6KCkge1xuICAgICAgICByZXR1cm4gdGhpc1syXTtcbiAgICB9XG5cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFswXSA9IHY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFsxXSA9IHY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzZXQgeih2KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFsyXSA9IHY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzZXQoeCwgeSA9IHgsIHogPSB4KSB7XG4gICAgICAgIGlmICh4Lmxlbmd0aCkgcmV0dXJuIHRoaXMuY29weSh4KTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzBdID0geDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzFdID0geTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzJdID0gejtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb3B5KHYpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzBdID0gdlswXTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzFdID0gdlsxXTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzJdID0gdlsyXTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW9yZGVyKG9yZGVyKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5vcmRlciA9IG9yZGVyO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZyb21Sb3RhdGlvbk1hdHJpeChtLCBvcmRlciA9IHRoaXMub3JkZXIpIHtcbiAgICAgICAgRXVsZXJGdW5jLmZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLl90YXJnZXQsIG0sIG9yZGVyKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tUXVhdGVybmlvbihxLCBvcmRlciA9IHRoaXMub3JkZXIsIGlzSW50ZXJuYWwpIHtcbiAgICAgICAgdG1wTWF0NC5mcm9tUXVhdGVybmlvbihxKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmZyb21Sb3RhdGlvbk1hdHJpeCh0bXBNYXQ0LCBvcmRlcik7XG4gICAgICAgIC8vIEF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICBpZiAoIWlzSW50ZXJuYWwpIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnJvbUFycmF5KGEsIG8gPSAwKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFswXSA9IGFbb107XG4gICAgICAgIHRoaXMuX3RhcmdldFsxXSA9IGFbbyArIDFdO1xuICAgICAgICB0aGlzLl90YXJnZXRbMl0gPSBhW28gKyAyXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9BcnJheShhID0gW10sIG8gPSAwKSB7XG4gICAgICAgIGFbb10gPSB0aGlzWzBdO1xuICAgICAgICBhW28gKyAxXSA9IHRoaXNbMV07XG4gICAgICAgIGFbbyArIDJdID0gdGhpc1syXTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkV1bGVyRnVuYyIsIk1hdDQiLCJ0bXBNYXQ0IiwiRXVsZXIiLCJBcnJheSIsIngiLCJ5IiwieiIsInYiLCJfdGFyZ2V0Iiwib25DaGFuZ2UiLCJzZXQiLCJsZW5ndGgiLCJjb3B5IiwicmVvcmRlciIsIm9yZGVyIiwiZnJvbVJvdGF0aW9uTWF0cml4IiwibSIsImZyb21RdWF0ZXJuaW9uIiwicSIsImlzSW50ZXJuYWwiLCJmcm9tQXJyYXkiLCJhIiwibyIsInRvQXJyYXkiLCJjb25zdHJ1Y3RvciIsInRyaWdnZXJQcm9wcyIsIlByb3h5IiwidGFyZ2V0IiwicHJvcGVydHkiLCJzdWNjZXNzIiwiUmVmbGVjdCIsImFyZ3VtZW50cyIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/Euler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/Mat3.js":
/*!*******************************************!*\
  !*** ./node_modules/ogl/src/math/Mat3.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mat3: function() { return /* binding */ Mat3; }\n/* harmony export */ });\n/* harmony import */ var _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions/Mat3Func.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/functions/Mat3Func.js\");\n\nclass Mat3 extends Array {\n    set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        if (m00.length) return this.copy(m00);\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n    translate(v) {\n        let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this;\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.translate(this, m, v);\n        return this;\n    }\n    rotate(v) {\n        let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this;\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.rotate(this, m, v);\n        return this;\n    }\n    scale(v) {\n        let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this;\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.scale(this, m, v);\n        return this;\n    }\n    multiply(ma, mb) {\n        if (mb) {\n            _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.multiply(this, ma, mb);\n        } else {\n            _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.multiply(this, this, ma);\n        }\n        return this;\n    }\n    identity() {\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.identity(this);\n        return this;\n    }\n    copy(m) {\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.copy(this, m);\n        return this;\n    }\n    fromMatrix4(m) {\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.fromMat4(this, m);\n        return this;\n    }\n    fromQuaternion(q) {\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.fromQuat(this, q);\n        return this;\n    }\n    fromBasis(vec3a, vec3b, vec3c) {\n        this.set(vec3a[0], vec3a[1], vec3a[2], vec3b[0], vec3b[1], vec3b[2], vec3c[0], vec3c[1], vec3c[2]);\n        return this;\n    }\n    inverse() {\n        let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.invert(this, m);\n        return this;\n    }\n    getNormalMatrix(m) {\n        _functions_Mat3Func_js__WEBPACK_IMPORTED_MODULE_0__.normalFromMat4(this, m);\n        return this;\n    }\n    constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1){\n        super(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvTWF0My5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUU3QyxNQUFNQyxhQUFhQztJQU10QkMsSUFBSUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUM3QyxJQUFJUixJQUFJUyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUNDLElBQUksQ0FBQ1Y7UUFDakNKLHVEQUFZLENBQUMsSUFBSSxFQUFFSSxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLQztRQUMzRCxPQUFPLElBQUk7SUFDZjtJQUVBRyxVQUFVQyxDQUFDLEVBQVk7WUFBVkMsSUFBQUEsaUVBQUksSUFBSTtRQUNqQmpCLDZEQUFrQixDQUFDLElBQUksRUFBRWlCLEdBQUdEO1FBQzVCLE9BQU8sSUFBSTtJQUNmO0lBRUFFLE9BQU9GLENBQUMsRUFBWTtZQUFWQyxJQUFBQSxpRUFBSSxJQUFJO1FBQ2RqQiwwREFBZSxDQUFDLElBQUksRUFBRWlCLEdBQUdEO1FBQ3pCLE9BQU8sSUFBSTtJQUNmO0lBRUFHLE1BQU1ILENBQUMsRUFBWTtZQUFWQyxJQUFBQSxpRUFBSSxJQUFJO1FBQ2JqQix5REFBYyxDQUFDLElBQUksRUFBRWlCLEdBQUdEO1FBQ3hCLE9BQU8sSUFBSTtJQUNmO0lBRUFJLFNBQVNDLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ2IsSUFBSUEsSUFBSTtZQUNKdEIsNERBQWlCLENBQUMsSUFBSSxFQUFFcUIsSUFBSUM7UUFDaEMsT0FBTztZQUNIdEIsNERBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRXFCO1FBQ2xDO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFFQUUsV0FBVztRQUNQdkIsNERBQWlCLENBQUMsSUFBSTtRQUN0QixPQUFPLElBQUk7SUFDZjtJQUVBYyxLQUFLRyxDQUFDLEVBQUU7UUFDSmpCLHdEQUFhLENBQUMsSUFBSSxFQUFFaUI7UUFDcEIsT0FBTyxJQUFJO0lBQ2Y7SUFFQU8sWUFBWVAsQ0FBQyxFQUFFO1FBQ1hqQiw0REFBaUIsQ0FBQyxJQUFJLEVBQUVpQjtRQUN4QixPQUFPLElBQUk7SUFDZjtJQUVBUyxlQUFlQyxDQUFDLEVBQUU7UUFDZDNCLDREQUFpQixDQUFDLElBQUksRUFBRTJCO1FBQ3hCLE9BQU8sSUFBSTtJQUNmO0lBRUFFLFVBQVVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7UUFDM0IsSUFBSSxDQUFDN0IsR0FBRyxDQUFDMkIsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUMsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUMsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUU7UUFDakcsT0FBTyxJQUFJO0lBQ2Y7SUFFQUMsVUFBa0I7WUFBVmhCLElBQUFBLGlFQUFJLElBQUk7UUFDWmpCLDBEQUFlLENBQUMsSUFBSSxFQUFFaUI7UUFDdEIsT0FBTyxJQUFJO0lBQ2Y7SUFFQWtCLGdCQUFnQmxCLENBQUMsRUFBRTtRQUNmakIsa0VBQXVCLENBQUMsSUFBSSxFQUFFaUI7UUFDOUIsT0FBTyxJQUFJO0lBQ2Y7SUFwRUFvQixZQUFZakMsTUFBTSxDQUFDLEVBQUVDLE1BQU0sQ0FBQyxFQUFFQyxNQUFNLENBQUMsRUFBRUMsTUFBTSxDQUFDLEVBQUVDLE1BQU0sQ0FBQyxFQUFFQyxNQUFNLENBQUMsRUFBRUMsTUFBTSxDQUFDLEVBQUVDLE1BQU0sQ0FBQyxFQUFFQyxNQUFNLENBQUMsQ0FBRTtRQUN6RixLQUFLLENBQUNSLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDO1FBQzlDLE9BQU8sSUFBSTtJQUNmO0FBa0VKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvTWF0My5qcz9hODJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIE1hdDNGdW5jIGZyb20gJy4vZnVuY3Rpb25zL01hdDNGdW5jLmpzJztcblxuZXhwb3J0IGNsYXNzIE1hdDMgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IobTAwID0gMSwgbTAxID0gMCwgbTAyID0gMCwgbTEwID0gMCwgbTExID0gMSwgbTEyID0gMCwgbTIwID0gMCwgbTIxID0gMCwgbTIyID0gMSkge1xuICAgICAgICBzdXBlcihtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0KG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgICAgICAgaWYgKG0wMC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkobTAwKTtcbiAgICAgICAgTWF0M0Z1bmMuc2V0KHRoaXMsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0cmFuc2xhdGUodiwgbSA9IHRoaXMpIHtcbiAgICAgICAgTWF0M0Z1bmMudHJhbnNsYXRlKHRoaXMsIG0sIHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByb3RhdGUodiwgbSA9IHRoaXMpIHtcbiAgICAgICAgTWF0M0Z1bmMucm90YXRlKHRoaXMsIG0sIHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZSh2LCBtID0gdGhpcykge1xuICAgICAgICBNYXQzRnVuYy5zY2FsZSh0aGlzLCBtLCB2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbXVsdGlwbHkobWEsIG1iKSB7XG4gICAgICAgIGlmIChtYikge1xuICAgICAgICAgICAgTWF0M0Z1bmMubXVsdGlwbHkodGhpcywgbWEsIG1iKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE1hdDNGdW5jLm11bHRpcGx5KHRoaXMsIHRoaXMsIG1hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZGVudGl0eSgpIHtcbiAgICAgICAgTWF0M0Z1bmMuaWRlbnRpdHkodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvcHkobSkge1xuICAgICAgICBNYXQzRnVuYy5jb3B5KHRoaXMsIG0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tTWF0cml4NChtKSB7XG4gICAgICAgIE1hdDNGdW5jLmZyb21NYXQ0KHRoaXMsIG0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tUXVhdGVybmlvbihxKSB7XG4gICAgICAgIE1hdDNGdW5jLmZyb21RdWF0KHRoaXMsIHEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tQmFzaXModmVjM2EsIHZlYzNiLCB2ZWMzYykge1xuICAgICAgICB0aGlzLnNldCh2ZWMzYVswXSwgdmVjM2FbMV0sIHZlYzNhWzJdLCB2ZWMzYlswXSwgdmVjM2JbMV0sIHZlYzNiWzJdLCB2ZWMzY1swXSwgdmVjM2NbMV0sIHZlYzNjWzJdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW52ZXJzZShtID0gdGhpcykge1xuICAgICAgICBNYXQzRnVuYy5pbnZlcnQodGhpcywgbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldE5vcm1hbE1hdHJpeChtKSB7XG4gICAgICAgIE1hdDNGdW5jLm5vcm1hbEZyb21NYXQ0KHRoaXMsIG0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiTWF0M0Z1bmMiLCJNYXQzIiwiQXJyYXkiLCJzZXQiLCJtMDAiLCJtMDEiLCJtMDIiLCJtMTAiLCJtMTEiLCJtMTIiLCJtMjAiLCJtMjEiLCJtMjIiLCJsZW5ndGgiLCJjb3B5IiwidHJhbnNsYXRlIiwidiIsIm0iLCJyb3RhdGUiLCJzY2FsZSIsIm11bHRpcGx5IiwibWEiLCJtYiIsImlkZW50aXR5IiwiZnJvbU1hdHJpeDQiLCJmcm9tTWF0NCIsImZyb21RdWF0ZXJuaW9uIiwicSIsImZyb21RdWF0IiwiZnJvbUJhc2lzIiwidmVjM2EiLCJ2ZWMzYiIsInZlYzNjIiwiaW52ZXJzZSIsImludmVydCIsImdldE5vcm1hbE1hdHJpeCIsIm5vcm1hbEZyb21NYXQ0IiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/Mat3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/Mat4.js":
/*!*******************************************!*\
  !*** ./node_modules/ogl/src/math/Mat4.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mat4: function() { return /* binding */ Mat4; }\n/* harmony export */ });\n/* harmony import */ var _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions/Mat4Func.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/functions/Mat4Func.js\");\n\nclass Mat4 extends Array {\n    get x() {\n        return this[12];\n    }\n    get y() {\n        return this[13];\n    }\n    get z() {\n        return this[14];\n    }\n    get w() {\n        return this[15];\n    }\n    set x(v) {\n        this[12] = v;\n    }\n    set y(v) {\n        this[13] = v;\n    }\n    set z(v) {\n        this[14] = v;\n    }\n    set w(v) {\n        this[15] = v;\n    }\n    set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n        if (m00.length) return this.copy(m00);\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n    translate(v) {\n        let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this;\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.translate(this, m, v);\n        return this;\n    }\n    rotate(v, axis) {\n        let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this;\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.rotate(this, m, v, axis);\n        return this;\n    }\n    scale(v) {\n        let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this;\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.scale(this, m, typeof v === \"number\" ? [\n            v,\n            v,\n            v\n        ] : v);\n        return this;\n    }\n    add(ma, mb) {\n        if (mb) _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.add(this, ma, mb);\n        else _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.add(this, this, ma);\n        return this;\n    }\n    sub(ma, mb) {\n        if (mb) _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.subtract(this, ma, mb);\n        else _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.subtract(this, this, ma);\n        return this;\n    }\n    multiply(ma, mb) {\n        if (!ma.length) {\n            _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.multiplyScalar(this, this, ma);\n        } else if (mb) {\n            _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.multiply(this, ma, mb);\n        } else {\n            _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.multiply(this, this, ma);\n        }\n        return this;\n    }\n    identity() {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.identity(this);\n        return this;\n    }\n    copy(m) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.copy(this, m);\n        return this;\n    }\n    fromPerspective() {\n        let { fov, aspect, near, far } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.perspective(this, fov, aspect, near, far);\n        return this;\n    }\n    fromOrthogonal(param) {\n        let { left, right, bottom, top, near, far } = param;\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.ortho(this, left, right, bottom, top, near, far);\n        return this;\n    }\n    fromQuaternion(q) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.fromQuat(this, q);\n        return this;\n    }\n    setPosition(v) {\n        this.x = v[0];\n        this.y = v[1];\n        this.z = v[2];\n        return this;\n    }\n    inverse() {\n        let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.invert(this, m);\n        return this;\n    }\n    compose(q, pos, scale) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.compose(this, q, pos, scale);\n        return this;\n    }\n    decompose(q, pos, scale) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.decompose(this, q, pos, scale);\n        return this;\n    }\n    getRotation(q) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.getRotation(q, this);\n        return this;\n    }\n    getTranslation(pos) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.getTranslation(pos, this);\n        return this;\n    }\n    getScaling(scale) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.getScaling(scale, this);\n        return this;\n    }\n    getMaxScaleOnAxis() {\n        return _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.getMaxScaleOnAxis(this);\n    }\n    lookAt(eye, target, up) {\n        _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.targetTo(this, eye, target, up);\n        return this;\n    }\n    determinant() {\n        return _functions_Mat4Func_js__WEBPACK_IMPORTED_MODULE_0__.determinant(this);\n    }\n    fromArray(a) {\n        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        this[4] = a[o + 4];\n        this[5] = a[o + 5];\n        this[6] = a[o + 6];\n        this[7] = a[o + 7];\n        this[8] = a[o + 8];\n        this[9] = a[o + 9];\n        this[10] = a[o + 10];\n        this[11] = a[o + 11];\n        this[12] = a[o + 12];\n        this[13] = a[o + 13];\n        this[14] = a[o + 14];\n        this[15] = a[o + 15];\n        return this;\n    }\n    toArray() {\n        let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        a[o + 4] = this[4];\n        a[o + 5] = this[5];\n        a[o + 6] = this[6];\n        a[o + 7] = this[7];\n        a[o + 8] = this[8];\n        a[o + 9] = this[9];\n        a[o + 10] = this[10];\n        a[o + 11] = this[11];\n        a[o + 12] = this[12];\n        a[o + 13] = this[13];\n        a[o + 14] = this[14];\n        a[o + 15] = this[15];\n        return a;\n    }\n    constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1){\n        super(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvTWF0NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUU3QyxNQUFNQyxhQUFhQztJQXVCdEIsSUFBSUMsSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEdBQUc7SUFDbkI7SUFFQSxJQUFJQyxJQUFJO1FBQ0osT0FBTyxJQUFJLENBQUMsR0FBRztJQUNuQjtJQUVBLElBQUlDLElBQUk7UUFDSixPQUFPLElBQUksQ0FBQyxHQUFHO0lBQ25CO0lBRUEsSUFBSUMsSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEdBQUc7SUFDbkI7SUFFQSxJQUFJSCxFQUFFSSxDQUFDLEVBQUU7UUFDTCxJQUFJLENBQUMsR0FBRyxHQUFHQTtJQUNmO0lBRUEsSUFBSUgsRUFBRUcsQ0FBQyxFQUFFO1FBQ0wsSUFBSSxDQUFDLEdBQUcsR0FBR0E7SUFDZjtJQUVBLElBQUlGLEVBQUVFLENBQUMsRUFBRTtRQUNMLElBQUksQ0FBQyxHQUFHLEdBQUdBO0lBQ2Y7SUFFQSxJQUFJRCxFQUFFQyxDQUFDLEVBQUU7UUFDTCxJQUFJLENBQUMsR0FBRyxHQUFHQTtJQUNmO0lBRUFDLElBQUlDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUNoRixJQUFJZixJQUFJZ0IsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDQyxJQUFJLENBQUNqQjtRQUNqQ1QsdURBQVksQ0FBQyxJQUFJLEVBQUVTLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtDLEtB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LENBQUNDLElBQUksRUFBRTtRQUNsQixJQUFJLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUNDLElBQUksRUFBRTtRQUNsQixJQUFJLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUNDLElBQUksRUFBRTtRQUNsQixJQUFJLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUNDLElBQUksRUFBRTtRQUNsQixJQUFJLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUNDLElBQUksRUFBRTtRQUNsQixJQUFJLENBQUMsR0FBRyxHQUFHRCxDQUFDLENBQUNDLElBQUksR0FBRztRQUNwQixJQUFJLENBQUMsR0FBRyxHQUFHRCxDQUFDLENBQUNDLElBQUksR0FBRztRQUNwQixJQUFJLENBQUMsR0FBRyxHQUFHRCxDQUFDLENBQUNDLElBQUksR0FBRztRQUNwQixJQUFJLENBQUMsR0FBRyxHQUFHRCxDQUFDLENBQUNDLElBQUksR0FBRztRQUNwQixJQUFJLENBQUMsR0FBRyxHQUFHRCxDQUFDLENBQUNDLElBQUksR0FBRztRQUNwQixJQUFJLENBQUMsR0FBRyxHQUFHRCxDQUFDLENBQUNDLElBQUksR0FBRztRQUNwQixPQUFPLElBQUk7SUFDZjtJQUVBQyxVQUF1QjtZQUFmRixJQUFBQSxpRUFBSSxFQUFFLEVBQUVDLElBQUFBLGlFQUFJO1FBQ2hCRCxDQUFDLENBQUNDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRTtRQUNkRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ2xCRCxDQUFDLENBQUNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO1FBQ3BCRCxDQUFDLENBQUNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO1FBQ3BCRCxDQUFDLENBQUNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO1FBQ3BCRCxDQUFDLENBQUNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO1FBQ3BCRCxDQUFDLENBQUNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO1FBQ3BCRCxDQUFDLENBQUNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO1FBQ3BCLE9BQU9EO0lBQ1g7SUFuTkFHLFlBQ0lsRSxNQUFNLENBQUMsRUFDUEMsTUFBTSxDQUFDLEVBQ1BDLE1BQU0sQ0FBQyxFQUNQQyxNQUFNLENBQUMsRUFDUEMsTUFBTSxDQUFDLEVBQ1BDLE1BQU0sQ0FBQyxFQUNQQyxNQUFNLENBQUMsRUFDUEMsTUFBTSxDQUFDLEVBQ1BDLE1BQU0sQ0FBQyxFQUNQQyxNQUFNLENBQUMsRUFDUEMsTUFBTSxDQUFDLEVBQ1BDLE1BQU0sQ0FBQyxFQUNQQyxNQUFNLENBQUMsRUFDUEMsTUFBTSxDQUFDLEVBQ1BDLE1BQU0sQ0FBQyxFQUNQQyxNQUFNLENBQUMsQ0FDVDtRQUNFLEtBQUssQ0FBQ2YsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0M7UUFDakYsT0FBTyxJQUFJO0lBQ2Y7QUFnTUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvbWF0aC9NYXQ0LmpzP2YwODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgTWF0NEZ1bmMgZnJvbSAnLi9mdW5jdGlvbnMvTWF0NEZ1bmMuanMnO1xuXG5leHBvcnQgY2xhc3MgTWF0NCBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgbTAwID0gMSxcbiAgICAgICAgbTAxID0gMCxcbiAgICAgICAgbTAyID0gMCxcbiAgICAgICAgbTAzID0gMCxcbiAgICAgICAgbTEwID0gMCxcbiAgICAgICAgbTExID0gMSxcbiAgICAgICAgbTEyID0gMCxcbiAgICAgICAgbTEzID0gMCxcbiAgICAgICAgbTIwID0gMCxcbiAgICAgICAgbTIxID0gMCxcbiAgICAgICAgbTIyID0gMSxcbiAgICAgICAgbTIzID0gMCxcbiAgICAgICAgbTMwID0gMCxcbiAgICAgICAgbTMxID0gMCxcbiAgICAgICAgbTMyID0gMCxcbiAgICAgICAgbTMzID0gMVxuICAgICkge1xuICAgICAgICBzdXBlcihtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMTJdO1xuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpc1sxM107XG4gICAgfVxuXG4gICAgZ2V0IHooKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzE0XTtcbiAgICB9XG5cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMTVdO1xuICAgIH1cblxuICAgIHNldCB4KHYpIHtcbiAgICAgICAgdGhpc1sxMl0gPSB2O1xuICAgIH1cblxuICAgIHNldCB5KHYpIHtcbiAgICAgICAgdGhpc1sxM10gPSB2O1xuICAgIH1cblxuICAgIHNldCB6KHYpIHtcbiAgICAgICAgdGhpc1sxNF0gPSB2O1xuICAgIH1cblxuICAgIHNldCB3KHYpIHtcbiAgICAgICAgdGhpc1sxNV0gPSB2O1xuICAgIH1cblxuICAgIHNldChtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgICAgICAgaWYgKG0wMC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkobTAwKTtcbiAgICAgICAgTWF0NEZ1bmMuc2V0KHRoaXMsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZSh2LCBtID0gdGhpcykge1xuICAgICAgICBNYXQ0RnVuYy50cmFuc2xhdGUodGhpcywgbSwgdik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJvdGF0ZSh2LCBheGlzLCBtID0gdGhpcykge1xuICAgICAgICBNYXQ0RnVuYy5yb3RhdGUodGhpcywgbSwgdiwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlKHYsIG0gPSB0aGlzKSB7XG4gICAgICAgIE1hdDRGdW5jLnNjYWxlKHRoaXMsIG0sIHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IFt2LCB2LCB2XSA6IHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhZGQobWEsIG1iKSB7XG4gICAgICAgIGlmIChtYikgTWF0NEZ1bmMuYWRkKHRoaXMsIG1hLCBtYik7XG4gICAgICAgIGVsc2UgTWF0NEZ1bmMuYWRkKHRoaXMsIHRoaXMsIG1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3ViKG1hLCBtYikge1xuICAgICAgICBpZiAobWIpIE1hdDRGdW5jLnN1YnRyYWN0KHRoaXMsIG1hLCBtYik7XG4gICAgICAgIGVsc2UgTWF0NEZ1bmMuc3VidHJhY3QodGhpcywgdGhpcywgbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtdWx0aXBseShtYSwgbWIpIHtcbiAgICAgICAgaWYgKCFtYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIE1hdDRGdW5jLm11bHRpcGx5U2NhbGFyKHRoaXMsIHRoaXMsIG1hKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYikge1xuICAgICAgICAgICAgTWF0NEZ1bmMubXVsdGlwbHkodGhpcywgbWEsIG1iKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE1hdDRGdW5jLm11bHRpcGx5KHRoaXMsIHRoaXMsIG1hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZGVudGl0eSgpIHtcbiAgICAgICAgTWF0NEZ1bmMuaWRlbnRpdHkodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvcHkobSkge1xuICAgICAgICBNYXQ0RnVuYy5jb3B5KHRoaXMsIG0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tUGVyc3BlY3RpdmUoeyBmb3YsIGFzcGVjdCwgbmVhciwgZmFyIH0gPSB7fSkge1xuICAgICAgICBNYXQ0RnVuYy5wZXJzcGVjdGl2ZSh0aGlzLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnJvbU9ydGhvZ29uYWwoeyBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciB9KSB7XG4gICAgICAgIE1hdDRGdW5jLm9ydGhvKHRoaXMsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnJvbVF1YXRlcm5pb24ocSkge1xuICAgICAgICBNYXQ0RnVuYy5mcm9tUXVhdCh0aGlzLCBxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0UG9zaXRpb24odikge1xuICAgICAgICB0aGlzLnggPSB2WzBdO1xuICAgICAgICB0aGlzLnkgPSB2WzFdO1xuICAgICAgICB0aGlzLnogPSB2WzJdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnZlcnNlKG0gPSB0aGlzKSB7XG4gICAgICAgIE1hdDRGdW5jLmludmVydCh0aGlzLCBtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29tcG9zZShxLCBwb3MsIHNjYWxlKSB7XG4gICAgICAgIE1hdDRGdW5jLmNvbXBvc2UodGhpcywgcSwgcG9zLCBzY2FsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRlY29tcG9zZShxLCBwb3MsIHNjYWxlKSB7XG4gICAgICAgIE1hdDRGdW5jLmRlY29tcG9zZSh0aGlzLCBxLCBwb3MsIHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0Um90YXRpb24ocSkge1xuICAgICAgICBNYXQ0RnVuYy5nZXRSb3RhdGlvbihxLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0VHJhbnNsYXRpb24ocG9zKSB7XG4gICAgICAgIE1hdDRGdW5jLmdldFRyYW5zbGF0aW9uKHBvcywgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFNjYWxpbmcoc2NhbGUpIHtcbiAgICAgICAgTWF0NEZ1bmMuZ2V0U2NhbGluZyhzY2FsZSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldE1heFNjYWxlT25BeGlzKCkge1xuICAgICAgICByZXR1cm4gTWF0NEZ1bmMuZ2V0TWF4U2NhbGVPbkF4aXModGhpcyk7XG4gICAgfVxuXG4gICAgbG9va0F0KGV5ZSwgdGFyZ2V0LCB1cCkge1xuICAgICAgICBNYXQ0RnVuYy50YXJnZXRUbyh0aGlzLCBleWUsIHRhcmdldCwgdXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkZXRlcm1pbmFudCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdDRGdW5jLmRldGVybWluYW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZyb21BcnJheShhLCBvID0gMCkge1xuICAgICAgICB0aGlzWzBdID0gYVtvXTtcbiAgICAgICAgdGhpc1sxXSA9IGFbbyArIDFdO1xuICAgICAgICB0aGlzWzJdID0gYVtvICsgMl07XG4gICAgICAgIHRoaXNbM10gPSBhW28gKyAzXTtcbiAgICAgICAgdGhpc1s0XSA9IGFbbyArIDRdO1xuICAgICAgICB0aGlzWzVdID0gYVtvICsgNV07XG4gICAgICAgIHRoaXNbNl0gPSBhW28gKyA2XTtcbiAgICAgICAgdGhpc1s3XSA9IGFbbyArIDddO1xuICAgICAgICB0aGlzWzhdID0gYVtvICsgOF07XG4gICAgICAgIHRoaXNbOV0gPSBhW28gKyA5XTtcbiAgICAgICAgdGhpc1sxMF0gPSBhW28gKyAxMF07XG4gICAgICAgIHRoaXNbMTFdID0gYVtvICsgMTFdO1xuICAgICAgICB0aGlzWzEyXSA9IGFbbyArIDEyXTtcbiAgICAgICAgdGhpc1sxM10gPSBhW28gKyAxM107XG4gICAgICAgIHRoaXNbMTRdID0gYVtvICsgMTRdO1xuICAgICAgICB0aGlzWzE1XSA9IGFbbyArIDE1XTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9BcnJheShhID0gW10sIG8gPSAwKSB7XG4gICAgICAgIGFbb10gPSB0aGlzWzBdO1xuICAgICAgICBhW28gKyAxXSA9IHRoaXNbMV07XG4gICAgICAgIGFbbyArIDJdID0gdGhpc1syXTtcbiAgICAgICAgYVtvICsgM10gPSB0aGlzWzNdO1xuICAgICAgICBhW28gKyA0XSA9IHRoaXNbNF07XG4gICAgICAgIGFbbyArIDVdID0gdGhpc1s1XTtcbiAgICAgICAgYVtvICsgNl0gPSB0aGlzWzZdO1xuICAgICAgICBhW28gKyA3XSA9IHRoaXNbN107XG4gICAgICAgIGFbbyArIDhdID0gdGhpc1s4XTtcbiAgICAgICAgYVtvICsgOV0gPSB0aGlzWzldO1xuICAgICAgICBhW28gKyAxMF0gPSB0aGlzWzEwXTtcbiAgICAgICAgYVtvICsgMTFdID0gdGhpc1sxMV07XG4gICAgICAgIGFbbyArIDEyXSA9IHRoaXNbMTJdO1xuICAgICAgICBhW28gKyAxM10gPSB0aGlzWzEzXTtcbiAgICAgICAgYVtvICsgMTRdID0gdGhpc1sxNF07XG4gICAgICAgIGFbbyArIDE1XSA9IHRoaXNbMTVdO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiTWF0NEZ1bmMiLCJNYXQ0IiwiQXJyYXkiLCJ4IiwieSIsInoiLCJ3IiwidiIsInNldCIsIm0wMCIsIm0wMSIsIm0wMiIsIm0wMyIsIm0xMCIsIm0xMSIsIm0xMiIsIm0xMyIsIm0yMCIsIm0yMSIsIm0yMiIsIm0yMyIsIm0zMCIsIm0zMSIsIm0zMiIsIm0zMyIsImxlbmd0aCIsImNvcHkiLCJ0cmFuc2xhdGUiLCJtIiwicm90YXRlIiwiYXhpcyIsInNjYWxlIiwiYWRkIiwibWEiLCJtYiIsInN1YiIsInN1YnRyYWN0IiwibXVsdGlwbHkiLCJtdWx0aXBseVNjYWxhciIsImlkZW50aXR5IiwiZnJvbVBlcnNwZWN0aXZlIiwiZm92IiwiYXNwZWN0IiwibmVhciIsImZhciIsInBlcnNwZWN0aXZlIiwiZnJvbU9ydGhvZ29uYWwiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ0b3AiLCJvcnRobyIsImZyb21RdWF0ZXJuaW9uIiwicSIsImZyb21RdWF0Iiwic2V0UG9zaXRpb24iLCJpbnZlcnNlIiwiaW52ZXJ0IiwiY29tcG9zZSIsInBvcyIsImRlY29tcG9zZSIsImdldFJvdGF0aW9uIiwiZ2V0VHJhbnNsYXRpb24iLCJnZXRTY2FsaW5nIiwiZ2V0TWF4U2NhbGVPbkF4aXMiLCJsb29rQXQiLCJleWUiLCJ0YXJnZXQiLCJ1cCIsInRhcmdldFRvIiwiZGV0ZXJtaW5hbnQiLCJmcm9tQXJyYXkiLCJhIiwibyIsInRvQXJyYXkiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/Mat4.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/Quat.js":
/*!*******************************************!*\
  !*** ./node_modules/ogl/src/math/Quat.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Quat: function() { return /* binding */ Quat; }\n/* harmony export */ });\n/* harmony import */ var _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions/QuatFunc.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/functions/QuatFunc.js\");\n\nclass Quat extends Array {\n    get x() {\n        return this[0];\n    }\n    get y() {\n        return this[1];\n    }\n    get z() {\n        return this[2];\n    }\n    get w() {\n        return this[3];\n    }\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n    set w(v) {\n        this._target[3] = v;\n        this.onChange();\n    }\n    identity() {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.identity(this._target);\n        this.onChange();\n        return this;\n    }\n    set(x, y, z, w) {\n        if (x.length) return this.copy(x);\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.set(this._target, x, y, z, w);\n        this.onChange();\n        return this;\n    }\n    rotateX(a) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.rotateX(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n    rotateY(a) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.rotateY(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n    rotateZ(a) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.rotateZ(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n    inverse() {\n        let q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._target;\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.invert(this._target, q);\n        this.onChange();\n        return this;\n    }\n    conjugate() {\n        let q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._target;\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.conjugate(this._target, q);\n        this.onChange();\n        return this;\n    }\n    copy(q) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.copy(this._target, q);\n        this.onChange();\n        return this;\n    }\n    normalize() {\n        let q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._target;\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.normalize(this._target, q);\n        this.onChange();\n        return this;\n    }\n    multiply(qA, qB) {\n        if (qB) {\n            _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.multiply(this._target, qA, qB);\n        } else {\n            _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.multiply(this._target, this._target, qA);\n        }\n        this.onChange();\n        return this;\n    }\n    dot(v) {\n        return _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.dot(this._target, v);\n    }\n    fromMatrix3(matrix3) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.fromMat3(this._target, matrix3);\n        this.onChange();\n        return this;\n    }\n    fromEuler(euler, isInternal) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.fromEuler(this._target, euler, euler.order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n    fromAxisAngle(axis, a) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.setAxisAngle(this._target, axis, a);\n        this.onChange();\n        return this;\n    }\n    slerp(q, t) {\n        _functions_QuatFunc_js__WEBPACK_IMPORTED_MODULE_0__.slerp(this._target, this._target, q, t);\n        this.onChange();\n        return this;\n    }\n    fromArray(a) {\n        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        this._target[3] = a[o + 3];\n        this.onChange();\n        return this;\n    }\n    toArray() {\n        let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n    constructor(x = 0, y = 0, z = 0, w = 1){\n        super(x, y, z, w);\n        this.onChange = ()=>{};\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = [\n            \"0\",\n            \"1\",\n            \"2\",\n            \"3\"\n        ];\n        return new Proxy(this, {\n            set (target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            }\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvUXVhdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUU3QyxNQUFNQyxhQUFhQztJQW1CdEIsSUFBSUMsSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEVBQUU7SUFDbEI7SUFFQSxJQUFJQyxJQUFJO1FBQ0osT0FBTyxJQUFJLENBQUMsRUFBRTtJQUNsQjtJQUVBLElBQUlDLElBQUk7UUFDSixPQUFPLElBQUksQ0FBQyxFQUFFO0lBQ2xCO0lBRUEsSUFBSUMsSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEVBQUU7SUFDbEI7SUFFQSxJQUFJSCxFQUFFSSxDQUFDLEVBQUU7UUFDTCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLEdBQUdEO1FBQ2xCLElBQUksQ0FBQ0UsUUFBUTtJQUNqQjtJQUVBLElBQUlMLEVBQUVHLENBQUMsRUFBRTtRQUNMLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsR0FBR0Q7UUFDbEIsSUFBSSxDQUFDRSxRQUFRO0lBQ2pCO0lBRUEsSUFBSUosRUFBRUUsQ0FBQyxFQUFFO1FBQ0wsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxHQUFHRDtRQUNsQixJQUFJLENBQUNFLFFBQVE7SUFDakI7SUFFQSxJQUFJSCxFQUFFQyxDQUFDLEVBQUU7UUFDTCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLEdBQUdEO1FBQ2xCLElBQUksQ0FBQ0UsUUFBUTtJQUNqQjtJQUVBQyxXQUFXO1FBQ1BWLDREQUFpQixDQUFDLElBQUksQ0FBQ1EsT0FBTztRQUM5QixJQUFJLENBQUNDLFFBQVE7UUFDYixPQUFPLElBQUk7SUFDZjtJQUVBRSxJQUFJUixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDWixJQUFJSCxFQUFFUyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUNDLElBQUksQ0FBQ1Y7UUFDL0JILHVEQUFZLENBQUMsSUFBSSxDQUFD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LFFBQVFyQyxHQUFHLElBQUlzQztnQkFDL0IsSUFBSUYsV0FBV0osYUFBYU8sUUFBUSxDQUFDSixXQUFXRCxPQUFPcEMsUUFBUTtnQkFDL0QsT0FBT3NDO1lBQ1g7UUFDSjtJQUNKO0FBb0pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvUXVhdC5qcz81OTlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFF1YXRGdW5jIGZyb20gJy4vZnVuY3Rpb25zL1F1YXRGdW5jLmpzJztcblxuZXhwb3J0IGNsYXNzIFF1YXQgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEpIHtcbiAgICAgICAgc3VwZXIoeCwgeSwgeiwgdyk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7fTtcblxuICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZSB0byBwcm94eSB0YXJnZXQgdG8gYXZvaWQgdHJpZ2dlcmluZyBvbkNoYW5nZSBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgcHJveHkgdG8gdHJpZ2dlciBvbkNoYW5nZSB3aGVuIGFycmF5IGVsZW1lbnRzIGFyZSBlZGl0ZWQgZGlyZWN0bHlcbiAgICAgICAgY29uc3QgdHJpZ2dlclByb3BzID0gWycwJywgJzEnLCAnMicsICczJ107XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgc2V0KHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gUmVmbGVjdC5zZXQoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2VzcyAmJiB0cmlnZ2VyUHJvcHMuaW5jbHVkZXMocHJvcGVydHkpKSB0YXJnZXQub25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpc1swXTtcbiAgICB9XG5cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMV07XG4gICAgfVxuXG4gICAgZ2V0IHooKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzJdO1xuICAgIH1cblxuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpc1szXTtcbiAgICB9XG5cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFswXSA9IHY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFsxXSA9IHY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzZXQgeih2KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFsyXSA9IHY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzZXQgdyh2KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFszXSA9IHY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBpZGVudGl0eSgpIHtcbiAgICAgICAgUXVhdEZ1bmMuaWRlbnRpdHkodGhpcy5fdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQoeCwgeSwgeiwgdykge1xuICAgICAgICBpZiAoeC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkoeCk7XG4gICAgICAgIFF1YXRGdW5jLnNldCh0aGlzLl90YXJnZXQsIHgsIHksIHosIHcpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJvdGF0ZVgoYSkge1xuICAgICAgICBRdWF0RnVuYy5yb3RhdGVYKHRoaXMuX3RhcmdldCwgdGhpcy5fdGFyZ2V0LCBhKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByb3RhdGVZKGEpIHtcbiAgICAgICAgUXVhdEZ1bmMucm90YXRlWSh0aGlzLl90YXJnZXQsIHRoaXMuX3RhcmdldCwgYSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcm90YXRlWihhKSB7XG4gICAgICAgIFF1YXRGdW5jLnJvdGF0ZVoodGhpcy5fdGFyZ2V0LCB0aGlzLl90YXJnZXQsIGEpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGludmVyc2UocSA9IHRoaXMuX3RhcmdldCkge1xuICAgICAgICBRdWF0RnVuYy5pbnZlcnQodGhpcy5fdGFyZ2V0LCBxKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25qdWdhdGUocSA9IHRoaXMuX3RhcmdldCkge1xuICAgICAgICBRdWF0RnVuYy5jb25qdWdhdGUodGhpcy5fdGFyZ2V0LCBxKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb3B5KHEpIHtcbiAgICAgICAgUXVhdEZ1bmMuY29weSh0aGlzLl90YXJnZXQsIHEpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZShxID0gdGhpcy5fdGFyZ2V0KSB7XG4gICAgICAgIFF1YXRGdW5jLm5vcm1hbGl6ZSh0aGlzLl90YXJnZXQsIHEpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG11bHRpcGx5KHFBLCBxQikge1xuICAgICAgICBpZiAocUIpIHtcbiAgICAgICAgICAgIFF1YXRGdW5jLm11bHRpcGx5KHRoaXMuX3RhcmdldCwgcUEsIHFCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFF1YXRGdW5jLm11bHRpcGx5KHRoaXMuX3RhcmdldCwgdGhpcy5fdGFyZ2V0LCBxQSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkb3Qodikge1xuICAgICAgICByZXR1cm4gUXVhdEZ1bmMuZG90KHRoaXMuX3RhcmdldCwgdik7XG4gICAgfVxuXG4gICAgZnJvbU1hdHJpeDMobWF0cml4Mykge1xuICAgICAgICBRdWF0RnVuYy5mcm9tTWF0Myh0aGlzLl90YXJnZXQsIG1hdHJpeDMpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZyb21FdWxlcihldWxlciwgaXNJbnRlcm5hbCkge1xuICAgICAgICBRdWF0RnVuYy5mcm9tRXVsZXIodGhpcy5fdGFyZ2V0LCBldWxlciwgZXVsZXIub3JkZXIpO1xuICAgICAgICAvLyBBdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgaWYgKCFpc0ludGVybmFsKSB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZyb21BeGlzQW5nbGUoYXhpcywgYSkge1xuICAgICAgICBRdWF0RnVuYy5zZXRBeGlzQW5nbGUodGhpcy5fdGFyZ2V0LCBheGlzLCBhKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzbGVycChxLCB0KSB7XG4gICAgICAgIFF1YXRGdW5jLnNsZXJwKHRoaXMuX3RhcmdldCwgdGhpcy5fdGFyZ2V0LCBxLCB0KTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tQXJyYXkoYSwgbyA9IDApIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzBdID0gYVtvXTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0WzFdID0gYVtvICsgMV07XG4gICAgICAgIHRoaXMuX3RhcmdldFsyXSA9IGFbbyArIDJdO1xuICAgICAgICB0aGlzLl90YXJnZXRbM10gPSBhW28gKyAzXTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0b0FycmF5KGEgPSBbXSwgbyA9IDApIHtcbiAgICAgICAgYVtvXSA9IHRoaXNbMF07XG4gICAgICAgIGFbbyArIDFdID0gdGhpc1sxXTtcbiAgICAgICAgYVtvICsgMl0gPSB0aGlzWzJdO1xuICAgICAgICBhW28gKyAzXSA9IHRoaXNbM107XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJRdWF0RnVuYyIsIlF1YXQiLCJBcnJheSIsIngiLCJ5IiwieiIsInciLCJ2IiwiX3RhcmdldCIsIm9uQ2hhbmdlIiwiaWRlbnRpdHkiLCJzZXQiLCJsZW5ndGgiLCJjb3B5Iiwicm90YXRlWCIsImEiLCJyb3RhdGVZIiwicm90YXRlWiIsImludmVyc2UiLCJxIiwiaW52ZXJ0IiwiY29uanVnYXRlIiwibm9ybWFsaXplIiwibXVsdGlwbHkiLCJxQSIsInFCIiwiZG90IiwiZnJvbU1hdHJpeDMiLCJtYXRyaXgzIiwiZnJvbU1hdDMiLCJmcm9tRXVsZXIiLCJldWxlciIsImlzSW50ZXJuYWwiLCJvcmRlciIsImZyb21BeGlzQW5nbGUiLCJheGlzIiwic2V0QXhpc0FuZ2xlIiwic2xlcnAiLCJ0IiwiZnJvbUFycmF5IiwibyIsInRvQXJyYXkiLCJjb25zdHJ1Y3RvciIsInRyaWdnZXJQcm9wcyIsIlByb3h5IiwidGFyZ2V0IiwicHJvcGVydHkiLCJzdWNjZXNzIiwiUmVmbGVjdCIsImFyZ3VtZW50cyIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/Quat.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/Vec3.js":
/*!*******************************************!*\
  !*** ./node_modules/ogl/src/math/Vec3.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vec3: function() { return /* binding */ Vec3; }\n/* harmony export */ });\n/* harmony import */ var _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions/Vec3Func.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/functions/Vec3Func.js\");\n\nclass Vec3 extends Array {\n    get x() {\n        return this[0];\n    }\n    get y() {\n        return this[1];\n    }\n    get z() {\n        return this[2];\n    }\n    set x(v) {\n        this[0] = v;\n    }\n    set y(v) {\n        this[1] = v;\n    }\n    set z(v) {\n        this[2] = v;\n    }\n    set(x) {\n        let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : x;\n        if (x.length) return this.copy(x);\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.set(this, x, y, z);\n        return this;\n    }\n    copy(v) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.copy(this, v);\n        return this;\n    }\n    add(va, vb) {\n        if (vb) _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.add(this, va, vb);\n        else _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.add(this, this, va);\n        return this;\n    }\n    sub(va, vb) {\n        if (vb) _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.subtract(this, va, vb);\n        else _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.subtract(this, this, va);\n        return this;\n    }\n    multiply(v) {\n        if (v.length) _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.multiply(this, this, v);\n        else _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.scale(this, this, v);\n        return this;\n    }\n    divide(v) {\n        if (v.length) _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.divide(this, this, v);\n        else _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.scale(this, this, 1 / v);\n        return this;\n    }\n    inverse() {\n        let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.inverse(this, v);\n        return this;\n    }\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.length(this);\n    }\n    distance(v) {\n        if (v) return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.distance(this, v);\n        else return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.length(this);\n    }\n    squaredLen() {\n        return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.squaredLength(this);\n    }\n    squaredDistance(v) {\n        if (v) return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance(this, v);\n        else return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.squaredLength(this);\n    }\n    negate() {\n        let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.negate(this, v);\n        return this;\n    }\n    cross(va, vb) {\n        if (vb) _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.cross(this, va, vb);\n        else _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.cross(this, this, va);\n        return this;\n    }\n    scale(v) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.scale(this, this, v);\n        return this;\n    }\n    normalize() {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.normalize(this, this);\n        return this;\n    }\n    dot(v) {\n        return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.dot(this, v);\n    }\n    equals(v) {\n        return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.exactEquals(this, v);\n    }\n    applyMatrix3(mat3) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.transformMat3(this, this, mat3);\n        return this;\n    }\n    applyMatrix4(mat4) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.transformMat4(this, this, mat4);\n        return this;\n    }\n    scaleRotateMatrix4(mat4) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.scaleRotateMat4(this, this, mat4);\n        return this;\n    }\n    applyQuaternion(q) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.transformQuat(this, this, q);\n        return this;\n    }\n    angle(v) {\n        return _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.angle(this, v);\n    }\n    lerp(v, t) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.lerp(this, this, v, t);\n        return this;\n    }\n    smoothLerp(v, decay, dt) {\n        _functions_Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.smoothLerp(this, this, v, decay, dt);\n        return this;\n    }\n    clone() {\n        return new Vec3(this[0], this[1], this[2]);\n    }\n    fromArray(a) {\n        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        return this;\n    }\n    toArray() {\n        let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n    transformDirection(mat4) {\n        const x = this[0];\n        const y = this[1];\n        const z = this[2];\n        this[0] = mat4[0] * x + mat4[4] * y + mat4[8] * z;\n        this[1] = mat4[1] * x + mat4[5] * y + mat4[9] * z;\n        this[2] = mat4[2] * x + mat4[6] * y + mat4[10] * z;\n        return this.normalize();\n    }\n    constructor(x = 0, y = x, z = x){\n        super(x, y, z);\n        return this;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvVmVjMy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUU3QyxNQUFNQyxhQUFhQztJQU10QixJQUFJQyxJQUFJO1FBQ0osT0FBTyxJQUFJLENBQUMsRUFBRTtJQUNsQjtJQUVBLElBQUlDLElBQUk7UUFDSixPQUFPLElBQUksQ0FBQyxFQUFFO0lBQ2xCO0lBRUEsSUFBSUMsSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEVBQUU7SUFDbEI7SUFFQSxJQUFJRixFQUFFRyxDQUFDLEVBQUU7UUFDTCxJQUFJLENBQUMsRUFBRSxHQUFHQTtJQUNkO0lBRUEsSUFBSUYsRUFBRUUsQ0FBQyxFQUFFO1FBQ0wsSUFBSSxDQUFDLEVBQUUsR0FBR0E7SUFDZDtJQUVBLElBQUlELEVBQUVDLENBQUMsRUFBRTtRQUNMLElBQUksQ0FBQyxFQUFFLEdBQUdBO0lBQ2Q7SUFFQUMsSUFBSUosQ0FBQyxFQUFnQjtZQUFkQyxJQUFBQSxpRUFBSUQsR0FBR0UsSUFBQUEsaUVBQUlGO1FBQ2QsSUFBSUEsRUFBRUssTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDQyxJQUFJLENBQUNOO1FBQy9CSCx1REFBWSxDQUFDLElBQUksRUFBRUcsR0FBR0MsR0FBR0M7UUFDekIsT0FBTyxJQUFJO0lBQ2Y7SUFFQUksS0FBS0gsQ0FBQyxFQUFFO1FBQ0pOLHdEQUFhLENBQUMsSUFBSSxFQUFFTTtRQUNwQixPQUFPLElBQUk7SUFDZjtJQUVBSSxJQUFJQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNSLElBQUlBLElBQUlaLHVEQUFZLENBQUMsSUFBSSxFQUFFVyxJQUFJQzthQUMxQlosdURBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFVztRQUM5QixPQUFPLElBQUk7SUFDZjtJQUVBRSxJQUFJRixFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNSLElBQUlBLElBQUlaLDREQUFpQixDQUFDLElBQUksRUFBRVcsSUFBSUM7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QUFDLEVBQUUsR0FBRzdCO1FBQ2hELElBQUksQ0FBQyxFQUFFLEdBQUc2QixJQUFJLENBQUMsRUFBRSxHQUFHL0IsSUFBSStCLElBQUksQ0FBQyxFQUFFLEdBQUc5QixJQUFJOEIsSUFBSSxDQUFDLEdBQUcsR0FBRzdCO1FBRWpELE9BQU8sSUFBSSxDQUFDcUIsU0FBUztJQUN6QjtJQW5MQTJCLFlBQVlsRCxJQUFJLENBQUMsRUFBRUMsSUFBSUQsQ0FBQyxFQUFFRSxJQUFJRixDQUFDLENBQUU7UUFDN0IsS0FBSyxDQUFDQSxHQUFHQyxHQUFHQztRQUNaLE9BQU8sSUFBSTtJQUNmO0FBaUxKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvVmVjMy5qcz9hZjgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFZlYzNGdW5jIGZyb20gJy4vZnVuY3Rpb25zL1ZlYzNGdW5jLmpzJztcblxuZXhwb3J0IGNsYXNzIFZlYzMgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSB4LCB6ID0geCkge1xuICAgICAgICBzdXBlcih4LCB5LCB6KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdO1xuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpc1sxXTtcbiAgICB9XG5cbiAgICBnZXQgeigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMl07XG4gICAgfVxuXG4gICAgc2V0IHgodikge1xuICAgICAgICB0aGlzWzBdID0gdjtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXNbMV0gPSB2O1xuICAgIH1cblxuICAgIHNldCB6KHYpIHtcbiAgICAgICAgdGhpc1syXSA9IHY7XG4gICAgfVxuXG4gICAgc2V0KHgsIHkgPSB4LCB6ID0geCkge1xuICAgICAgICBpZiAoeC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkoeCk7XG4gICAgICAgIFZlYzNGdW5jLnNldCh0aGlzLCB4LCB5LCB6KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29weSh2KSB7XG4gICAgICAgIFZlYzNGdW5jLmNvcHkodGhpcywgdik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGFkZCh2YSwgdmIpIHtcbiAgICAgICAgaWYgKHZiKSBWZWMzRnVuYy5hZGQodGhpcywgdmEsIHZiKTtcbiAgICAgICAgZWxzZSBWZWMzRnVuYy5hZGQodGhpcywgdGhpcywgdmEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWIodmEsIHZiKSB7XG4gICAgICAgIGlmICh2YikgVmVjM0Z1bmMuc3VidHJhY3QodGhpcywgdmEsIHZiKTtcbiAgICAgICAgZWxzZSBWZWMzRnVuYy5zdWJ0cmFjdCh0aGlzLCB0aGlzLCB2YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG11bHRpcGx5KHYpIHtcbiAgICAgICAgaWYgKHYubGVuZ3RoKSBWZWMzRnVuYy5tdWx0aXBseSh0aGlzLCB0aGlzLCB2KTtcbiAgICAgICAgZWxzZSBWZWMzRnVuYy5zY2FsZSh0aGlzLCB0aGlzLCB2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGl2aWRlKHYpIHtcbiAgICAgICAgaWYgKHYubGVuZ3RoKSBWZWMzRnVuYy5kaXZpZGUodGhpcywgdGhpcywgdik7XG4gICAgICAgIGVsc2UgVmVjM0Z1bmMuc2NhbGUodGhpcywgdGhpcywgMSAvIHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnZlcnNlKHYgPSB0aGlzKSB7XG4gICAgICAgIFZlYzNGdW5jLmludmVyc2UodGhpcywgdik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIENhbid0IHVzZSAnbGVuZ3RoJyBhcyBBcnJheS5wcm90b3R5cGUgdXNlcyBpdFxuICAgIGxlbigpIHtcbiAgICAgICAgcmV0dXJuIFZlYzNGdW5jLmxlbmd0aCh0aGlzKTtcbiAgICB9XG5cbiAgICBkaXN0YW5jZSh2KSB7XG4gICAgICAgIGlmICh2KSByZXR1cm4gVmVjM0Z1bmMuZGlzdGFuY2UodGhpcywgdik7XG4gICAgICAgIGVsc2UgcmV0dXJuIFZlYzNGdW5jLmxlbmd0aCh0aGlzKTtcbiAgICB9XG5cbiAgICBzcXVhcmVkTGVuKCkge1xuICAgICAgICByZXR1cm4gVmVjM0Z1bmMuc3F1YXJlZExlbmd0aCh0aGlzKTtcbiAgICB9XG5cbiAgICBzcXVhcmVkRGlzdGFuY2Uodikge1xuICAgICAgICBpZiAodikgcmV0dXJuIFZlYzNGdW5jLnNxdWFyZWREaXN0YW5jZSh0aGlzLCB2KTtcbiAgICAgICAgZWxzZSByZXR1cm4gVmVjM0Z1bmMuc3F1YXJlZExlbmd0aCh0aGlzKTtcbiAgICB9XG5cbiAgICBuZWdhdGUodiA9IHRoaXMpIHtcbiAgICAgICAgVmVjM0Z1bmMubmVnYXRlKHRoaXMsIHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjcm9zcyh2YSwgdmIpIHtcbiAgICAgICAgaWYgKHZiKSBWZWMzRnVuYy5jcm9zcyh0aGlzLCB2YSwgdmIpO1xuICAgICAgICBlbHNlIFZlYzNGdW5jLmNyb3NzKHRoaXMsIHRoaXMsIHZhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGUodikge1xuICAgICAgICBWZWMzRnVuYy5zY2FsZSh0aGlzLCB0aGlzLCB2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICBWZWMzRnVuYy5ub3JtYWxpemUodGhpcywgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRvdCh2KSB7XG4gICAgICAgIHJldHVybiBWZWMzRnVuYy5kb3QodGhpcywgdik7XG4gICAgfVxuXG4gICAgZXF1YWxzKHYpIHtcbiAgICAgICAgcmV0dXJuIFZlYzNGdW5jLmV4YWN0RXF1YWxzKHRoaXMsIHYpO1xuICAgIH1cblxuICAgIGFwcGx5TWF0cml4MyhtYXQzKSB7XG4gICAgICAgIFZlYzNGdW5jLnRyYW5zZm9ybU1hdDModGhpcywgdGhpcywgbWF0Myk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGFwcGx5TWF0cml4NChtYXQ0KSB7XG4gICAgICAgIFZlYzNGdW5jLnRyYW5zZm9ybU1hdDQodGhpcywgdGhpcywgbWF0NCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlUm90YXRlTWF0cml4NChtYXQ0KSB7XG4gICAgICAgIFZlYzNGdW5jLnNjYWxlUm90YXRlTWF0NCh0aGlzLCB0aGlzLCBtYXQ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYXBwbHlRdWF0ZXJuaW9uKHEpIHtcbiAgICAgICAgVmVjM0Z1bmMudHJhbnNmb3JtUXVhdCh0aGlzLCB0aGlzLCBxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYW5nbGUodikge1xuICAgICAgICByZXR1cm4gVmVjM0Z1bmMuYW5nbGUodGhpcywgdik7XG4gICAgfVxuXG4gICAgbGVycCh2LCB0KSB7XG4gICAgICAgIFZlYzNGdW5jLmxlcnAodGhpcywgdGhpcywgdiwgdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNtb290aExlcnAodiwgZGVjYXksIGR0KSB7XG4gICAgICAgIFZlYzNGdW5jLnNtb290aExlcnAodGhpcywgdGhpcywgdiwgZGVjYXksIGR0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzWzBdLCB0aGlzWzFdLCB0aGlzWzJdKTtcbiAgICB9XG5cbiAgICBmcm9tQXJyYXkoYSwgbyA9IDApIHtcbiAgICAgICAgdGhpc1swXSA9IGFbb107XG4gICAgICAgIHRoaXNbMV0gPSBhW28gKyAxXTtcbiAgICAgICAgdGhpc1syXSA9IGFbbyArIDJdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0b0FycmF5KGEgPSBbXSwgbyA9IDApIHtcbiAgICAgICAgYVtvXSA9IHRoaXNbMF07XG4gICAgICAgIGFbbyArIDFdID0gdGhpc1sxXTtcbiAgICAgICAgYVtvICsgMl0gPSB0aGlzWzJdO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1EaXJlY3Rpb24obWF0NCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpc1swXTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXNbMV07XG4gICAgICAgIGNvbnN0IHogPSB0aGlzWzJdO1xuXG4gICAgICAgIHRoaXNbMF0gPSBtYXQ0WzBdICogeCArIG1hdDRbNF0gKiB5ICsgbWF0NFs4XSAqIHo7XG4gICAgICAgIHRoaXNbMV0gPSBtYXQ0WzFdICogeCArIG1hdDRbNV0gKiB5ICsgbWF0NFs5XSAqIHo7XG4gICAgICAgIHRoaXNbMl0gPSBtYXQ0WzJdICogeCArIG1hdDRbNl0gKiB5ICsgbWF0NFsxMF0gKiB6O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWMzRnVuYyIsIlZlYzMiLCJBcnJheSIsIngiLCJ5IiwieiIsInYiLCJzZXQiLCJsZW5ndGgiLCJjb3B5IiwiYWRkIiwidmEiLCJ2YiIsInN1YiIsInN1YnRyYWN0IiwibXVsdGlwbHkiLCJzY2FsZSIsImRpdmlkZSIsImludmVyc2UiLCJsZW4iLCJkaXN0YW5jZSIsInNxdWFyZWRMZW4iLCJzcXVhcmVkTGVuZ3RoIiwic3F1YXJlZERpc3RhbmNlIiwibmVnYXRlIiwiY3Jvc3MiLCJub3JtYWxpemUiLCJkb3QiLCJlcXVhbHMiLCJleGFjdEVxdWFscyIsImFwcGx5TWF0cml4MyIsIm1hdDMiLCJ0cmFuc2Zvcm1NYXQzIiwiYXBwbHlNYXRyaXg0IiwibWF0NCIsInRyYW5zZm9ybU1hdDQiLCJzY2FsZVJvdGF0ZU1hdHJpeDQiLCJzY2FsZVJvdGF0ZU1hdDQiLCJhcHBseVF1YXRlcm5pb24iLCJxIiwidHJhbnNmb3JtUXVhdCIsImFuZ2xlIiwibGVycCIsInQiLCJzbW9vdGhMZXJwIiwiZGVjYXkiLCJkdCIsImNsb25lIiwiZnJvbUFycmF5IiwiYSIsIm8iLCJ0b0FycmF5IiwidHJhbnNmb3JtRGlyZWN0aW9uIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/Vec3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/functions/EulerFunc.js":
/*!**********************************************************!*\
  !*** ./node_modules/ogl/src/math/functions/EulerFunc.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRotationMatrix: function() { return /* binding */ fromRotationMatrix; }\n/* harmony export */ });\n// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\nfunction fromRotationMatrix(out, m) {\n    let order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"YXZ\";\n    if (order === \"XYZ\") {\n        out[1] = Math.asin(Math.min(Math.max(m[8], -1), 1));\n        if (Math.abs(m[8]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[2] = Math.atan2(-m[4], m[0]);\n        } else {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[2] = 0;\n        }\n    } else if (order === \"YXZ\") {\n        out[0] = Math.asin(-Math.min(Math.max(m[9], -1), 1));\n        if (Math.abs(m[9]) < 0.99999) {\n            out[1] = Math.atan2(m[8], m[10]);\n            out[2] = Math.atan2(m[1], m[5]);\n        } else {\n            out[1] = Math.atan2(-m[2], m[0]);\n            out[2] = 0;\n        }\n    } else if (order === \"ZXY\") {\n        out[0] = Math.asin(Math.min(Math.max(m[6], -1), 1));\n        if (Math.abs(m[6]) < 0.99999) {\n            out[1] = Math.atan2(-m[2], m[10]);\n            out[2] = Math.atan2(-m[4], m[5]);\n        } else {\n            out[1] = 0;\n            out[2] = Math.atan2(m[1], m[0]);\n        }\n    } else if (order === \"ZYX\") {\n        out[1] = Math.asin(-Math.min(Math.max(m[2], -1), 1));\n        if (Math.abs(m[2]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[10]);\n            out[2] = Math.atan2(m[1], m[0]);\n        } else {\n            out[0] = 0;\n            out[2] = Math.atan2(-m[4], m[5]);\n        }\n    } else if (order === \"YZX\") {\n        out[2] = Math.asin(Math.min(Math.max(m[1], -1), 1));\n        if (Math.abs(m[1]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[5]);\n            out[1] = Math.atan2(-m[2], m[0]);\n        } else {\n            out[0] = 0;\n            out[1] = Math.atan2(m[8], m[10]);\n        }\n    } else if (order === \"XZY\") {\n        out[2] = Math.asin(-Math.min(Math.max(m[4], -1), 1));\n        if (Math.abs(m[4]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[1] = Math.atan2(m[8], m[0]);\n        } else {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[1] = 0;\n        }\n    }\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL0V1bGVyRnVuYy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsdUVBQXVFO0FBQ2hFLFNBQVNBLG1CQUFtQkMsR0FBRyxFQUFFQyxDQUFDO1FBQUVDLFFBQUFBLGlFQUFRO0lBQy9DLElBQUlBLFVBQVUsT0FBTztRQUNqQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0csS0FBS0MsSUFBSSxDQUFDRCxLQUFLRSxHQUFHLENBQUNGLEtBQUtHLEdBQUcsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUk7UUFDaEQsSUFBSUUsS0FBS0ksR0FBRyxDQUFDTixDQUFDLENBQUMsRUFBRSxJQUFJLFNBQVM7WUFDMUJELEdBQUcsQ0FBQyxFQUFFLEdBQUdHLEtBQUtLLEtBQUssQ0FBQyxDQUFDUCxDQUFDLENBQUMsRUFBRSxFQUFFQSxDQUFDLENBQUMsR0FBRztZQUNoQ0QsR0FBRyxDQUFDLEVBQUUsR0FBR0csS0FBS0ssS0FBSyxDQUFDLENBQUNQLENBQUMsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxFQUFFO1FBQ25DLE9BQU87WUFDSEQsR0FBRyxDQUFDLEVBQUUsR0FBR0csS0FBS0ssS0FBSyxDQUFDUCxDQUFDLENBQUMsRUFBRSxFQUFFQSxDQUFDLENBQUMsRUFBRTtZQUM5QkQsR0FBRyxDQUFDLEVBQUUsR0FBRztRQUNiO0lBQ0osT0FBTyxJQUFJRSxVQUFVLE9BQU87UUFDeEJGLEdBQUcsQ0FBQyxFQUFFLEdBQUdHLEtBQUtDLElBQUksQ0FBQyxDQUFDRCxLQUFLRSxHQUFHLENBQUNGLEtBQUtHLEdBQUcsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUk7UUFDakQsSUFBSUUsS0FBS0ksR0FBRyxDQUFDTixDQUFDLENBQUMsRUFBRSxJQUFJLFNBQVM7WUFDMUJELEdBQUcsQ0FBQyxFQUFFLEdBQUdHLEtBQUtLLEtBQUssQ0FBQ1AsQ0FBQyxD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LENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJO1FBQ2pELElBQUlFLEtBQUtJLEdBQUcsQ0FBQ04sQ0FBQyxDQUFDLEVBQUUsSUFBSSxTQUFTO1lBQzFCRCxHQUFHLENBQUMsRUFBRSxHQUFHRyxLQUFLSyxLQUFLLENBQUNQLENBQUMsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxFQUFFO1lBQzlCRCxHQUFHLENBQUMsRUFBRSxHQUFHRyxLQUFLSyxLQUFLLENBQUNQLENBQUMsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxFQUFFO1FBQ2xDLE9BQU87WUFDSEQsR0FBRyxDQUFDLEVBQUUsR0FBR0csS0FBS0ssS0FBSyxDQUFDLENBQUNQLENBQUMsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxHQUFHO1lBQ2hDRCxHQUFHLENBQUMsRUFBRSxHQUFHO1FBQ2I7SUFDSjtJQUVBLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvbWF0aC9mdW5jdGlvbnMvRXVsZXJGdW5jLmpzP2NiMzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25NYXRyaXgob3V0LCBtLCBvcmRlciA9ICdZWFonKSB7XG4gICAgaWYgKG9yZGVyID09PSAnWFlaJykge1xuICAgICAgICBvdXRbMV0gPSBNYXRoLmFzaW4oTWF0aC5taW4oTWF0aC5tYXgobVs4XSwgLTEpLCAxKSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhtWzhdKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGguYXRhbjIoLW1bOV0sIG1bMTBdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIoLW1bNF0sIG1bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5hdGFuMihtWzZdLCBtWzVdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuICAgICAgICBvdXRbMF0gPSBNYXRoLmFzaW4oLU1hdGgubWluKE1hdGgubWF4KG1bOV0sIC0xKSwgMSkpO1xuICAgICAgICBpZiAoTWF0aC5hYnMobVs5XSkgPCAwLjk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLmF0YW4yKG1bOF0sIG1bMTBdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIobVsxXSwgbVs1XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLmF0YW4yKC1tWzJdLCBtWzBdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWlhZJykge1xuICAgICAgICBvdXRbMF0gPSBNYXRoLmFzaW4oTWF0aC5taW4oTWF0aC5tYXgobVs2XSwgLTEpLCAxKSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhtWzZdKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGguYXRhbjIoLW1bMl0sIG1bMTBdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIoLW1bNF0sIG1bNV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIobVsxXSwgbVswXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuICAgICAgICBvdXRbMV0gPSBNYXRoLmFzaW4oLU1hdGgubWluKE1hdGgubWF4KG1bMl0sIC0xKSwgMSkpO1xuICAgICAgICBpZiAoTWF0aC5hYnMobVsyXSkgPCAwLjk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLmF0YW4yKG1bNl0sIG1bMTBdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIobVsxXSwgbVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gTWF0aC5hdGFuMigtbVs0XSwgbVs1XSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuICAgICAgICBvdXRbMl0gPSBNYXRoLmFzaW4oTWF0aC5taW4oTWF0aC5tYXgobVsxXSwgLTEpLCAxKSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhtWzFdKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGguYXRhbjIoLW1bOV0sIG1bNV0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5hdGFuMigtbVsyXSwgbVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5hdGFuMihtWzhdLCBtWzEwXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykge1xuICAgICAgICBvdXRbMl0gPSBNYXRoLmFzaW4oLU1hdGgubWluKE1hdGgubWF4KG1bNF0sIC0xKSwgMSkpO1xuICAgICAgICBpZiAoTWF0aC5hYnMobVs0XSkgPCAwLjk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLmF0YW4yKG1bNl0sIG1bNV0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5hdGFuMihtWzhdLCBtWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGguYXRhbjIoLW1bOV0sIG1bMTBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuIl0sIm5hbWVzIjpbImZyb21Sb3RhdGlvbk1hdHJpeCIsIm91dCIsIm0iLCJvcmRlciIsIk1hdGgiLCJhc2luIiwibWluIiwibWF4IiwiYWJzIiwiYXRhbjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/functions/EulerFunc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/functions/Mat3Func.js":
/*!*********************************************************!*\
  !*** ./node_modules/ogl/src/math/functions/Mat3Func.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   copy: function() { return /* binding */ copy; },\n/* harmony export */   determinant: function() { return /* binding */ determinant; },\n/* harmony export */   fromMat4: function() { return /* binding */ fromMat4; },\n/* harmony export */   fromQuat: function() { return /* binding */ fromQuat; },\n/* harmony export */   identity: function() { return /* binding */ identity; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   multiply: function() { return /* binding */ multiply; },\n/* harmony export */   multiplyScalar: function() { return /* binding */ multiplyScalar; },\n/* harmony export */   normalFromMat4: function() { return /* binding */ normalFromMat4; },\n/* harmony export */   projection: function() { return /* binding */ projection; },\n/* harmony export */   rotate: function() { return /* binding */ rotate; },\n/* harmony export */   scale: function() { return /* binding */ scale; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   subtract: function() { return /* binding */ subtract; },\n/* harmony export */   translate: function() { return /* binding */ translate; },\n/* harmony export */   transpose: function() { return /* binding */ transpose; }\n/* harmony export */ });\nconst EPSILON = 0.000001;\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */ function fromMat4(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */ function fromQuat(out, q) {\n    let x = q[0], y = q[1], z = q[2], w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n    return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */ function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */ function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */ function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */ function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1], a02 = a[2], a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n    return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */ function invert(out, a) {\n    let a00 = a[0], a01 = a[1], a02 = a[2];\n    let a10 = a[3], a11 = a[4], a12 = a[5];\n    let a20 = a[6], a21 = a[7], a22 = a[8];\n    let b01 = a22 * a11 - a12 * a21;\n    let b11 = -a22 * a10 + a12 * a20;\n    let b21 = a21 * a10 - a11 * a20;\n    // Calculate the determinant\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */ function determinant(a) {\n    let a00 = a[0], a01 = a[1], a02 = a[2];\n    let a10 = a[3], a11 = a[4], a12 = a[5];\n    let a20 = a[6], a21 = a[7], a22 = a[8];\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */ function multiply(out, a, b) {\n    let a00 = a[0], a01 = a[1], a02 = a[2];\n    let a10 = a[3], a11 = a[4], a12 = a[5];\n    let a20 = a[6], a21 = a[7], a22 = a[8];\n    let b00 = b[0], b01 = b[1], b02 = b[2];\n    let b10 = b[3], b11 = b[4], b12 = b[5];\n    let b20 = b[6], b21 = b[7], b22 = b[8];\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */ function translate(out, a, v) {\n    let a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */ function rotate(out, a, rad) {\n    let a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/ function scale(out, a, v) {\n    let x = v[0], y = v[1];\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */ function normalFromMat4(out, a) {\n    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */ function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */ function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */ function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */ function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL01hdDNGdW5jLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBTUEsVUFBVTtBQUVoQjs7Ozs7O0NBTUMsR0FDTSxTQUFTQyxTQUFTQyxHQUFHLEVBQUVDLENBQUM7SUFDM0JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxHQUFHO0lBQ2QsT0FBT0Q7QUFDWDtBQUVBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTRSxTQUFTRixHQUFHLEVBQUVHLENBQUM7SUFDM0IsSUFBSUMsSUFBSUQsQ0FBQyxDQUFDLEVBQUUsRUFDUkUsSUFBSUYsQ0FBQyxDQUFDLEVBQUUsRUFDUkcsSUFBSUgsQ0FBQyxDQUFDLEVBQUUsRUFDUkksSUFBSUosQ0FBQyxDQUFDLEVBQUU7SUFDWixJQUFJSyxLQUFLSixJQUFJQTtJQUNiLElBQUlLLEtBQUtKLElBQUlBO0lBQ2IsSUFBSUssS0FBS0osSUFBSUE7SUFFYixJQUFJSyxLQUFLUCxJQUFJSTtJQUNiLElBQUlJLEtBQUtQLElBQUlHO0lBQ2IsSUFBSUssS0FBS1IsSUFBSUk7SUFDYixJQUFJSyxLQUFL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RCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEIsT0FBT2pEO0FBQ1g7QUFFQTs7Ozs7OztDQU9DLEdBQ00sU0FBU3FGLFNBQVNyRixHQUFHLEVBQUVDLENBQUMsRUFBRWdELENBQUM7SUFDOUJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEIsT0FBT2pEO0FBQ1g7QUFFQTs7Ozs7OztDQU9DLEdBQ00sU0FBU3NGLGVBQWV0RixHQUFHLEVBQUVDLENBQUMsRUFBRWdELENBQUM7SUFDcENqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEJqRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHZ0Q7SUFDaEIsT0FBT2pEO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvbWF0aC9mdW5jdGlvbnMvTWF0M0Z1bmMuanM/NDY1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFUFNJTE9OID0gMC4wMDAwMDE7XG5cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDQob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVs0XTtcbiAgICBvdXRbNF0gPSBhWzVdO1xuICAgIG91dFs1XSA9IGFbNl07XG4gICAgb3V0WzZdID0gYVs4XTtcbiAgICBvdXRbN10gPSBhWzldO1xuICAgIG91dFs4XSA9IGFbMTBdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICpcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICAgIGxldCB4ID0gcVswXSxcbiAgICAgICAgeSA9IHFbMV0sXG4gICAgICAgIHogPSBxWzJdLFxuICAgICAgICB3ID0gcVszXTtcbiAgICBsZXQgeDIgPSB4ICsgeDtcbiAgICBsZXQgeTIgPSB5ICsgeTtcbiAgICBsZXQgejIgPSB6ICsgejtcblxuICAgIGxldCB4eCA9IHggKiB4MjtcbiAgICBsZXQgeXggPSB5ICogeDI7XG4gICAgbGV0IHl5ID0geSAqIHkyO1xuICAgIGxldCB6eCA9IHogKiB4MjtcbiAgICBsZXQgenkgPSB6ICogeTI7XG4gICAgbGV0IHp6ID0geiAqIHoyO1xuICAgIGxldCB3eCA9IHcgKiB4MjtcbiAgICBsZXQgd3kgPSB3ICogeTI7XG4gICAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMDI7XG4gICAgb3V0WzNdID0gbTEwO1xuICAgIG91dFs0XSA9IG0xMTtcbiAgICBvdXRbNV0gPSBtMTI7XG4gICAgb3V0WzZdID0gbTIwO1xuICAgIG91dFs3XSA9IG0yMTtcbiAgICBvdXRbOF0gPSBtMjI7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgbGV0IGEwMSA9IGFbMV0sXG4gICAgICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICAgICAgYTEyID0gYVs1XTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYTAxO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhMDI7XG4gICAgICAgIG91dFs3XSA9IGExMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhWzFdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhWzJdO1xuICAgICAgICBvdXRbN10gPSBhWzVdO1xuICAgICAgICBvdXRbOF0gPSBhWzhdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gICAgbGV0IGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl07XG4gICAgbGV0IGExMCA9IGFbM10sXG4gICAgICAgIGExMSA9IGFbNF0sXG4gICAgICAgIGExMiA9IGFbNV07XG4gICAgbGV0IGEyMCA9IGFbNl0sXG4gICAgICAgIGEyMSA9IGFbN10sXG4gICAgICAgIGEyMiA9IGFbOF07XG5cbiAgICBsZXQgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xuICAgIGxldCBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICAgIGxldCBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgbGV0IGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICAgIGxldCBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdO1xuICAgIGxldCBhMTAgPSBhWzNdLFxuICAgICAgICBhMTEgPSBhWzRdLFxuICAgICAgICBhMTIgPSBhWzVdO1xuICAgIGxldCBhMjAgPSBhWzZdLFxuICAgICAgICBhMjEgPSBhWzddLFxuICAgICAgICBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgbGV0IGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl07XG4gICAgbGV0IGExMCA9IGFbM10sXG4gICAgICAgIGExMSA9IGFbNF0sXG4gICAgICAgIGExMiA9IGFbNV07XG4gICAgbGV0IGEyMCA9IGFbNl0sXG4gICAgICAgIGEyMSA9IGFbN10sXG4gICAgICAgIGEyMiA9IGFbOF07XG5cbiAgICBsZXQgYjAwID0gYlswXSxcbiAgICAgICAgYjAxID0gYlsxXSxcbiAgICAgICAgYjAyID0gYlsyXTtcbiAgICBsZXQgYjEwID0gYlszXSxcbiAgICAgICAgYjExID0gYls0XSxcbiAgICAgICAgYjEyID0gYls1XTtcbiAgICBsZXQgYjIwID0gYls2XSxcbiAgICAgICAgYjIxID0gYls3XSxcbiAgICAgICAgYjIyID0gYls4XTtcblxuICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gICAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuXG4gICAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICAgIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG5cbiAgICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gICAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICAgIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gICAgbGV0IGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sXG4gICAgICAgIGExMSA9IGFbNF0sXG4gICAgICAgIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sXG4gICAgICAgIGEyMSA9IGFbN10sXG4gICAgICAgIGEyMiA9IGFbOF0sXG4gICAgICAgIHggPSB2WzBdLFxuICAgICAgICB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuXG4gICAgb3V0WzNdID0gYTEwO1xuICAgIG91dFs0XSA9IGExMTtcbiAgICBvdXRbNV0gPSBhMTI7XG5cbiAgICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgICBsZXQgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSxcbiAgICAgICAgYTExID0gYVs0XSxcbiAgICAgICAgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSxcbiAgICAgICAgYTIxID0gYVs3XSxcbiAgICAgICAgYTIyID0gYVs4XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgICBsZXQgeCA9IHZbMF0sXG4gICAgICAgIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0geCAqIGFbMF07XG4gICAgb3V0WzFdID0geCAqIGFbMV07XG4gICAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgICBvdXRbM10gPSB5ICogYVszXTtcbiAgICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7bWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsRnJvbU1hdDQob3V0LCBhKSB7XG4gICAgbGV0IGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM107XG4gICAgbGV0IGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG4gICAgbGV0IGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcbiAgICBsZXQgYTMwID0gYVsxMl0sXG4gICAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgICBhMzIgPSBhWzE0XSxcbiAgICAgICAgYTMzID0gYVsxNV07XG5cbiAgICBsZXQgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICAgIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gICAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgICBsZXQgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICAgIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gICAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgICBsZXQgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICAgIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gICAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgICBsZXQgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICAgIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gICAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZ2wgY29udGV4dFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBvdXRbMF0gPSAyIC8gd2lkdGg7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAtMTtcbiAgICBvdXRbN10gPSAxO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSArIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICAgIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICAgIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICAgIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICBvdXRbNl0gPSBhWzZdICogYjtcbiAgICBvdXRbN10gPSBhWzddICogYjtcbiAgICBvdXRbOF0gPSBhWzhdICogYjtcbiAgICByZXR1cm4gb3V0O1xufVxuIl0sIm5hbWVzIjpbIkVQU0lMT04iLCJmcm9tTWF0NCIsIm91dCIsImEiLCJmcm9tUXVhdCIsInEiLCJ4IiwieSIsInoiLCJ3IiwieDIiLCJ5MiIsInoyIiwieHgiLCJ5eCIsInl5IiwiengiLCJ6eSIsInp6Iiwid3giLCJ3eSIsInd6IiwiY29weSIsInNldCIsIm0wMCIsIm0wMSIsIm0wMiIsIm0xMCIsIm0xMSIsIm0xMiIsIm0yMCIsIm0yMSIsIm0yMiIsImlkZW50aXR5IiwidHJhbnNwb3NlIiwiYTAxIiwiYTAyIiwiYTEyIiwiaW52ZXJ0IiwiYTAwIiwiYTEwIiwiYTExIiwiYTIwIiwiYTIxIiwiYTIyIiwiYjAxIiwiYjExIiwiYjIxIiwiZGV0IiwiZGV0ZXJtaW5hbnQiLCJtdWx0aXBseSIsImIiLCJiMDAiLCJiMDIiLCJiMTAiLCJiMTIiLCJiMjAiLCJiMjIiLCJ0cmFuc2xhdGUiLCJ2Iiwicm90YXRlIiwicmFkIiwicyIsIk1hdGgiLCJzaW4iLCJjIiwiY29zIiwic2NhbGUiLCJub3JtYWxGcm9tTWF0NCIsImEwMyIsImExMyIsImEyMyIsImEzMCIsImEzMSIsImEzMiIsImEzMyIsImIwMyIsImIwNCIsImIwNSIsImIwNiIsImIwNyIsImIwOCIsImIwOSIsInByb2plY3Rpb24iLCJ3aWR0aCIsImhlaWdodCIsImFkZCIsInN1YnRyYWN0IiwibXVsdGlwbHlTY2FsYXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/functions/Mat3Func.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/functions/Mat4Func.js":
/*!*********************************************************!*\
  !*** ./node_modules/ogl/src/math/functions/Mat4Func.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   compose: function() { return /* binding */ compose; },\n/* harmony export */   copy: function() { return /* binding */ copy; },\n/* harmony export */   decompose: function() { return /* binding */ decompose; },\n/* harmony export */   determinant: function() { return /* binding */ determinant; },\n/* harmony export */   fromQuat: function() { return /* binding */ fromQuat; },\n/* harmony export */   fromRotationTranslationScale: function() { return /* binding */ fromRotationTranslationScale; },\n/* harmony export */   getMaxScaleOnAxis: function() { return /* binding */ getMaxScaleOnAxis; },\n/* harmony export */   getRotation: function() { return /* binding */ getRotation; },\n/* harmony export */   getScaling: function() { return /* binding */ getScaling; },\n/* harmony export */   getTranslation: function() { return /* binding */ getTranslation; },\n/* harmony export */   identity: function() { return /* binding */ identity; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   multiply: function() { return /* binding */ multiply; },\n/* harmony export */   multiplyScalar: function() { return /* binding */ multiplyScalar; },\n/* harmony export */   ortho: function() { return /* binding */ ortho; },\n/* harmony export */   perspective: function() { return /* binding */ perspective; },\n/* harmony export */   rotate: function() { return /* binding */ rotate; },\n/* harmony export */   scale: function() { return /* binding */ scale; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   subtract: function() { return /* binding */ subtract; },\n/* harmony export */   targetTo: function() { return /* binding */ targetTo; },\n/* harmony export */   translate: function() { return /* binding */ translate; },\n/* harmony export */   transpose: function() { return /* binding */ transpose; }\n/* harmony export */ });\n/* harmony import */ var _Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3Func.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/functions/Vec3Func.js\");\n\nconst EPSILON = 0.000001;\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */ function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */ function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */ function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */ function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1], a02 = a[2], a03 = a[3];\n        let a12 = a[6], a13 = a[7];\n        let a23 = a[11];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n    return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */ function invert(out, a) {\n    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n    return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */ function determinant(a) {\n    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */ function multiply(out, a, b) {\n    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    // Cache only the current line of the second matrix\n    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */ function translate(out, a, v) {\n    let x = v[0], y = v[1], z = v[2];\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0];\n        a01 = a[1];\n        a02 = a[2];\n        a03 = a[3];\n        a10 = a[4];\n        a11 = a[5];\n        a12 = a[6];\n        a13 = a[7];\n        a20 = a[8];\n        a21 = a[9];\n        a22 = a[10];\n        a23 = a[11];\n        out[0] = a00;\n        out[1] = a01;\n        out[2] = a02;\n        out[3] = a03;\n        out[4] = a10;\n        out[5] = a11;\n        out[6] = a12;\n        out[7] = a13;\n        out[8] = a20;\n        out[9] = a21;\n        out[10] = a22;\n        out[11] = a23;\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n    return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/ function scale(out, a, v) {\n    let x = v[0], y = v[1], z = v[2];\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */ function rotate(out, a, rad, axis) {\n    let x = axis[0], y = axis[1], z = axis[2];\n    let len = Math.hypot(x, y, z);\n    let s, c, t;\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n    let b00, b01, b02;\n    let b10, b11, b12;\n    let b20, b21, b22;\n    if (Math.abs(len) < EPSILON) {\n        return null;\n    }\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c;\n    b01 = y * x * t + z * s;\n    b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s;\n    b11 = y * y * t + c;\n    b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s;\n    b21 = y * z * t - x * s;\n    b22 = z * z * t + c;\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n    if (a !== out) {\n        // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */ function getTranslation(out, mat) {\n    out[0] = mat[12];\n    out[1] = mat[13];\n    out[2] = mat[14];\n    return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */ function getScaling(out, mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n    out[0] = Math.hypot(m11, m12, m13);\n    out[1] = Math.hypot(m21, m22, m23);\n    out[2] = Math.hypot(m31, m32, m33);\n    return out;\n}\nfunction getMaxScaleOnAxis(mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n    const x = m11 * m11 + m12 * m12 + m13 * m13;\n    const y = m21 * m21 + m22 * m22 + m23 * m23;\n    const z = m31 * m31 + m32 * m32 + m33 * m33;\n    return Math.sqrt(Math.max(x, y, z));\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */ const getRotation = function() {\n    const temp = [\n        1,\n        1,\n        1\n    ];\n    return function(out, mat) {\n        let scaling = temp;\n        getScaling(scaling, mat);\n        let is1 = 1 / scaling[0];\n        let is2 = 1 / scaling[1];\n        let is3 = 1 / scaling[2];\n        let sm11 = mat[0] * is1;\n        let sm12 = mat[1] * is2;\n        let sm13 = mat[2] * is3;\n        let sm21 = mat[4] * is1;\n        let sm22 = mat[5] * is2;\n        let sm23 = mat[6] * is3;\n        let sm31 = mat[8] * is1;\n        let sm32 = mat[9] * is2;\n        let sm33 = mat[10] * is3;\n        let trace = sm11 + sm22 + sm33;\n        let S = 0;\n        if (trace > 0) {\n            S = Math.sqrt(trace + 1.0) * 2;\n            out[3] = 0.25 * S;\n            out[0] = (sm23 - sm32) / S;\n            out[1] = (sm31 - sm13) / S;\n            out[2] = (sm12 - sm21) / S;\n        } else if (sm11 > sm22 && sm11 > sm33) {\n            S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n            out[3] = (sm23 - sm32) / S;\n            out[0] = 0.25 * S;\n            out[1] = (sm12 + sm21) / S;\n            out[2] = (sm31 + sm13) / S;\n        } else if (sm22 > sm33) {\n            S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n            out[3] = (sm31 - sm13) / S;\n            out[0] = (sm12 + sm21) / S;\n            out[1] = 0.25 * S;\n            out[2] = (sm23 + sm32) / S;\n        } else {\n            S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n            out[3] = (sm12 - sm21) / S;\n            out[0] = (sm31 + sm13) / S;\n            out[1] = (sm23 + sm32) / S;\n            out[2] = 0.25 * S;\n        }\n        return out;\n    };\n}();\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Decompose a mat4 to TRS properties.\n *\n * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} srcMat Matrix element, to be decomposed to TRS properties.\n * @param {quat4} dstRotation Rotation element, to be overwritten.\n * @param {vec3} dstTranslation Translation element, to be overwritten.\n * @param {vec3} dstScale Scale element, to be overwritten\n */ function decompose(srcMat, dstRotation, dstTranslation, dstScale) {\n    let sx = _Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.length([\n        srcMat[0],\n        srcMat[1],\n        srcMat[2]\n    ]);\n    const sy = _Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.length([\n        srcMat[4],\n        srcMat[5],\n        srcMat[6]\n    ]);\n    const sz = _Vec3Func_js__WEBPACK_IMPORTED_MODULE_0__.length([\n        srcMat[8],\n        srcMat[9],\n        srcMat[10]\n    ]);\n    // if determine is negative, we need to invert one scale\n    const det = determinant(srcMat);\n    if (det < 0) sx = -sx;\n    dstTranslation[0] = srcMat[12];\n    dstTranslation[1] = srcMat[13];\n    dstTranslation[2] = srcMat[14];\n    // scale the rotation part\n    const _m1 = srcMat.slice();\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1[0] *= invSX;\n    _m1[1] *= invSX;\n    _m1[2] *= invSX;\n    _m1[4] *= invSY;\n    _m1[5] *= invSY;\n    _m1[6] *= invSY;\n    _m1[8] *= invSZ;\n    _m1[9] *= invSZ;\n    _m1[10] *= invSZ;\n    getRotation(dstRotation, _m1);\n    dstScale[0] = sx;\n    dstScale[1] = sy;\n    dstScale[2] = sz;\n}\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Compose TRS properties to a mat4.\n *\n * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} dstMat Matrix element, to be modified and returned.\n * @param {quat4} srcRotation Rotation element of matrix.\n * @param {vec3} srcTranslation Translation element of matrix.\n * @param {vec3} srcScale Scale element of matrix.\n * @returns {mat4} dstMat, overwritten to mat4 equivalent of given TRS properties.\n */ function compose(dstMat, srcRotation, srcTranslation, srcScale) {\n    const te = dstMat;\n    const x = srcRotation[0], y = srcRotation[1], z = srcRotation[2], w = srcRotation[3];\n    const x2 = x + x, y2 = y + y, z2 = z + z;\n    const xx = x * x2, xy = x * y2, xz = x * z2;\n    const yy = y * y2, yz = y * z2, zz = z * z2;\n    const wx = w * x2, wy = w * y2, wz = w * z2;\n    const sx = srcScale[0], sy = srcScale[1], sz = srcScale[2];\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = srcTranslation[0];\n    te[13] = srcTranslation[1];\n    te[14] = srcTranslation[2];\n    te[15] = 1;\n    return te;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */ function fromRotationTranslationScale(out, q, v, s) {\n    // Quaternion math\n    let x = q[0], y = q[1], z = q[2], w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = s[0];\n    let sy = s[1];\n    let sz = s[2];\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n    return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */ function fromQuat(out, q) {\n    let x = q[0], y = q[1], z = q[2], w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */ function perspective(out, fovy, aspect, near, far) {\n    let f = 1.0 / Math.tan(fovy / 2);\n    let nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 2 * far * near * nf;\n    out[15] = 0;\n    return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */ function ortho(out, left, right, bottom, top, near, far) {\n    let lr = 1 / (left - right);\n    let bt = 1 / (bottom - top);\n    let nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} target Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */ function targetTo(out, eye, target, up) {\n    let eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];\n    let z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];\n    let len = z0 * z0 + z1 * z1 + z2 * z2;\n    if (len === 0) {\n        // eye and target are in the same position\n        z2 = 1;\n    } else {\n        len = 1 / Math.sqrt(len);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n    }\n    let x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;\n    len = x0 * x0 + x1 * x1 + x2 * x2;\n    if (len === 0) {\n        // up and z are parallel\n        if (upz) {\n            upx += 1e-6;\n        } else if (upy) {\n            upz += 1e-6;\n        } else {\n            upy += 1e-6;\n        }\n        x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;\n        len = x0 * x0 + x1 * x1 + x2 * x2;\n    }\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n    out[0] = x0;\n    out[1] = x1;\n    out[2] = x2;\n    out[3] = 0;\n    out[4] = z1 * x2 - z2 * x1;\n    out[5] = z2 * x0 - z0 * x2;\n    out[6] = z0 * x1 - z1 * x0;\n    out[7] = 0;\n    out[8] = z0;\n    out[9] = z1;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = eyex;\n    out[13] = eyey;\n    out[14] = eyez;\n    out[15] = 1;\n    return out;\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */ function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */ function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */ function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL01hdDRGdW5jLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFFdEMsTUFBTUMsVUFBVTtBQUVoQjs7Ozs7O0NBTUMsR0FDTSxTQUFTQyxLQUFLQyxHQUFHLEVBQUVDLENBQUM7SUFDdkJELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxHQUFHLEdBQUdDLENBQUMsQ0FBQyxHQUFHO0lBQ2ZELEdBQUcsQ0FBQyxHQUFHLEdBQUdDLENBQUMsQ0FBQyxHQUFHO0lBQ2ZELEdBQUcsQ0FBQyxHQUFHLEdBQUdDLENBQUMsQ0FBQyxHQUFHO0lBQ2ZELEdBQUcsQ0FBQyxHQUFHLEdBQUdDLENBQUMsQ0FBQyxHQUFHO0lBQ2ZELEdBQUcsQ0FBQyxHQUFHLEdBQUdDLENBQUMsQ0FBQyxHQUFHO0lBQ2ZELEdBQUcsQ0FBQyxHQUFHLEdBQUdDLENBQUMsQ0FBQyxHQUFHO0lBQ2YsT0FBT0Q7QUFDWDtBQUVBOzs7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QUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkIsT0FBT3JEO0FBQ1g7QUFFQTs7Ozs7OztDQU9DLEdBQ00sU0FBUzRLLFNBQVM1SyxHQUFHLEVBQUVDLENBQUMsRUFBRW9ELENBQUM7SUFDOUJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0QsQ0FBQyxDQUFDLEVBQUU7SUFDcEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0QsQ0FBQyxDQUFDLEdBQUc7SUFDdkIsT0FBT3JEO0FBQ1g7QUFFQTs7Ozs7OztDQU9DLEdBQ00sU0FBUzZLLGVBQWU3SyxHQUFHLEVBQUVDLENBQUMsRUFBRW9ELENBQUM7SUFDcENyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHb0Q7SUFDaEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0Q7SUFDbEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0Q7SUFDbEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0Q7SUFDbEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0Q7SUFDbEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0Q7SUFDbEJyRCxHQUFHLENBQUMsR0FBRyxHQUFHQyxDQUFDLENBQUMsR0FBRyxHQUFHb0Q7SUFDbEIsT0FBT3JEO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvbWF0aC9mdW5jdGlvbnMvTWF0NEZ1bmMuanM/OGUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB2ZWMzIGZyb20gJy4vVmVjM0Z1bmMuanMnO1xuXG5jb25zdCBFUFNJTE9OID0gMC4wMDAwMDE7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMDM7XG4gICAgb3V0WzRdID0gbTEwO1xuICAgIG91dFs1XSA9IG0xMTtcbiAgICBvdXRbNl0gPSBtMTI7XG4gICAgb3V0WzddID0gbTEzO1xuICAgIG91dFs4XSA9IG0yMDtcbiAgICBvdXRbOV0gPSBtMjE7XG4gICAgb3V0WzEwXSA9IG0yMjtcbiAgICBvdXRbMTFdID0gbTIzO1xuICAgIG91dFsxMl0gPSBtMzA7XG4gICAgb3V0WzEzXSA9IG0zMTtcbiAgICBvdXRbMTRdID0gbTMyO1xuICAgIG91dFsxNV0gPSBtMzM7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICBsZXQgYTAxID0gYVsxXSxcbiAgICAgICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgICAgICBhMDMgPSBhWzNdO1xuICAgICAgICBsZXQgYTEyID0gYVs2XSxcbiAgICAgICAgICAgIGExMyA9IGFbN107XG4gICAgICAgIGxldCBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gICAgbGV0IGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM107XG4gICAgbGV0IGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG4gICAgbGV0IGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcbiAgICBsZXQgYTMwID0gYVsxMl0sXG4gICAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgICBhMzIgPSBhWzE0XSxcbiAgICAgICAgYTMzID0gYVsxNV07XG5cbiAgICBsZXQgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICAgIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gICAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgICBsZXQgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICAgIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gICAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgICBsZXQgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICAgIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gICAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgICBsZXQgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICAgIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gICAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgICBsZXQgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICBsZXQgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICBsZXQgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuICAgIGxldCBhMzAgPSBhWzEyXSxcbiAgICAgICAgYTMxID0gYVsxM10sXG4gICAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgICBhMzMgPSBhWzE1XTtcblxuICAgIGxldCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gICAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgICBsZXQgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICAgIGxldCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gICAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgICBsZXQgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICAgIGxldCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gICAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgICBsZXQgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICAgIGxldCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gICAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgICBsZXQgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBsZXQgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICBsZXQgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICBsZXQgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuICAgIGxldCBhMzAgPSBhWzEyXSxcbiAgICAgICAgYTMxID0gYVsxM10sXG4gICAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgICBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIGxldCBiMCA9IGJbMF0sXG4gICAgICAgIGIxID0gYlsxXSxcbiAgICAgICAgYjIgPSBiWzJdLFxuICAgICAgICBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgb3V0WzFdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gICAgb3V0WzJdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG5cbiAgICBiMCA9IGJbNF07XG4gICAgYjEgPSBiWzVdO1xuICAgIGIyID0gYls2XTtcbiAgICBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgb3V0WzVdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gICAgb3V0WzZdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG5cbiAgICBiMCA9IGJbOF07XG4gICAgYjEgPSBiWzldO1xuICAgIGIyID0gYlsxMF07XG4gICAgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgICBvdXRbOV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgICBvdXRbMTBdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuXG4gICAgYjAgPSBiWzEyXTtcbiAgICBiMSA9IGJbMTNdO1xuICAgIGIyID0gYlsxNF07XG4gICAgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgb3V0WzEzXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICAgIG91dFsxNF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIGxldCB4ID0gdlswXSxcbiAgICAgICAgeSA9IHZbMV0sXG4gICAgICAgIHogPSB2WzJdO1xuICAgIGxldCBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gICAgbGV0IGExMCwgYTExLCBhMTIsIGExMztcbiAgICBsZXQgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdO1xuICAgICAgICBhMDEgPSBhWzFdO1xuICAgICAgICBhMDIgPSBhWzJdO1xuICAgICAgICBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdO1xuICAgICAgICBhMTEgPSBhWzVdO1xuICAgICAgICBhMTIgPSBhWzZdO1xuICAgICAgICBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdO1xuICAgICAgICBhMjEgPSBhWzldO1xuICAgICAgICBhMjIgPSBhWzEwXTtcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwO1xuICAgICAgICBvdXRbMV0gPSBhMDE7XG4gICAgICAgIG91dFsyXSA9IGEwMjtcbiAgICAgICAgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7XG4gICAgICAgIG91dFs1XSA9IGExMTtcbiAgICAgICAgb3V0WzZdID0gYTEyO1xuICAgICAgICBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDtcbiAgICAgICAgb3V0WzldID0gYTIxO1xuICAgICAgICBvdXRbMTBdID0gYTIyO1xuICAgICAgICBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgICBsZXQgeCA9IHZbMF0sXG4gICAgICAgIHkgPSB2WzFdLFxuICAgICAgICB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBnaXZlbiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICBsZXQgeCA9IGF4aXNbMF0sXG4gICAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgICB6ID0gYXhpc1syXTtcbiAgICBsZXQgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgICBsZXQgcywgYywgdDtcbiAgICBsZXQgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICAgIGxldCBhMTAsIGExMSwgYTEyLCBhMTM7XG4gICAgbGV0IGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgICBsZXQgYjAwLCBiMDEsIGIwMjtcbiAgICBsZXQgYjEwLCBiMTEsIGIxMjtcbiAgICBsZXQgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7XG4gICAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gICAgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7XG4gICAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgICBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogcztcbiAgICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgICBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkge1xuICAgICAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gICAgb3V0WzBdID0gbWF0WzEyXTtcbiAgICBvdXRbMV0gPSBtYXRbMTNdO1xuICAgIG91dFsyXSA9IG1hdFsxNF07XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcbiAqICB3aXRoIGEgbm9ybWFsaXplZCBRdWF0ZXJuaW9uIHBhcmFtdGVyLCB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmVcbiAqICB0aGUgc2FtZSBhcyB0aGUgc2NhbGluZyB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudFxuICogQHBhcmFtICB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICAgIGxldCBtMTEgPSBtYXRbMF07XG4gICAgbGV0IG0xMiA9IG1hdFsxXTtcbiAgICBsZXQgbTEzID0gbWF0WzJdO1xuICAgIGxldCBtMjEgPSBtYXRbNF07XG4gICAgbGV0IG0yMiA9IG1hdFs1XTtcbiAgICBsZXQgbTIzID0gbWF0WzZdO1xuICAgIGxldCBtMzEgPSBtYXRbOF07XG4gICAgbGV0IG0zMiA9IG1hdFs5XTtcbiAgICBsZXQgbTMzID0gbWF0WzEwXTtcblxuICAgIG91dFswXSA9IE1hdGguaHlwb3QobTExLCBtMTIsIG0xMyk7XG4gICAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgICBvdXRbMl0gPSBNYXRoLmh5cG90KG0zMSwgbTMyLCBtMzMpO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heFNjYWxlT25BeGlzKG1hdCkge1xuICAgIGxldCBtMTEgPSBtYXRbMF07XG4gICAgbGV0IG0xMiA9IG1hdFsxXTtcbiAgICBsZXQgbTEzID0gbWF0WzJdO1xuICAgIGxldCBtMjEgPSBtYXRbNF07XG4gICAgbGV0IG0yMiA9IG1hdFs1XTtcbiAgICBsZXQgbTIzID0gbWF0WzZdO1xuICAgIGxldCBtMzEgPSBtYXRbOF07XG4gICAgbGV0IG0zMiA9IG1hdFs5XTtcbiAgICBsZXQgbTMzID0gbWF0WzEwXTtcblxuICAgIGNvbnN0IHggPSBtMTEgKiBtMTEgKyBtMTIgKiBtMTIgKyBtMTMgKiBtMTM7XG4gICAgY29uc3QgeSA9IG0yMSAqIG0yMSArIG0yMiAqIG0yMiArIG0yMyAqIG0yMztcbiAgICBjb25zdCB6ID0gbTMxICogbTMxICsgbTMyICogbTMyICsgbTMzICogbTMzO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heCh4LCB5LCB6KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxuICovXG5leHBvcnQgY29uc3QgZ2V0Um90YXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHRlbXAgPSBbMSwgMSwgMV07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG91dCwgbWF0KSB7XG4gICAgICAgIGxldCBzY2FsaW5nID0gdGVtcDtcbiAgICAgICAgZ2V0U2NhbGluZyhzY2FsaW5nLCBtYXQpO1xuXG4gICAgICAgIGxldCBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgICAgICAgbGV0IGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICAgICAgICBsZXQgaXMzID0gMSAvIHNjYWxpbmdbMl07XG5cbiAgICAgICAgbGV0IHNtMTEgPSBtYXRbMF0gKiBpczE7XG4gICAgICAgIGxldCBzbTEyID0gbWF0WzFdICogaXMyO1xuICAgICAgICBsZXQgc20xMyA9IG1hdFsyXSAqIGlzMztcbiAgICAgICAgbGV0IHNtMjEgPSBtYXRbNF0gKiBpczE7XG4gICAgICAgIGxldCBzbTIyID0gbWF0WzVdICogaXMyO1xuICAgICAgICBsZXQgc20yMyA9IG1hdFs2XSAqIGlzMztcbiAgICAgICAgbGV0IHNtMzEgPSBtYXRbOF0gKiBpczE7XG4gICAgICAgIGxldCBzbTMyID0gbWF0WzldICogaXMyO1xuICAgICAgICBsZXQgc20zMyA9IG1hdFsxMF0gKiBpczM7XG5cbiAgICAgICAgbGV0IHRyYWNlID0gc20xMSArIHNtMjIgKyBzbTMzO1xuICAgICAgICBsZXQgUyA9IDA7XG5cbiAgICAgICAgaWYgKHRyYWNlID4gMCkge1xuICAgICAgICAgICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgICAgICAgICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgICAgICAgICBvdXRbMF0gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICAgICAgICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgICAgICAgICAgb3V0WzJdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gICAgICAgIH0gZWxzZSBpZiAoc20xMSA+IHNtMjIgJiYgc20xMSA+IHNtMzMpIHtcbiAgICAgICAgICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20xMSAtIHNtMjIgLSBzbTMzKSAqIDI7XG4gICAgICAgICAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICAgICAgICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgICAgICAgICAgb3V0WzFdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgICAgICAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICAgICAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgICAgICAgICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTIyIC0gc20xMSAtIHNtMzMpICogMjtcbiAgICAgICAgICAgIG91dFszXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgICAgICAgICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgICAgICAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICAgICAgICAgIG91dFsyXSA9IChzbTIzICsgc20zMikgLyBTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICAgICAgICAgIG91dFszXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICAgICAgICAgICAgb3V0WzBdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gICAgICAgICAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICAgICAgICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBGcm9tIGdsVEYtVHJhbnNmb3JtXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZG9ubWNjdXJkeS9nbFRGLVRyYW5zZm9ybS9ibG9iL21haW4vcGFja2FnZXMvY29yZS9zcmMvdXRpbHMvbWF0aC11dGlscy50c1xuICpcbiAqIERlY29tcG9zZSBhIG1hdDQgdG8gVFJTIHByb3BlcnRpZXMuXG4gKlxuICogRXF1aXZhbGVudCB0byB0aGUgTWF0cml4NCBkZWNvbXBvc2UoKSBtZXRob2QgaW4gdGhyZWUuanMsIGFuZCBpbnRlbnRpb25hbGx5IG5vdCB1c2luZyB0aGVcbiAqIGdsLW1hdHJpeCB2ZXJzaW9uLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9pc3N1ZXMvNDA4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBzcmNNYXQgTWF0cml4IGVsZW1lbnQsIHRvIGJlIGRlY29tcG9zZWQgdG8gVFJTIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge3F1YXQ0fSBkc3RSb3RhdGlvbiBSb3RhdGlvbiBlbGVtZW50LCB0byBiZSBvdmVyd3JpdHRlbi5cbiAqIEBwYXJhbSB7dmVjM30gZHN0VHJhbnNsYXRpb24gVHJhbnNsYXRpb24gZWxlbWVudCwgdG8gYmUgb3ZlcndyaXR0ZW4uXG4gKiBAcGFyYW0ge3ZlYzN9IGRzdFNjYWxlIFNjYWxlIGVsZW1lbnQsIHRvIGJlIG92ZXJ3cml0dGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvbXBvc2Uoc3JjTWF0LCBkc3RSb3RhdGlvbiwgZHN0VHJhbnNsYXRpb24sIGRzdFNjYWxlKSB7XG4gICAgbGV0IHN4ID0gdmVjMy5sZW5ndGgoW3NyY01hdFswXSwgc3JjTWF0WzFdLCBzcmNNYXRbMl1dKTtcbiAgICBjb25zdCBzeSA9IHZlYzMubGVuZ3RoKFtzcmNNYXRbNF0sIHNyY01hdFs1XSwgc3JjTWF0WzZdXSk7XG4gICAgY29uc3Qgc3ogPSB2ZWMzLmxlbmd0aChbc3JjTWF0WzhdLCBzcmNNYXRbOV0sIHNyY01hdFsxMF1dKTtcblxuICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgY29uc3QgZGV0ID0gZGV0ZXJtaW5hbnQoc3JjTWF0KTtcbiAgICBpZiAoZGV0IDwgMCkgc3ggPSAtc3g7XG5cbiAgICBkc3RUcmFuc2xhdGlvblswXSA9IHNyY01hdFsxMl07XG4gICAgZHN0VHJhbnNsYXRpb25bMV0gPSBzcmNNYXRbMTNdO1xuICAgIGRzdFRyYW5zbGF0aW9uWzJdID0gc3JjTWF0WzE0XTtcblxuICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG4gICAgY29uc3QgX20xID0gc3JjTWF0LnNsaWNlKCk7XG5cbiAgICBjb25zdCBpbnZTWCA9IDEgLyBzeDtcbiAgICBjb25zdCBpbnZTWSA9IDEgLyBzeTtcbiAgICBjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuICAgIF9tMVswXSAqPSBpbnZTWDtcbiAgICBfbTFbMV0gKj0gaW52U1g7XG4gICAgX20xWzJdICo9IGludlNYO1xuXG4gICAgX20xWzRdICo9IGludlNZO1xuICAgIF9tMVs1XSAqPSBpbnZTWTtcbiAgICBfbTFbNl0gKj0gaW52U1k7XG5cbiAgICBfbTFbOF0gKj0gaW52U1o7XG4gICAgX20xWzldICo9IGludlNaO1xuICAgIF9tMVsxMF0gKj0gaW52U1o7XG5cbiAgICBnZXRSb3RhdGlvbihkc3RSb3RhdGlvbiwgX20xKTtcblxuICAgIGRzdFNjYWxlWzBdID0gc3g7XG4gICAgZHN0U2NhbGVbMV0gPSBzeTtcbiAgICBkc3RTY2FsZVsyXSA9IHN6O1xufVxuXG4vKipcbiAqIEZyb20gZ2xURi1UcmFuc2Zvcm1cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kb25tY2N1cmR5L2dsVEYtVHJhbnNmb3JtL2Jsb2IvbWFpbi9wYWNrYWdlcy9jb3JlL3NyYy91dGlscy9tYXRoLXV0aWxzLnRzXG4gKlxuICogQ29tcG9zZSBUUlMgcHJvcGVydGllcyB0byBhIG1hdDQuXG4gKlxuICogRXF1aXZhbGVudCB0byB0aGUgTWF0cml4NCBjb21wb3NlKCkgbWV0aG9kIGluIHRocmVlLmpzLCBhbmQgaW50ZW50aW9uYWxseSBub3QgdXNpbmcgdGhlXG4gKiBnbC1tYXRyaXggdmVyc2lvbi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvaXNzdWVzLzQwOFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gZHN0TWF0IE1hdHJpeCBlbGVtZW50LCB0byBiZSBtb2RpZmllZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge3F1YXQ0fSBzcmNSb3RhdGlvbiBSb3RhdGlvbiBlbGVtZW50IG9mIG1hdHJpeC5cbiAqIEBwYXJhbSB7dmVjM30gc3JjVHJhbnNsYXRpb24gVHJhbnNsYXRpb24gZWxlbWVudCBvZiBtYXRyaXguXG4gKiBAcGFyYW0ge3ZlYzN9IHNyY1NjYWxlIFNjYWxlIGVsZW1lbnQgb2YgbWF0cml4LlxuICogQHJldHVybnMge21hdDR9IGRzdE1hdCwgb3ZlcndyaXR0ZW4gdG8gbWF0NCBlcXVpdmFsZW50IG9mIGdpdmVuIFRSUyBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZShkc3RNYXQsIHNyY1JvdGF0aW9uLCBzcmNUcmFuc2xhdGlvbiwgc3JjU2NhbGUpIHtcbiAgICBjb25zdCB0ZSA9IGRzdE1hdDtcblxuICAgIGNvbnN0IHggPSBzcmNSb3RhdGlvblswXSxcbiAgICAgICAgeSA9IHNyY1JvdGF0aW9uWzFdLFxuICAgICAgICB6ID0gc3JjUm90YXRpb25bMl0sXG4gICAgICAgIHcgPSBzcmNSb3RhdGlvblszXTtcbiAgICBjb25zdCB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6O1xuICAgIGNvbnN0IHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejI7XG4gICAgY29uc3QgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MjtcbiAgICBjb25zdCB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgY29uc3Qgc3ggPSBzcmNTY2FsZVswXSxcbiAgICAgICAgc3kgPSBzcmNTY2FsZVsxXSxcbiAgICAgICAgc3ogPSBzcmNTY2FsZVsyXTtcblxuICAgIHRlWzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gICAgdGVbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgICB0ZVsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICAgIHRlWzNdID0gMDtcblxuICAgIHRlWzRdID0gKHh5IC0gd3opICogc3k7XG4gICAgdGVbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgICB0ZVs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICAgIHRlWzddID0gMDtcblxuICAgIHRlWzhdID0gKHh6ICsgd3kpICogc3o7XG4gICAgdGVbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgICB0ZVsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgICB0ZVsxMV0gPSAwO1xuXG4gICAgdGVbMTJdID0gc3JjVHJhbnNsYXRpb25bMF07XG4gICAgdGVbMTNdID0gc3JjVHJhbnNsYXRpb25bMV07XG4gICAgdGVbMTRdID0gc3JjVHJhbnNsYXRpb25bMl07XG4gICAgdGVbMTVdID0gMTtcblxuICAgIHJldHVybiB0ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZShvdXQsIHEsIHYsIHMpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICBsZXQgeCA9IHFbMF0sXG4gICAgICAgIHkgPSBxWzFdLFxuICAgICAgICB6ID0gcVsyXSxcbiAgICAgICAgdyA9IHFbM107XG4gICAgbGV0IHgyID0geCArIHg7XG4gICAgbGV0IHkyID0geSArIHk7XG4gICAgbGV0IHoyID0geiArIHo7XG5cbiAgICBsZXQgeHggPSB4ICogeDI7XG4gICAgbGV0IHh5ID0geCAqIHkyO1xuICAgIGxldCB4eiA9IHggKiB6MjtcbiAgICBsZXQgeXkgPSB5ICogeTI7XG4gICAgbGV0IHl6ID0geSAqIHoyO1xuICAgIGxldCB6eiA9IHogKiB6MjtcbiAgICBsZXQgd3ggPSB3ICogeDI7XG4gICAgbGV0IHd5ID0gdyAqIHkyO1xuICAgIGxldCB3eiA9IHcgKiB6MjtcbiAgICBsZXQgc3ggPSBzWzBdO1xuICAgIGxldCBzeSA9IHNbMV07XG4gICAgbGV0IHN6ID0gc1syXTtcblxuICAgIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICAgIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICAgIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gICAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gICAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgICBsZXQgeCA9IHFbMF0sXG4gICAgICAgIHkgPSBxWzFdLFxuICAgICAgICB6ID0gcVsyXSxcbiAgICAgICAgdyA9IHFbM107XG4gICAgbGV0IHgyID0geCArIHg7XG4gICAgbGV0IHkyID0geSArIHk7XG4gICAgbGV0IHoyID0geiArIHo7XG5cbiAgICBsZXQgeHggPSB4ICogeDI7XG4gICAgbGV0IHl4ID0geSAqIHgyO1xuICAgIGxldCB5eSA9IHkgKiB5MjtcbiAgICBsZXQgenggPSB6ICogeDI7XG4gICAgbGV0IHp5ID0geiAqIHkyO1xuICAgIGxldCB6eiA9IHogKiB6MjtcbiAgICBsZXQgd3ggPSB3ICogeDI7XG4gICAgbGV0IHd5ID0gdyAqIHkyO1xuICAgIGxldCB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgbGV0IGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMik7XG4gICAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDIgKiBmYXIgKiBuZWFyICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIGxldCBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTtcbiAgICBsZXQgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gICAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSB0YXJnZXQgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gICAgbGV0IGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl07XG5cbiAgICBsZXQgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcblxuICAgIGxldCBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAvLyBleWUgYW5kIHRhcmdldCBhcmUgaW4gdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgejIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgejAgKj0gbGVuO1xuICAgICAgICB6MSAqPSBsZW47XG4gICAgICAgIHoyICo9IGxlbjtcbiAgICB9XG5cbiAgICBsZXQgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcblxuICAgIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuICAgICAgICBpZiAodXB6KSB7XG4gICAgICAgICAgICB1cHggKz0gMWUtNjtcbiAgICAgICAgfSBlbHNlIGlmICh1cHkpIHtcbiAgICAgICAgICAgIHVweiArPSAxZS02O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXB5ICs9IDFlLTY7XG4gICAgICAgIH1cbiAgICAgICAgKHgwID0gdXB5ICogejIgLSB1cHogKiB6MSksICh4MSA9IHVweiAqIHowIC0gdXB4ICogejIpLCAoeDIgPSB1cHggKiB6MSAtIHVweSAqIHowKTtcblxuICAgICAgICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG4gICAgfVxuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geDE7XG4gICAgb3V0WzJdID0geDI7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICBvdXRbNl0gPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHowO1xuICAgIG91dFs5XSA9IHoxO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gZXlleDtcbiAgICBvdXRbMTNdID0gZXlleTtcbiAgICBvdXRbMTRdID0gZXllejtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gICAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdIC0gYlsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdIC0gYlsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIG91dFs0XSA9IGFbNF0gKiBiO1xuICAgIG91dFs1XSA9IGFbNV0gKiBiO1xuICAgIG91dFs2XSA9IGFbNl0gKiBiO1xuICAgIG91dFs3XSA9IGFbN10gKiBiO1xuICAgIG91dFs4XSA9IGFbOF0gKiBiO1xuICAgIG91dFs5XSA9IGFbOV0gKiBiO1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gICAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICAgIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gICAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59XG4iXSwibmFtZXMiOlsidmVjMyIsIkVQU0lMT04iLCJjb3B5Iiwib3V0IiwiYSIsInNldCIsIm0wMCIsIm0wMSIsIm0wMiIsIm0wMyIsIm0xMCIsIm0xMSIsIm0xMiIsIm0xMyIsIm0yMCIsIm0yMSIsIm0yMiIsIm0yMyIsIm0zMCIsIm0zMSIsIm0zMiIsIm0zMyIsImlkZW50aXR5IiwidHJhbnNwb3NlIiwiYTAxIiwiYTAyIiwiYTAzIiwiYTEyIiwiYTEzIiwiYTIzIiwiaW52ZXJ0IiwiYTAwIiwiYTEwIiwiYTExIiwiYTIwIiwiYTIxIiwiYTIyIiwiYTMwIiwiYTMxIiwiYTMyIiwiYTMzIiwiYjAwIiwiYjAxIiwiYjAyIiwiYjAzIiwiYjA0IiwiYjA1IiwiYjA2IiwiYjA3IiwiYjA4IiwiYjA5IiwiYjEwIiwiYjExIiwiZGV0IiwiZGV0ZXJtaW5hbnQiLCJtdWx0aXBseSIsImIiLCJiMCIsImIxIiwiYjIiLCJiMyIsInRyYW5zbGF0ZSIsInYiLCJ4IiwieSIsInoiLCJzY2FsZSIsInJvdGF0ZSIsInJhZCIsImF4aXMiLCJsZW4iLCJNYXRoIiwiaHlwb3QiLCJzIiwiYyIsInQiLCJiMTIiLCJiMjAiLCJiMjEiLCJiMjIiLCJhYnMiLCJzaW4iLCJjb3MiLCJnZXRUcmFuc2xhdGlvbiIsIm1hdCIsImdldFNjYWxpbmciLCJnZXRNYXhTY2FsZU9uQXhpcyIsInNxcnQiLCJtYXgiLCJnZXRSb3RhdGlvbiIsInRlbXAiLCJzY2FsaW5nIiwiaXMxIiwiaXMyIiwiaXMzIiwic20xMSIsInNtMTIiLCJzbTEzIiwic20yMSIsInNtMjIiLCJzbTIzIiwic20zMSIsInNtMzIiLCJzbTMzIiwidHJhY2UiLCJTIiwiZGVjb21wb3NlIiwic3JjTWF0IiwiZHN0Um90YXRpb24iLCJkc3RUcmFuc2xhdGlvbiIsImRzdFNjYWxlIiwic3giLCJsZW5ndGgiLCJzeSIsInN6IiwiX20xIiwic2xpY2UiLCJpbnZTWCIsImludlNZIiwiaW52U1oiLCJjb21wb3NlIiwiZHN0TWF0Iiwic3JjUm90YXRpb24iLCJzcmNUcmFuc2xhdGlvbiIsInNyY1NjYWxlIiwidGUiLCJ3IiwieDIiLCJ5MiIsInoyIiwieHgiLCJ4eSIsInh6IiwieXkiLCJ5eiIsInp6Iiwid3giLCJ3eSIsInd6IiwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSIsInEiLCJmcm9tUXVhdCIsInl4IiwiengiLCJ6eSIsInBlcnNwZWN0aXZlIiwiZm92eSIsImFzcGVjdCIsIm5lYXIiLCJmYXIiLCJmIiwidGFuIiwibmYiLCJvcnRobyIsImxlZnQiLCJyaWdodCIsImJvdHRvbSIsInRvcCIsImxyIiwiYnQiLCJ0YXJnZXRUbyIsImV5ZSIsInRhcmdldCIsInVwIiwiZXlleCIsImV5ZXkiLCJleWV6IiwidXB4IiwidXB5IiwidXB6IiwiejAiLCJ6MSIsIngwIiwieDEiLCJhZGQiLCJzdWJ0cmFjdCIsIm11bHRpcGx5U2NhbGFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/functions/Mat4Func.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/functions/QuatFunc.js":
/*!*********************************************************!*\
  !*** ./node_modules/ogl/src/math/functions/QuatFunc.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   conjugate: function() { return /* binding */ conjugate; },\n/* harmony export */   copy: function() { return /* binding */ copy; },\n/* harmony export */   dot: function() { return /* binding */ dot; },\n/* harmony export */   fromEuler: function() { return /* binding */ fromEuler; },\n/* harmony export */   fromMat3: function() { return /* binding */ fromMat3; },\n/* harmony export */   identity: function() { return /* binding */ identity; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   length: function() { return /* binding */ length; },\n/* harmony export */   lerp: function() { return /* binding */ lerp; },\n/* harmony export */   multiply: function() { return /* binding */ multiply; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   rotateX: function() { return /* binding */ rotateX; },\n/* harmony export */   rotateY: function() { return /* binding */ rotateY; },\n/* harmony export */   rotateZ: function() { return /* binding */ rotateZ; },\n/* harmony export */   scale: function() { return /* binding */ scale; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   setAxisAngle: function() { return /* binding */ setAxisAngle; },\n/* harmony export */   slerp: function() { return /* binding */ slerp; }\n/* harmony export */ });\n/* harmony import */ var _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec4Func.js */ \"(app-pages-browser)/./node_modules/ogl/src/math/functions/Vec4Func.js\");\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */ function identity(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/ function setAxisAngle(out, axis, rad) {\n    rad = rad * 0.5;\n    let s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n}\n/**\n * Multiplies two quats\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */ function multiply(out, a, b) {\n    let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n    let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */ function rotateX(out, a, rad) {\n    rad *= 0.5;\n    let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n    let bx = Math.sin(rad), bw = Math.cos(rad);\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */ function rotateY(out, a, rad) {\n    rad *= 0.5;\n    let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n    let by = Math.sin(rad), bw = Math.cos(rad);\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */ function rotateZ(out, a, rad) {\n    rad *= 0.5;\n    let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n    let bz = Math.sin(rad), bw = Math.cos(rad);\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */ function slerp(out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n    let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n    let omega, cosom, sinom, scale0, scale1;\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    // calculate coefficients\n    if (1.0 - cosom > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */ function invert(out, a) {\n    let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    let invDot = dot ? 1.0 / dot : 0;\n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n    out[0] = -a0 * invDot;\n    out[1] = -a1 * invDot;\n    out[2] = -a2 * invDot;\n    out[3] = a3 * invDot;\n    return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */ function conjugate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */ function fromMat3(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n    if (fTrace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0); // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot; // 1/(4w)\n        out[0] = (m[5] - m[7]) * fRoot;\n        out[1] = (m[6] - m[2]) * fRoot;\n        out[2] = (m[1] - m[3]) * fRoot;\n    } else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[4] > m[0]) i = 1;\n        if (m[8] > m[i * 3 + i]) i = 2;\n        let j = (i + 1) % 3;\n        let k = (i + 2) % 3;\n        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n    return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} euler Angles to rotate around each axis in degrees.\n * @param {String} order detailing order of operations. Default 'XYZ'.\n * @returns {quat} out\n * @function\n */ function fromEuler(out, euler) {\n    let order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"YXZ\";\n    let sx = Math.sin(euler[0] * 0.5);\n    let cx = Math.cos(euler[0] * 0.5);\n    let sy = Math.sin(euler[1] * 0.5);\n    let cy = Math.cos(euler[1] * 0.5);\n    let sz = Math.sin(euler[2] * 0.5);\n    let cz = Math.cos(euler[2] * 0.5);\n    if (order === \"XYZ\") {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === \"YXZ\") {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === \"ZXY\") {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === \"ZYX\") {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === \"YZX\") {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === \"XZY\") {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    }\n    return out;\n}\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */ const copy = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */ const set = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */ const add = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.add;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */ const scale = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */ const dot = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */ const lerp = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */ const length = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.length;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */ const normalize = _Vec4Func_js__WEBPACK_IMPORTED_MODULE_0__.normalize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL1F1YXRGdW5jLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBRXRDOzs7OztDQUtDLEdBQ00sU0FBU0MsU0FBU0MsR0FBRztJQUN4QkEsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNUQSxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNULE9BQU9BO0FBQ1g7QUFFQTs7Ozs7Ozs7RUFRRSxHQUNLLFNBQVNDLGFBQWFELEdBQUcsRUFBRUUsSUFBSSxFQUFFQyxHQUFHO0lBQ3ZDQSxNQUFNQSxNQUFNO0lBQ1osSUFBSUMsSUFBSUMsS0FBS0MsR0FBRyxDQUFDSDtJQUNqQkgsR0FBRyxDQUFDLEVBQUUsR0FBR0ksSUFBSUYsSUFBSSxDQUFDLEVBQUU7SUFDcEJGLEdBQUcsQ0FBQyxFQUFFLEdBQUdJLElBQUlGLElBQUksQ0FBQyxFQUFFO0lBQ3BCRixHQUFHLENBQUMsRUFBRSxHQUFHSSxJQUFJRixJQUFJLENBQUMsRUFBRTtJQUNwQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0ssS0FBS0UsR0FBRyxDQUFDSjtJQUNsQixPQUFPSDtBQUNYO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNRLFNBQVNSLEdBQUcsRUFBRVMsQ0FBQyxFQUFFQyxDQUFDO0lBQzlCLElBQUlDLEtBQUtGLENBQUMsQ0FBQyxFQUFFLEVBQ1RHLEtBQUtILENBQUMsQ0FBQyxFQUFFLEVBQ1RJLEtBQUtKLENBQUMsQ0FBQyxFQUFFLEVBQ1RLLEtBQUtMLENBQUMsQ0FBQyxFQUFFO0lBQ2IsSUFBSU0sS0FBS0wsQ0FBQyxDQUFDLEVBQUUsRUFDVE0sS0FBS04sQ0FBQyxDQUFDLEVBQUUsRUFDVE8sS0FBS1AsQ0FBQyxDQUFDLEVBQUUsRUFDVFEsS0FBS1IsQ0FBQyxDQUFDLEVBQUU7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TCxVQUFVLE9BQU87UUFDeEJoRCxHQUFHLENBQUMsRUFBRSxHQUFHaUQsS0FBS0csS0FBS0UsS0FBS0osS0FBS0MsS0FBS0U7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0MsS0FBS0csS0FBS0wsS0FBS0csS0FBS0M7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0MsS0FBS0osS0FBS0UsS0FBS0c7UUFDbEN0RCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0UsS0FBS0wsS0FBS0UsS0FBS0U7SUFDdEMsT0FBTyxJQUFJTCxVQUFVLE9BQU87UUFDeEJoRCxHQUFHLENBQUMsRUFBRSxHQUFHaUQsS0FBS0csS0FBS0UsS0FBS0osS0FBS0MsS0FBS0U7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0MsS0FBS0csS0FBS0wsS0FBS0csS0FBS0M7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0MsS0FBS0osS0FBS0UsS0FBS0c7UUFDbEN0RCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0UsS0FBS0wsS0FBS0UsS0FBS0U7SUFDdEMsT0FBTyxJQUFJTCxVQUFVLE9BQU87UUFDeEJoRCxHQUFHLENBQUMsRUFBRSxHQUFHaUQsS0FBS0csS0FBS0UsS0FBS0osS0FBS0MsS0FBS0U7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0MsS0FBS0csS0FBS0wsS0FBS0csS0FBS0M7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0MsS0FBS0osS0FBS0UsS0FBS0c7UUFDbEN0RCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0UsS0FBS0wsS0FBS0UsS0FBS0U7SUFDdEMsT0FBTyxJQUFJTCxVQUFVLE9BQU87UUFDeEJoRCxHQUFHLENBQUMsRUFBRSxHQUFHaUQsS0FBS0csS0FBS0UsS0FBS0osS0FBS0MsS0FBS0U7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0MsS0FBS0csS0FBS0wsS0FBS0csS0FBS0M7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0MsS0FBS0osS0FBS0UsS0FBS0c7UUFDbEN0RCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0UsS0FBS0wsS0FBS0UsS0FBS0U7SUFDdEMsT0FBTyxJQUFJTCxVQUFVLE9BQU87UUFDeEJoRCxHQUFHLENBQUMsRUFBRSxHQUFHaUQsS0FBS0csS0FBS0UsS0FBS0osS0FBS0MsS0FBS0U7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0MsS0FBS0csS0FBS0wsS0FBS0csS0FBS0M7UUFDbENyRCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0MsS0FBS0osS0FBS0UsS0FBS0c7UUFDbEN0RCxHQUFHLENBQUMsRUFBRSxHQUFHa0QsS0FBS0UsS0FBS0UsS0FBS0wsS0FBS0UsS0FBS0U7SUFDdEM7SUFFQSxPQUFPckQ7QUFDWDtBQUVBOzs7Ozs7O0NBT0MsR0FDTSxNQUFNdUQsT0FBT3pELDhDQUFTLENBQUM7QUFFOUI7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU0wRCxNQUFNMUQsNkNBQVEsQ0FBQztBQUU1Qjs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU0yRCxNQUFNM0QsNkNBQVEsQ0FBQztBQUU1Qjs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU00RCxRQUFRNUQsK0NBQVUsQ0FBQztBQUVoQzs7Ozs7OztDQU9DLEdBQ00sTUFBTXFDLE1BQU1yQyw2Q0FBUSxDQUFDO0FBRTVCOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU02RCxPQUFPN0QsOENBQVMsQ0FBQztBQUU5Qjs7Ozs7Q0FLQyxHQUNNLE1BQU04RCxTQUFTOUQsZ0RBQVcsQ0FBQztBQUVsQzs7Ozs7OztDQU9DLEdBQ00sTUFBTStELFlBQVkvRCxtREFBYyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL1F1YXRGdW5jLmpzP2JjMDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdmVjNCBmcm9tICcuL1ZlYzRGdW5jLmpzJztcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEF4aXNBbmdsZShvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXRzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIGxldCBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgbGV0IGJ4ID0gYlswXSxcbiAgICAgICAgYnkgPSBiWzFdLFxuICAgICAgICBieiA9IGJbMl0sXG4gICAgICAgIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTtcblxuICAgIGxldCBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgbGV0IGJ4ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTtcblxuICAgIGxldCBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgbGV0IGJ5ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTtcblxuICAgIGxldCBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgbGV0IGJ6ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIC8vIGJlbmNobWFya3M6XG4gICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcbiAgICBsZXQgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXSxcbiAgICAgICAgYXcgPSBhWzNdO1xuICAgIGxldCBieCA9IGJbMF0sXG4gICAgICAgIGJ5ID0gYlsxXSxcbiAgICAgICAgYnogPSBiWzJdLFxuICAgICAgICBidyA9IGJbM107XG5cbiAgICBsZXQgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgICBpZiAoY29zb20gPCAwLjApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLWJ4O1xuICAgICAgICBieSA9IC1ieTtcbiAgICAgICAgYnogPSAtYno7XG4gICAgICAgIGJ3ID0gLWJ3O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKDEuMCAtIGNvc29tID4gMC4wMDAwMDEpIHtcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZVxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgICBsZXQgYTAgPSBhWzBdLFxuICAgICAgICBhMSA9IGFbMV0sXG4gICAgICAgIGEyID0gYVsyXSxcbiAgICAgICAgYTMgPSBhWzNdO1xuICAgIGxldCBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICAgIGxldCBpbnZEb3QgPSBkb3QgPyAxLjAgLyBkb3QgOiAwO1xuXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCAqIGludkRvdDtcbiAgICBvdXRbMV0gPSAtYTEgKiBpbnZEb3Q7XG4gICAgb3V0WzJdID0gLWEyICogaW52RG90O1xuICAgIG91dFszXSA9IGEzICogaW52RG90O1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MyhvdXQsIG0pIHtcbiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAgIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICAgIGxldCBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gICAgbGV0IGZSb290O1xuXG4gICAgaWYgKGZUcmFjZSA+IDAuMCkge1xuICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7IC8vIDJ3XG4gICAgICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dylcbiAgICAgICAgb3V0WzBdID0gKG1bNV0gLSBtWzddKSAqIGZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVs2XSAtIG1bMl0pICogZlJvb3Q7XG4gICAgICAgIG91dFsyXSA9IChtWzFdIC0gbVszXSkgKiBmUm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB8d3wgPD0gMS8yXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgaWYgKG1bNF0gPiBtWzBdKSBpID0gMTtcbiAgICAgICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pIGkgPSAyO1xuICAgICAgICBsZXQgaiA9IChpICsgMSkgJSAzO1xuICAgICAgICBsZXQgayA9IChpICsgMikgJSAzO1xuXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSAqIDMgKyBpXSAtIG1baiAqIDMgKyBqXSAtIG1bayAqIDMgKyBrXSArIDEuMCk7XG4gICAgICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgICAgICBvdXRbM10gPSAobVtqICogMyArIGtdIC0gbVtrICogMyArIGpdKSAqIGZSb290O1xuICAgICAgICBvdXRbal0gPSAobVtqICogMyArIGldICsgbVtpICogMyArIGpdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrICogMyArIGldICsgbVtpICogMyArIGtdKSAqIGZSb290O1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gZXVsZXIgYW5nbGUgeCwgeSwgei5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gZXVsZXIgQW5nbGVzIHRvIHJvdGF0ZSBhcm91bmQgZWFjaCBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3JkZXIgZGV0YWlsaW5nIG9yZGVyIG9mIG9wZXJhdGlvbnMuIERlZmF1bHQgJ1hZWicuXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdWxlcihvdXQsIGV1bGVyLCBvcmRlciA9ICdZWFonKSB7XG4gICAgbGV0IHN4ID0gTWF0aC5zaW4oZXVsZXJbMF0gKiAwLjUpO1xuICAgIGxldCBjeCA9IE1hdGguY29zKGV1bGVyWzBdICogMC41KTtcbiAgICBsZXQgc3kgPSBNYXRoLnNpbihldWxlclsxXSAqIDAuNSk7XG4gICAgbGV0IGN5ID0gTWF0aC5jb3MoZXVsZXJbMV0gKiAwLjUpO1xuICAgIGxldCBzeiA9IE1hdGguc2luKGV1bGVyWzJdICogMC41KTtcbiAgICBsZXQgY3ogPSBNYXRoLmNvcyhldWxlclsyXSAqIDAuNSk7XG5cbiAgICBpZiAob3JkZXIgPT09ICdYWVonKSB7XG4gICAgICAgIG91dFswXSA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcbiAgICAgICAgb3V0WzFdID0gY3ggKiBzeSAqIGN6IC0gc3ggKiBjeSAqIHN6O1xuICAgICAgICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogKyBzeCAqIHN5ICogY3o7XG4gICAgICAgIG91dFszXSA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuICAgICAgICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XG4gICAgICAgIG91dFsxXSA9IGN4ICogc3kgKiBjeiAtIHN4ICogY3kgKiBzejtcbiAgICAgICAgb3V0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgICAgICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pYWScpIHtcbiAgICAgICAgb3V0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICAgICAgICBvdXRbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gICAgICAgIG91dFsyXSA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcbiAgICAgICAgb3V0WzNdID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWVgnKSB7XG4gICAgICAgIG91dFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgICAgICAgb3V0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICAgICAgICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gICAgICAgIG91dFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuICAgICAgICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XG4gICAgICAgIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgICAgICAgb3V0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgICAgICBvdXRbM10gPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1haWScpIHtcbiAgICAgICAgb3V0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICAgICAgICBvdXRbMV0gPSBjeCAqIHN5ICogY3ogLSBzeCAqIGN5ICogc3o7XG4gICAgICAgIG91dFsyXSA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcbiAgICAgICAgb3V0WzNdID0gY3ggKiBjeSAqIGN6ICsgc3ggKiBzeSAqIHN6O1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuIl0sIm5hbWVzIjpbInZlYzQiLCJpZGVudGl0eSIsIm91dCIsInNldEF4aXNBbmdsZSIsImF4aXMiLCJyYWQiLCJzIiwiTWF0aCIsInNpbiIsImNvcyIsIm11bHRpcGx5IiwiYSIsImIiLCJheCIsImF5IiwiYXoiLCJhdyIsImJ4IiwiYnkiLCJieiIsImJ3Iiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwic2xlcnAiLCJ0Iiwib21lZ2EiLCJjb3NvbSIsInNpbm9tIiwic2NhbGUwIiwic2NhbGUxIiwiYWNvcyIsImludmVydCIsImEwIiwiYTEiLCJhMiIsImEzIiwiZG90IiwiaW52RG90IiwiY29uanVnYXRlIiwiZnJvbU1hdDMiLCJtIiwiZlRyYWNlIiwiZlJvb3QiLCJzcXJ0IiwiaSIsImoiLCJrIiwiZnJvbUV1bGVyIiwiZXVsZXIiLCJvcmRlciIsInN4IiwiY3giLCJzeSIsImN5Iiwic3oiLCJjeiIsImNvcHkiLCJzZXQiLCJhZGQiLCJzY2FsZSIsImxlcnAiLCJsZW5ndGgiLCJub3JtYWxpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/functions/QuatFunc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/functions/Vec3Func.js":
/*!*********************************************************!*\
  !*** ./node_modules/ogl/src/math/functions/Vec3Func.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   angle: function() { return /* binding */ angle; },\n/* harmony export */   copy: function() { return /* binding */ copy; },\n/* harmony export */   cross: function() { return /* binding */ cross; },\n/* harmony export */   distance: function() { return /* binding */ distance; },\n/* harmony export */   divide: function() { return /* binding */ divide; },\n/* harmony export */   dot: function() { return /* binding */ dot; },\n/* harmony export */   exactEquals: function() { return /* binding */ exactEquals; },\n/* harmony export */   inverse: function() { return /* binding */ inverse; },\n/* harmony export */   length: function() { return /* binding */ length; },\n/* harmony export */   lerp: function() { return /* binding */ lerp; },\n/* harmony export */   multiply: function() { return /* binding */ multiply; },\n/* harmony export */   negate: function() { return /* binding */ negate; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   scale: function() { return /* binding */ scale; },\n/* harmony export */   scaleRotateMat4: function() { return /* binding */ scaleRotateMat4; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   smoothLerp: function() { return /* binding */ smoothLerp; },\n/* harmony export */   squaredDistance: function() { return /* binding */ squaredDistance; },\n/* harmony export */   squaredLength: function() { return /* binding */ squaredLength; },\n/* harmony export */   subtract: function() { return /* binding */ subtract; },\n/* harmony export */   transformMat3: function() { return /* binding */ transformMat3; },\n/* harmony export */   transformMat4: function() { return /* binding */ transformMat4; },\n/* harmony export */   transformQuat: function() { return /* binding */ transformQuat; }\n/* harmony export */ });\nconst EPSILON = 0.000001;\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */ function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */ function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */ function set(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */ function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */ function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */ function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */ function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */ function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */ function distance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */ function squaredDistance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */ function squaredLength(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */ function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */ function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    out[2] = 1.0 / a[2];\n    return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */ function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let len = x * x + y * y + z * z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    out[2] = a[2] * len;\n    return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */ function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */ function cross(out, a, b) {\n    let ax = a[0], ay = a[1], az = a[2];\n    let bx = b[0], by = b[1], bz = b[2];\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */ function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n}\n/**\n * Performs a frame rate independant, linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\n * @param {Number} dt delta time\n * @returns {vec3} out\n */ function smoothLerp(out, a, b, decay, dt) {\n    const exp = Math.exp(-decay * dt);\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    out[0] = b[0] + (ax - b[0]) * exp;\n    out[1] = b[1] + (ay - b[1]) * exp;\n    out[2] = b[2] + (az - b[2]) * exp;\n    return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */ function transformMat4(out, a, m) {\n    let x = a[0], y = a[1], z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n}\n/**\n * Same as above but doesn't apply translation.\n * Useful for rays.\n */ function scaleRotateMat4(out, a, m) {\n    let x = a[0], y = a[1], z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n    return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */ function transformMat3(out, a, m) {\n    let x = a[0], y = a[1], z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n}\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */ function transformQuat(out, a, q) {\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n    let x = a[0], y = a[1], z = a[2];\n    let qx = q[0], qy = q[1], qz = q[2], qw = q[3];\n    let uvx = qy * z - qz * y;\n    let uvy = qz * x - qx * z;\n    let uvz = qx * y - qy * x;\n    let uuvx = qy * uvz - qz * uvy;\n    let uuvy = qz * uvx - qx * uvz;\n    let uuvz = qx * uvy - qy * uvx;\n    let w2 = qw * 2;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n    uuvx *= 2;\n    uuvy *= 2;\n    uuvz *= 2;\n    out[0] = x + uvx + uuvx;\n    out[1] = y + uvy + uuvy;\n    out[2] = z + uvz + uuvz;\n    return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */ const angle = function() {\n    const tempA = [\n        0,\n        0,\n        0\n    ];\n    const tempB = [\n        0,\n        0,\n        0\n    ];\n    return function(a, b) {\n        copy(tempA, a);\n        copy(tempB, b);\n        normalize(tempA, tempA);\n        normalize(tempB, tempB);\n        let cosine = dot(tempA, tempB);\n        if (cosine > 1.0) {\n            return 0;\n        } else if (cosine < -1.0) {\n            return Math.PI;\n        } else {\n            return Math.acos(cosine);\n        }\n    };\n}();\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */ function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL1ZlYzNGdW5jLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLFVBQVU7QUFFaEI7Ozs7O0NBS0MsR0FDTSxTQUFTQyxPQUFPQyxDQUFDO0lBQ3BCLElBQUlDLElBQUlELENBQUMsQ0FBQyxFQUFFO0lBQ1osSUFBSUUsSUFBSUYsQ0FBQyxDQUFDLEVBQUU7SUFDWixJQUFJRyxJQUFJSCxDQUFDLENBQUMsRUFBRTtJQUNaLE9BQU9JLEtBQUtDLElBQUksQ0FBQ0osSUFBSUEsSUFBSUMsSUFBSUEsSUFBSUMsSUFBSUE7QUFDekM7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTRyxLQUFLQyxHQUFHLEVBQUVQLENBQUM7SUFDdkJPLEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFO0lBQ2JPLEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFO0lBQ2JPLEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFO0lBQ2IsT0FBT087QUFDWDtBQUVBOzs7Ozs7OztDQVFDLEdBQ00sU0FBU0MsSUFBSUQsR0FBRyxFQUFFTixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUM1QkksR0FBRyxDQUFDLEVBQUUsR0FBR047SUFDVE0sR0FBRyxDQUFDLEVBQUUsR0FBR0w7SUFDVEssR0FBRyxDQUFDLEVBQUUsR0FBR0o7SUFDVCxPQUFPSTtBQUNYO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNFLElBQUlGLEdBQUcsRUFBRVAsQ0FBQyxFQUFFVSxDQUFDO0lBQ3pCSCxHQUFHLENBQUMsRUFBRSxHQUFHUCxDQUFDLENBQUMsRUFBRSxHQUFHVSxDQUFDLENBQUMsRUFBRTtJQUNwQkgsR0FBRyxDQUFDLEVBQUUsR0FBR1AsQ0FBQyxDQUFDLEVBQUUsR0FBR1UsQ0FBQyxDQUFDLEVBQUU7SUFDcEJILEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdVLENBQUMsQ0FBQyxFQUFFO0lBQ3BCLE9BQU9IO0FBQ1g7QUFFQTs7Ozs7OztDQU9DLEdBQ00sU0FBU0ksU0FBU0osR0FBRyxFQUFFUCxDQUFDLEVBQUVVLENBQUM7SUFDOUJILEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdVLENBQUMsQ0FBQyxFQUFFO0lBQ3BCSCxHQUFHLENBQUMsRUFBRSxHQUFHUCxDQUFDLENBQUMsRUFBRSxHQUFHVSxDQUFDLENBQUMsRUFBRTtJQUNwQkgsR0FBRyxDQUFDLEVBQUUsR0FBR1AsQ0FBQyxDQUFDLEVBQUUsR0FBR1UsQ0FBQyxDQUFDLEVBQUU7SUFDcEIsT0FBT0g7QUFDWDtBQUVBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTSyxTQUFTTCxHQUFHLEVBQUVQLENBQUMsRUFBRVUsQ0FBQztJQUM5QkgsR0FBRyxDQUFDLEVBQUUsR0FBR1AsQ0FBQyxDQUFDLEVBQUUsR0FBR1UsQ0FBQyxDQUFDLEVBQUU7SUFDcEJILEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdVLENBQUMsQ0FBQyxFQUFFO0lBQ3BCSCxHQUFHLENBQUMsRUFBRSxHQUFHUCxDQUFDLENBQUMsRUFBRSxHQUFHVSxDQUFDLENBQUMsRUFBRTtJQUNwQixPQUFPSDtBQUNYO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNNLE9BQU9OLEdBQUcsRUFBRVAsQ0FBQyxFQUFFVSxDQUFDO0lBQzVCSCxHQUFHLENBQUMsRUFBRSxHQUFHUCxDQUFDLENBQUMsRUFBRSxHQUFHVSxDQUFDLENBQUMsRUFBRTtJQUNwQkgsR0FBRyxDQUFDLEVBQUUsR0FBR1AsQ0FBQyxDQUFDLEVBQUUsR0FBR1UsQ0FBQyxDQUFDLEVBQUU7SUFDcEJILEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdVLENBQUMsQ0FBQyxFQUFFO0lBQ3BCLE9BQU9IO0FBQ1g7QUFFQTs7Ozs7OztDQU9DLEdBQ00sU0FBU08sTUFBTVAsR0FBRyxFQUFFUCxDQUFDLEVBQUVVLENBQUM7SUFDM0JILEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdVO0lBQ2hCSCxHQUFHLENBQUMsRUFBRSxHQUFHUCxDQUFDLENBQUMsRUFBRSxHQUFHVTtJQUNoQkgsR0FBRyxDQUFDLEVBQUUsR0FBR1AsQ0FBQyxDQUFDLEVBQUUsR0FBR1U7SUFDaEIsT0FBT0g7QUFDWDtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNRLFNBQVNmLENBQUMsRUFBRVUsQ0FBQztJQUN6QixJQUFJVCxJQUFJUyxDQUFDLENBQUMsRUFBRSxHQUFHVixDQUFDLENBQUMsRUFBRTtJQUNuQixJQUFJRSxJQUFJUSxDQUFDLENBQUMsRUFBRSxHQUFHVixDQUFDLENBQUMsRUFBRTtJQUNuQixJQUFJRyxJQUFJTyxDQUFDLENBQUMsRUFBRSxHQUFHVixDQUFDLENBQUMsRUFBRTtJQUNuQixPQUFPSSxLQUFLQyxJQUFJLENBQUNKLElBQUlBLElBQUlDLElBQUlBLElBQUlDLElBQUlBO0FBQ3pDO0FBRUE7Ozs7OztDQU1DLEdBQ00sU0FBU2EsZ0JBQWdCaEIsQ0FBQyxFQUFFVSxDQUFDO0lBQ2hDLElBQUlULElBQUlTLENBQUMsQ0FBQyxFQUFFLEdBQUdWLENBQUMsQ0FBQyxFQUFFO0lBQ25CLElBQUlFLElBQUlRLENBQUMsQ0FBQyxFQUFFLEdBQUdWLENBQUMsQ0FBQyxFQUFFO0lBQ25CLElBQUlHLElBQUlPLENBQUMsQ0FBQyxFQUFFLEdBQUdWLENBQUMsQ0FBQyxFQUFFO0lBQ25CLE9BQU9DLElBQUlBLElBQUlDLElBQUlBLElBQUlDLElBQUlBO0FBQy9CO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTYyxjQUFjakIsQ0FBQztJQUMzQixJQUFJQyxJQUFJRCxDQUFDLENBQUMsRUFBRTtJQUNaLElBQUlFLElBQUlGLENBQUMsQ0FBQyxFQUFFO0lBQ1osSUFBSUcsSUFBSUgsQ0FBQyxDQUFDLEVBQUU7SUFDWixPQUFPQyxJQUFJQSxJQUFJQyxJQUFJQSxJQUFJQyxJQUFJQTtBQUMvQjtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNlLE9BQU9YLEdBQUcsRUFBRVAsQ0FBQztJQUN6Qk8sR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDUCxDQUFDLENBQUMsRUFBRTtJQUNkTyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUNQLENBQUMsQ0FBQyxFQUFFO0lBQ2RPLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQ1AsQ0FBQyxDQUFDLEVBQUU7SUFDZCxPQUFPTztBQUNYO0FBRUE7Ozs7OztDQU1DLEdBQ00sU0FBU1ksUUFBUVosR0FBRyxFQUFFUCxDQUFDO0lBQzFCTyxHQUFHLENBQUMsRUFBRSxHQUFHLE1BQU1QLENBQUMsQ0FBQyxFQUFFO0lBQ25CTyxHQUFHLENBQUMsRUFBRSxHQUFHLE1BQU1QLENBQUMsQ0FBQyxFQUFFO0lBQ25CTyxHQUFHLENBQUMsRUFBRSxHQUFHLE1BQU1QLENBQUMsQ0FBQyxFQUFFO0lBQ25CLE9BQU9PO0FBQ1g7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTYSxVQUFVYixHQUFHLEVBQUVQLENBQUM7SUFDNUIsSUFBSUMsSUFBSUQsQ0FBQyxDQUFDLEVBQUU7SUFDWixJQUFJRSxJQUFJRixDQUFDLENBQUMsRUFBRTtJQUNaLElBQUlHLElBQUlILENBQUMsQ0FBQyxFQUFFO0lBQ1osSUFBSXFCLE1BQU1wQixJQUFJQSxJQUFJQyxJQUFJQSxJQUFJQyxJQUFJQTtJQUM5QixJQUFJa0IsTUFBTSxHQUFHO1FBQ1QseUNBQXlDO1FBQ3pDQSxNQUFNLElBQUlqQixLQUFLQyxJQUFJLENBQUNnQjtJQUN4QjtJQUNBZCxHQUFHLENBQUMsRUFBRSxHQUFHUCxDQUFDLENBQUMsRUFBRSxHQUFHcUI7SUFDaEJkLEdBQUcsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdxQjtJQUNoQmQsR0FBRyxDQUFDLEVBQUUsR0FBR1AsQ0FBQyxDQUFDLEVBQUUsR0FBR3FCO0lBQ2hCLE9BQU9kO0FBQ1g7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTZSxJQUFJdEIsQ0FBQyxFQUFFVSxDQUFDO0lBQ3BCLE9BQU9WLENBQUMsQ0FBQyxFQUFFLEdBQUdVLENBQUMsQ0FBQyxFQUFFLEdBQUdWLENBQUMsQ0FBQyxFQUFFLEdBQUdVLENBQUMsQ0FBQyxFQUFFLEdBQUdWLENBQUMsQ0FBQyxFQUFFLEdBQUdVLENBQUMsQ0FBQyxFQUFFO0FBQ2xEO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNhLE1BQU1oQixHQUFHLEVBQUVQLENBQUMsRUFBRVUsQ0FBQztJQUMzQixJQUFJYyxLQUFLeEIsQ0FBQyxDQUFDLEVBQUUsRUFDVHlCLEtBQUt6QixDQUFDLENBQUMsRUFBRSxFQUNUMEIsS0FBSzFCLENBQUMsQ0FBQyxFQUFFO0lBQ2IsSUFBSTJCLEtBQUtqQixDQUFDLENBQUMsRUFBRSxFQUNUa0IsS0FBS2xCLENBQUMsQ0FBQyxFQUFFLEVBQ1RtQixLQUFLbkIsQ0FBQyxDQUFDLEVBQUU7SUFFYkgsR0FBRyxDQUFDLEVBQUUsR0FBR2tCLEtBQUtJLEtBQUtILEtBQUtFO0lBQ3hCckIsR0FBRyxDQUFDLEVBQUUsR0FBR21CLEtBQUtDLEtBQUtILEtBQUtLO0lBQ3hCdEIsR0FBRyxDQUFDLEVBQUUsR0FBR2lCLEtBQUtJLEtBQUtILEtBQUtFO0lBQ3hCLE9BQU9wQjtBQUNYO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTdUIsS0FBS3ZCLEdBQUcsRUFBRVAsQ0FBQyxFQUFFVSxDQUFDLEVBQUVxQixDQUFDO0lBQzdCLElBQUlQLEtBQUt4QixDQUFDLENBQUMsRUFBRTtJQUNiLElBQUl5QixLQUFLekIsQ0FBQyxDQUFDLEVBQUU7SUFDYixJQUFJMEIsS0FBSzFCLENBQUMsQ0FBQyxFQUFFO0lBQ2JPLEdBQUcsQ0FBQyxFQUFFLEdBQUdpQixLQUFLTyxJQUFLckIsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR2MsRUFBQztJQUMzQmpCLEdBQUcsQ0FBQyxFQUFFLEdBQUdrQixLQUFLTSxJQUFLckIsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR2UsRUFBQztJQUMzQmxCLEdBQUcsQ0FBQyxFQUFFLEdBQUdtQixLQUFLSyxJQUFLckIsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR2dCLEVBQUM7SUFDM0IsT0FBT25CO0FBQ1g7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDTSxTQUFTeUIsV0FBV3pCLEdBQUcsRUFBRVAsQ0FBQyxFQUFFVSxDQUFDLEVBQUV1QixLQUFLLEVBQUVDLEVBQUU7SUFDM0MsTUFBTUMsTUFBTS9CLEtBQUsrQixHQUFHLENBQUMsQ0FBQ0YsUUFBUUM7SUFDOUIsSUFBSVYsS0FBS3hCLENBQUMsQ0FBQyxFQUFFO0lBQ2IsSUFBSXlCLEtBQUt6QixDQUFDLENBQUMsRUFBRTtJQUNiLElBQUkwQixLQUFLMUIsQ0FBQyxDQUFDLEVBQUU7SUFFYk8sR0FBRyxDQUFDLEVBQUUsR0FBR0csQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDYyxLQUFLZCxDQUFDLENBQUMsRUFBRSxJQUFJeUI7SUFDOUI1QixHQUFHLENBQUMsRUFBRSxHQUFHRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUNlLEtBQUtmLENBQUMsQ0FBQyxFQUFFLElBQUl5QjtJQUM5QjVCLEdBQUcsQ0FBQyxFQUFFLEdBQUdHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQ2dCLEtBQUtoQixDQUFDLENBQUMsRUFBRSxJQUFJeUI7SUFDOUIsT0FBTzVCO0FBQ1g7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVM2QixjQUFjN0IsR0FBRyxFQUFFUCxDQUFDLEVBQUVxQyxDQUFDO0lBQ25DLElBQUlwQyxJQUFJRCxDQUFDLENBQUMsRUFBRSxFQUNSRSxJQUFJRixDQUFDLENBQUMsRUFBRSxFQUNSRyxJQUFJSCxDQUFDLENBQUMsRUFBRTtJQUNaLElBQUlzQyxJQUFJRCxDQUFDLENBQUMsRUFBRSxHQUFHcEMsSUFBSW9DLENBQUMsQ0FBQyxFQUFFLEdBQUduQyxJQUFJbUMsQ0FBQyxDQUFDLEdBQUcsR0FBR2xDLElBQUlrQyxDQUFDLENBQUMsR0FBRztJQUMvQ0MsSUFBSUEsS0FBSztJQUNUL0IsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDOEIsQ0FBQyxDQUFDLEVBQUUsR0FBR3BDLElBQUlvQyxDQUFDLENBQUMsRUFBRSxHQUFHbkMsSUFBSW1DLENBQUMsQ0FBQyxFQUFFLEdBQUdsQyxJQUFJa0MsQ0FBQyxDQUFDLEdBQUcsSUFBSUM7SUFDcEQvQixHQUFHLENBQUMsRUFBRSxHQUFHLENBQUM4QixDQUFDLENBQUMsRUFBRSxHQUFHcEMsSUFBSW9DLENBQUMsQ0FBQyxFQUFFLEdBQUduQyxJQUFJbUMsQ0FBQyxDQUFDLEVBQUUsR0FBR2xDLElBQUlrQyxDQUFDLENBQUMsR0FBRyxJQUFJQztJQUNwRC9CLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQzhCLENBQUMsQ0FBQyxFQUFFLEdBQUdwQyxJQUFJb0MsQ0FBQyxDQUFDLEVBQUUsR0FBR25DLElBQUltQyxDQUFDLENBQUMsR0FBRyxHQUFHbEMsSUFBSWtDLENBQUMsQ0FBQyxHQUFHLElBQUlDO0lBQ3JELE9BQU8vQjtBQUNYO0FBRUE7OztDQUdDLEdBQ00sU0FBU2dDLGdCQUFnQmhDLEdBQUcsRUFBRVAsQ0FBQyxFQUFFcUMsQ0FBQztJQUNyQyxJQUFJcEMsSUFBSUQsQ0FBQyxDQUFDLEVBQUUsRUFDUkUsSUFBSUYsQ0FBQyxDQUFDLEVBQUUsRUFDUkcsSUFBSUgsQ0FBQyxDQUFDLEVBQUU7SUFDWixJQUFJc0MsSUFBSUQsQ0FBQyxDQUFDLEVBQUUsR0FBR3BDLElBQUlvQyxDQUFDLENBQUMsRUFBRSxHQUFHbkMsSUFBSW1DLENBQUMsQ0FBQyxHQUFHLEdBQUdsQyxJQUFJa0MsQ0FBQyxDQUFDLEdBQUc7SUFDL0NDLElBQUlBLEtBQUs7SUFDVC9CLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQzhCLENBQUMsQ0FBQyxFQUFFLEdBQUdwQyxJQUFJb0MsQ0FBQyxDQUFDLEVBQUUsR0FBR25DLElBQUltQyxDQUFDLENBQUMsRUFBRSxHQUFHbEMsQ0FBQUEsSUFBS21DO0lBQzVDL0IsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDOEIsQ0FBQyxDQUFDLEVBQUUsR0FBR3BDLElBQUlvQyxDQUFDLENBQUMsRUFBRSxHQUFHbkMsSUFBSW1DLENBQUMsQ0FBQyxFQUFFLEdBQUdsQyxDQUFBQSxJQUFLbUM7SUFDNUMvQixHQUFHLENBQUMsRUFBRSxHQUFHLENBQUM4QixDQUFDLENBQUMsRUFBRSxHQUFHcEMsSUFBSW9DLENBQUMsQ0FBQyxFQUFFLEdBQUduQyxJQUFJbUMsQ0FBQyxDQUFDLEdBQUcsR0FBR2xDLENBQUFBLElBQUttQztJQUM3QyxPQUFPL0I7QUFDWDtBQUVBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTaUMsY0FBY2pDLEdBQUcsRUFBRVAsQ0FBQyxFQUFFcUMsQ0FBQztJQUNuQyxJQUFJcEMsSUFBSUQsQ0FBQyxDQUFDLEVBQUUsRUFDUkUsSUFBSUYsQ0FBQyxDQUFDLEVBQUUsRUFDUkcsSUFBSUgsQ0FBQyxDQUFDLEVBQUU7SUFDWk8sR0FBRyxDQUFDLEVBQUUsR0FBR04sSUFBSW9DLENBQUMsQ0FBQyxFQUFFLEdBQUduQyxJQUFJbUMsQ0FBQyxDQUFDLEVBQUUsR0FBR2xDLElBQUlrQyxDQUFDLENBQUMsRUFBRTtJQUN2QzlCLEdBQUcsQ0FBQyxFQUFFLEdBQUdOLElBQUlvQyxDQUFDLENBQUMsRUFBRSxHQUFHbkMsSUFBSW1DLENBQUMsQ0FBQyxFQUFFLEdBQUdsQyxJQUFJa0MsQ0FBQyxDQUFDLEVBQUU7SUFDdkM5QixHQUFHLENBQUMsRUFBRSxHQUFHTixJQUFJb0MsQ0FBQyxDQUFDLEVBQUUsR0FBR25DLElBQUltQyxDQUFDLENBQUMsRUFBRSxHQUFHbEMsSUFBSWtDLENBQUMsQ0FBQyxFQUFFO0lBQ3ZDLE9BQU85QjtBQUNYO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNrQyxjQUFjbEMsR0FBRyxFQUFFUCxDQUFDLEVBQUUwQyxDQUFDO0lBQ25DLGlGQUFpRjtJQUVqRixJQUFJekMsSUFBSUQsQ0FBQyxDQUFDLEVBQUUsRUFDUkUsSUFBSUYsQ0FBQyxDQUFDLEVBQUUsRUFDUkcsSUFBSUgsQ0FBQyxDQUFDLEVBQUU7SUFDWixJQUFJMkMsS0FBS0QsQ0FBQyxDQUFDLEVBQUUsRUFDVEUsS0FBS0YsQ0FBQyxDQUFDLEVBQUUsRUFDVEcsS0FBS0gsQ0FBQyxDQUFDLEVBQUUsRUFDVEksS0FBS0osQ0FBQyxDQUFDLEVBQUU7SUFFYixJQUFJSyxNQUFNSCxLQUFLekMsSUFBSTBDLEtBQUszQztJQUN4QixJQUFJOEMsTUFBTUgsS0FBSzVDLElBQUkwQyxLQUFLeEM7SUFDeEIsSUFBSThDLE1BQU1OLEtBQUt6QyxJQUFJMEMsS0FBSzNDO0lBRXhCLElBQUlpRCxPQUFPTixLQUFLSyxNQUFNSixLQUFLRztJQUMzQixJQUFJRyxPQUFPTixLQUFLRSxNQUFNSixLQUFLTTtJQUMzQixJQUFJRyxPQUFPVCxLQUFLSyxNQUFNSixLQUFLRztJQUUzQixJQUFJTSxLQUFLUCxLQUFLO0lBQ2RDLE9BQU9NO0lBQ1BMLE9BQU9LO0lBQ1BKLE9BQU9JO0lBRVBILFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBRVI3QyxHQUFHLENBQUMsRUFBRSxHQUFHTixJQUFJOEMsTUFBTUc7SUFDbkIzQyxHQUFHLENBQUMsRUFBRSxHQUFHTCxJQUFJOEMsTUFBTUc7SUFDbkI1QyxHQUFHLENBQUMsRUFBRSxHQUFHSixJQUFJOEMsTUFBTUc7SUFDbkIsT0FBTzdDO0FBQ1g7QUFFQTs7Ozs7Q0FLQyxHQUNNLE1BQU0rQyxRQUFRO0lBQ2pCLE1BQU1DLFFBQVE7UUFBQztRQUFHO1FBQUc7S0FBRTtJQUN2QixNQUFNQyxRQUFRO1FBQUM7UUFBRztRQUFHO0tBQUU7SUFFdkIsT0FBTyxTQUFVeEQsQ0FBQyxFQUFFVSxDQUFDO1FBQ2pCSixLQUFLaUQsT0FBT3ZEO1FBQ1pNLEtBQUtrRCxPQUFPOUM7UUFFWlUsVUFBVW1DLE9BQU9BO1FBQ2pCbkMsVUFBVW9DLE9BQU9BO1FBRWpCLElBQUlDLFNBQVNuQyxJQUFJaUMsT0FBT0M7UUFFeEIsSUFBSUMsU0FBUyxLQUFLO1lBQ2QsT0FBTztRQUNYLE9BQU8sSUFBSUEsU0FBUyxDQUFDLEtBQUs7WUFDdEIsT0FBT3JELEtBQUtzRCxFQUFFO1FBQ2xCLE9BQU87WUFDSCxPQUFPdEQsS0FBS3VELElBQUksQ0FBQ0Y7UUFDckI7SUFDSjtBQUNKLElBQUs7QUFFTDs7Ozs7O0NBTUMsR0FDTSxTQUFTRyxZQUFZNUQsQ0FBQyxFQUFFVSxDQUFDO0lBQzVCLE9BQU9WLENBQUMsQ0FBQyxFQUFFLEtBQUtVLENBQUMsQ0FBQyxFQUFFLElBQUlWLENBQUMsQ0FBQyxFQUFFLEtBQUtVLENBQUMsQ0FBQyxFQUFFLElBQUlWLENBQUMsQ0FBQyxFQUFFLEtBQUtVLENBQUMsQ0FBQyxFQUFFO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL1ZlYzNGdW5jLmpzPzMwYTQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIGxldCB4ID0gYVswXTtcbiAgICBsZXQgeSA9IGFbMV07XG4gICAgbGV0IHogPSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICAgIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gICAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICAgIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgbGV0IHggPSBhWzBdO1xuICAgIGxldCB5ID0gYVsxXTtcbiAgICBsZXQgeiA9IGFbMl07XG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICAgIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgbGV0IHggPSBhWzBdO1xuICAgIGxldCB5ID0gYVsxXTtcbiAgICBsZXQgeiA9IGFbMl07XG4gICAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgfVxuICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgICBsZXQgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBsZXQgYnggPSBiWzBdLFxuICAgICAgICBieSA9IGJbMV0sXG4gICAgICAgIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIGxldCBheCA9IGFbMF07XG4gICAgbGV0IGF5ID0gYVsxXTtcbiAgICBsZXQgYXogPSBhWzJdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBmcmFtZSByYXRlIGluZGVwZW5kYW50LCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gZGVjYXkgZGVjYXkgY29uc3RhbnQgZm9yIGludGVycG9sYXRpb24uIHVzZWZ1bCByYW5nZSBiZXR3ZWVuIDEgYW5kIDI1LCBmcm9tIHNsb3cgdG8gZmFzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBkZWx0YSB0aW1lXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbW9vdGhMZXJwKG91dCwgYSwgYiwgZGVjYXksIGR0KSB7XG4gICAgY29uc3QgZXhwID0gTWF0aC5leHAoLWRlY2F5ICogZHQpO1xuICAgIGxldCBheCA9IGFbMF07XG4gICAgbGV0IGF5ID0gYVsxXTtcbiAgICBsZXQgYXogPSBhWzJdO1xuXG4gICAgb3V0WzBdID0gYlswXSArIChheCAtIGJbMF0pICogZXhwO1xuICAgIG91dFsxXSA9IGJbMV0gKyAoYXkgLSBiWzFdKSAqIGV4cDtcbiAgICBvdXRbMl0gPSBiWzJdICsgKGF6IC0gYlsyXSkgKiBleHA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIGxldCB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIGxldCB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTYW1lIGFzIGFib3ZlIGJ1dCBkb2Vzbid0IGFwcGx5IHRyYW5zbGF0aW9uLlxuICogVXNlZnVsIGZvciByYXlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVSb3RhdGVNYXQ0KG91dCwgYSwgbSkge1xuICAgIGxldCB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIGxldCB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6KSAvIHc7XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeikgLyB3O1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6KSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICBsZXQgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcblxuICAgIGxldCB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIGxldCBxeCA9IHFbMF0sXG4gICAgICAgIHF5ID0gcVsxXSxcbiAgICAgICAgcXogPSBxWzJdLFxuICAgICAgICBxdyA9IHFbM107XG5cbiAgICBsZXQgdXZ4ID0gcXkgKiB6IC0gcXogKiB5O1xuICAgIGxldCB1dnkgPSBxeiAqIHggLSBxeCAqIHo7XG4gICAgbGV0IHV2eiA9IHF4ICogeSAtIHF5ICogeDtcblxuICAgIGxldCB1dXZ4ID0gcXkgKiB1dnogLSBxeiAqIHV2eTtcbiAgICBsZXQgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dno7XG4gICAgbGV0IHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4O1xuXG4gICAgbGV0IHcyID0gcXcgKiAyO1xuICAgIHV2eCAqPSB3MjtcbiAgICB1dnkgKj0gdzI7XG4gICAgdXZ6ICo9IHcyO1xuXG4gICAgdXV2eCAqPSAyO1xuICAgIHV1dnkgKj0gMjtcbiAgICB1dXZ6ICo9IDI7XG5cbiAgICBvdXRbMF0gPSB4ICsgdXZ4ICsgdXV2eDtcbiAgICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgY29uc3QgYW5nbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHRlbXBBID0gWzAsIDAsIDBdO1xuICAgIGNvbnN0IHRlbXBCID0gWzAsIDAsIDBdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvcHkodGVtcEEsIGEpO1xuICAgICAgICBjb3B5KHRlbXBCLCBiKTtcblxuICAgICAgICBub3JtYWxpemUodGVtcEEsIHRlbXBBKTtcbiAgICAgICAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG5cbiAgICAgICAgbGV0IGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpO1xuXG4gICAgICAgIGlmIChjb3NpbmUgPiAxLjApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKGNvc2luZSA8IC0xLjApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG4iXSwibmFtZXMiOlsiRVBTSUxPTiIsImxlbmd0aCIsImEiLCJ4IiwieSIsInoiLCJNYXRoIiwic3FydCIsImNvcHkiLCJvdXQiLCJzZXQiLCJhZGQiLCJiIiwic3VidHJhY3QiLCJtdWx0aXBseSIsImRpdmlkZSIsInNjYWxlIiwiZGlzdGFuY2UiLCJzcXVhcmVkRGlzdGFuY2UiLCJzcXVhcmVkTGVuZ3RoIiwibmVnYXRlIiwiaW52ZXJzZSIsIm5vcm1hbGl6ZSIsImxlbiIsImRvdCIsImNyb3NzIiwiYXgiLCJheSIsImF6IiwiYngiLCJieSIsImJ6IiwibGVycCIsInQiLCJzbW9vdGhMZXJwIiwiZGVjYXkiLCJkdCIsImV4cCIsInRyYW5zZm9ybU1hdDQiLCJtIiwidyIsInNjYWxlUm90YXRlTWF0NCIsInRyYW5zZm9ybU1hdDMiLCJ0cmFuc2Zvcm1RdWF0IiwicSIsInF4IiwicXkiLCJxeiIsInF3IiwidXZ4IiwidXZ5IiwidXZ6IiwidXV2eCIsInV1dnkiLCJ1dXZ6IiwidzIiLCJhbmdsZSIsInRlbXBBIiwidGVtcEIiLCJjb3NpbmUiLCJQSSIsImFjb3MiLCJleGFjdEVxdWFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/functions/Vec3Func.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ogl/src/math/functions/Vec4Func.js":
/*!*********************************************************!*\
  !*** ./node_modules/ogl/src/math/functions/Vec4Func.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   copy: function() { return /* binding */ copy; },\n/* harmony export */   dot: function() { return /* binding */ dot; },\n/* harmony export */   length: function() { return /* binding */ length; },\n/* harmony export */   lerp: function() { return /* binding */ lerp; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   scale: function() { return /* binding */ scale; },\n/* harmony export */   set: function() { return /* binding */ set; }\n/* harmony export */ });\nconst EPSILON = 0.000001;\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */ function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */ function set(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */ function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */ function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */ function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */ function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    let len = x * x + y * y + z * z + w * w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = x * len;\n    out[1] = y * len;\n    out[2] = z * len;\n    out[3] = w * len;\n    return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */ function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */ function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    let aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vZ2wvc3JjL21hdGgvZnVuY3Rpb25zL1ZlYzRGdW5jLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsTUFBTUEsVUFBVTtBQUVoQjs7Ozs7O0NBTUMsR0FDTSxTQUFTQyxLQUFLQyxHQUFHLEVBQUVDLENBQUM7SUFDdkJELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2JELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO0lBQ2IsT0FBT0Q7QUFDWDtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNNLFNBQVNFLElBQUlGLEdBQUcsRUFBRUcsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUMvQk4sR0FBRyxDQUFDLEVBQUUsR0FBR0c7SUFDVEgsR0FBRyxDQUFDLEVBQUUsR0FBR0k7SUFDVEosR0FBRyxDQUFDLEVBQUUsR0FBR0s7SUFDVEwsR0FBRyxDQUFDLEVBQUUsR0FBR007SUFDVCxPQUFPTjtBQUNYO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNPLElBQUlQLEdBQUcsRUFBRUMsQ0FBQyxFQUFFTyxDQUFDO0lBQ3pCUixHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHTyxDQUFDLENBQUMsRUFBRTtJQUNwQlIsR0FBRyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR08sQ0FBQyxDQUFDLEVBQUU7SUFDcEJSLEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdPLENBQUMsQ0FBQyxFQUFFO0lBQ3BCUixHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHTyxDQUFDLENBQUMsRUFBRTtJQUNwQixPQUFPUjtBQUNYO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNTLE1BQU1ULEdBQUcsRUFBRUMsQ0FBQyxFQUFFTyxDQUFDO0lBQzNCUixHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHTztJQUNoQlIsR0FBRyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsR0FBR087SUFDaEJSLEdBQUcsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdPO0lBQ2hCUixHQUFHLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHTztJQUNoQixPQUFPUjtBQUNYO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTVSxPQUFPVCxDQUFDO0lBQ3BCLElBQUlFLElBQUlGLENBQUMsQ0FBQyxFQUFFO0lBQ1osSUFBSUcsSUFBSUgsQ0FBQyxDQUFDLEVBQUU7SUFDWixJQUFJSSxJQUFJSixDQUFDLENBQUMsRUFBRTtJQUNaLElBQUlLLElBQUlMLENBQUMsQ0FBQyxFQUFFO0lBQ1osT0FBT1UsS0FBS0MsSUFBSSxDQUFDVCxJQUFJQSxJQUFJQyxJQUFJQSxJQUFJQyxJQUFJQSxJQUFJQyxJQUFJQTtBQUNqRDtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNPLFVBQVViLEdBQUcsRUFBRUMsQ0FBQztJQUM1QixJQUFJRSxJQUFJRixDQUFDLENBQUMsRUFBRTtJQUNaLElBQUlHLElBQUlILENBQUMsQ0FBQyxFQUFFO0lBQ1osSUFBSUksSUFBSUosQ0FBQyxDQUFDLEVBQUU7SUFDWixJQUFJSyxJQUFJTCxDQUFDLENBQUMsRUFBRTtJQUNaLElBQUlhLE1BQU1YLElBQUlBLElBQUlDLElBQUlBLElBQUlDLElBQUlBLElBQUlDLElBQUlBO0lBQ3RDLElBQUlRLE1BQU0sR0FBRztRQUNUQSxNQUFNLElBQUlILEtBQUtDLElBQUksQ0FBQ0U7SUFDeEI7SUFDQWQsR0FBRyxDQUFDLEVBQUUsR0FBR0csSUFBSVc7SUFDYmQsR0FBRyxDQUFDLEVBQUUsR0FBR0ksSUFBSVU7SUFDYmQsR0FBRyxDQUFDLEVBQUUsR0FBR0ssSUFBSVM7SUFDYmQsR0FBRyxDQUFDLEVBQUUsR0FBR00sSUFBSVE7SUFDYixPQUFPZDtBQUNYO0FBRUE7Ozs7OztDQU1DLEdBQ00sU0FBU2UsSUFBSWQsQ0FBQyxFQUFFTyxDQUFDO0lBQ3BCLE9BQU9QLENBQUMsQ0FBQyxFQUFFLEdBQUdPLENBQUMsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdPLENBQUMsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdPLENBQUMsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxFQUFFLEdBQUdPLENBQUMsQ0FBQyxFQUFFO0FBQ2hFO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTUSxLQUFLaEIsR0FBRyxFQUFFQyxDQUFDLEVBQUVPLENBQUMsRUFBRVMsQ0FBQztJQUM3QixJQUFJQyxLQUFLakIsQ0FBQyxDQUFDLEVBQUU7SUFDYixJQUFJa0IsS0FBS2xCLENBQUMsQ0FBQyxFQUFFO0lBQ2IsSUFBSW1CLEtBQUtuQixDQUFDLENBQUMsRUFBRTtJQUNiLElBQUlvQixLQUFLcEIsQ0FBQyxDQUFDLEVBQUU7SUFDYkQsR0FBRyxDQUFDLEVBQUUsR0FBR2tCLEtBQUtELElBQUtULENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUdVLEVBQUM7SUFDM0JsQixHQUFHLENBQUMsRUFBRSxHQUFHbUIsS0FBS0YsSUFBS1QsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR1csRUFBQztJQUMzQm5CLEdBQUcsQ0FBQyxFQUFFLEdBQUdvQixLQUFLSCxJQUFLVCxDQUFBQSxDQUFDLENBQUMsRUFBRSxHQUFHWSxFQUFDO0lBQzNCcEIsR0FBRyxDQUFDLEVBQUUsR0FBR3FCLEtBQUtKLElBQUtULENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUdhLEVBQUM7SUFDM0IsT0FBT3JCO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29nbC9zcmMvbWF0aC9mdW5jdGlvbnMvVmVjNEZ1bmMuanM/OGFkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFUFNJTE9OID0gMC4wMDAwMDE7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgbGV0IHggPSBhWzBdO1xuICAgIGxldCB5ID0gYVsxXTtcbiAgICBsZXQgeiA9IGFbMl07XG4gICAgbGV0IHcgPSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcpO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICBsZXQgeCA9IGFbMF07XG4gICAgbGV0IHkgPSBhWzFdO1xuICAgIGxldCB6ID0gYVsyXTtcbiAgICBsZXQgdyA9IGFbM107XG4gICAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB9XG4gICAgb3V0WzBdID0geCAqIGxlbjtcbiAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgIG91dFsyXSA9IHogKiBsZW47XG4gICAgb3V0WzNdID0gdyAqIGxlbjtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgICBsZXQgYXggPSBhWzBdO1xuICAgIGxldCBheSA9IGFbMV07XG4gICAgbGV0IGF6ID0gYVsyXTtcbiAgICBsZXQgYXcgPSBhWzNdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICAgIHJldHVybiBvdXQ7XG59XG4iXSwibmFtZXMiOlsiRVBTSUxPTiIsImNvcHkiLCJvdXQiLCJhIiwic2V0IiwieCIsInkiLCJ6IiwidyIsImFkZCIsImIiLCJzY2FsZSIsImxlbmd0aCIsIk1hdGgiLCJzcXJ0Iiwibm9ybWFsaXplIiwibGVuIiwiZG90IiwibGVycCIsInQiLCJheCIsImF5IiwiYXoiLCJhdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ogl/src/math/functions/Vec4Func.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CNavbar.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Ccomponents%5CParticles.js&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Space_Grotesk%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-heading%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22spaceGrotesk%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Manrope%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-body%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22manrope%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.js%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-signature%22%2C%22display%22%3A%22swap%22%7D%5D%2C%22variableName%22%3A%22signature%22%7D&modules=C%3A%5CUsers%5CUSER%5CDownloads%5Cpot%5Cbus-transport-app%5Capp%5Cglobals.css&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);